// Generated by .

	public partial class GameDefine 
	{
		//===========================================================================
		// Blizzard.j ( define Jass2 functions that need to be in every map script )
		//===========================================================================
		//-----------------------------------------------------------------------
		// Constants
		//
		// Misc constants
		public static double PI = 3.14159;
		public static double E = 2.71828;
		public static double CELLWIDTH = 128.0;
		public static double CLIFFHEIGHT = 128.0;
		public static double UNIT_FACING = 270.0;
		public static double RADTODEG = 180.0/PI;
		public static double DEGTORAD = PI/180.0;
		public static double TEXT_DELAY_QUEST = 20.00;
		public static double TEXT_DELAY_QUESTUPDATE = 20.00;
		public static double TEXT_DELAY_QUESTDONE = 20.00;
		public static double TEXT_DELAY_QUESTFAILED = 20.00;
		public static double TEXT_DELAY_QUESTREQUIREMENT = 20.00;
		public static double TEXT_DELAY_MISSIONFAILED = 20.00;
		public static double TEXT_DELAY_ALWAYSHINT = 12.00;
		public static double TEXT_DELAY_HINT = 12.00;
		public static double TEXT_DELAY_SECRET = 10.00;
		public static double TEXT_DELAY_UNITACQUIRED = 15.00;
		public static double TEXT_DELAY_UNITAVAILABLE = 10.00;
		public static double TEXT_DELAY_ITEMACQUIRED = 10.00;
		public static double TEXT_DELAY_WARNING = 12.00;
		public static double QUEUE_DELAY_QUEST = 5.00;
		public static double QUEUE_DELAY_HINT = 5.00;
		public static double QUEUE_DELAY_SECRET = 3.00;
		public static double HANDICAP_EASY = 60.00;
		public static double GAME_STARTED_THRESHOLD = 0.01;
		public static double WAIT_FOR_COND_MIN_INTERVAL = 0.10;
		public static double POLLED_WAIT_INTERVAL = 0.10;
		public static double POLLED_WAIT_SKIP_THRESHOLD = 2.00;
		// Game constants
		public static int MAX_INVENTORY = 6;
		public static int MAX_PLAYERS = 12;
		public static int PLAYER_NEUTRAL_VICTIM = 13;
		public static int PLAYER_NEUTRAL_EXTRA = 14;
		public static int MAX_PLAYER_SLOTS = 16;
		public static int MAX_SKELETONS = 25;
		public static int MAX_STOCK_ITEM_SLOTS = 11;
		public static int MAX_STOCK_UNIT_SLOTS = 11;
		public static int MAX_ITEM_LEVEL = 10;
		// Ideally these would be looked up from Units/MiscData.txt,
		// but there is currently no script functionality exposed to do that
		public static double TOD_DAWN = 6.00;
		public static double TOD_DUSK = 18.00;
		// Melee game settings:
		//   - Starting Time of Day (TOD)
		//   - Starting Gold
		//   - Starting Lumber
		//   - Starting Hero Tokens (free heroes)
		//   - Max heroes allowed per player
		//   - Max heroes allowed per hero type
		//   - Distance from start loc to search for nearby mines
		//
		public static double MELEE_STARTING_TOD = 8.00;
		public static int MELEE_STARTING_GOLD_V0 = 750;
		public static int MELEE_STARTING_GOLD_V1 = 500;
		public static int MELEE_STARTING_LUMBER_V0 = 200;
		public static int MELEE_STARTING_LUMBER_V1 = 150;
		public static int MELEE_STARTING_HERO_TOKENS = 1;
		public static int MELEE_HERO_LIMIT = 3;
		public static int MELEE_HERO_TYPE_LIMIT = 1;
		public static double MELEE_MINE_SEARCH_RADIUS = 2000;
		public static double MELEE_CLEAR_UNITS_RADIUS = 1500;
		public static double MELEE_CRIPPLE_TIMEOUT = 120.00;
		public static double MELEE_CRIPPLE_MSG_DURATION = 20.00;
		public static int MELEE_MAX_TWINKED_HEROES_V0 = 3;
		public static int MELEE_MAX_TWINKED_HEROES_V1 = 1;
		// Delay between a creep's death and the time it may drop an item.
		public static double CREEP_ITEM_DELAY = 0.50;
		// Timing settings for Marketplace inventories.
		public static double STOCK_RESTOCK_INITIAL_DELAY = 120;
		public static double STOCK_RESTOCK_INTERVAL = 30;
		public static int STOCK_MAX_ITERATIONS = 20;
		// Max events registered by a single "dest dies in region" event.
		public static int MAX_DEST_IN_REGION_EVENTS = 64;
		// Camera settings
		public static int CAMERA_MIN_FARZ = 100;
		public static int CAMERA_DEFAULT_DISTANCE = 1650;
		public static int CAMERA_DEFAULT_FARZ = 5000;
		public static int CAMERA_DEFAULT_AOA = 304;
		public static int CAMERA_DEFAULT_FOV = 70;
		public static int CAMERA_DEFAULT_ROLL = 0;
		public static int CAMERA_DEFAULT_ROTATION = 90;
		// Rescue
		public static double RESCUE_PING_TIME = 2.00;
		// Transmission behavior settings
		public static double NOTHING_SOUND_DURATION = 5.00;
		public static double TRANSMISSION_PING_TIME = 1.00;
		public static int TRANSMISSION_IND_RED = 255;
		public static int TRANSMISSION_IND_BLUE = 255;
		public static int TRANSMISSION_IND_GREEN = 255;
		public static int TRANSMISSION_IND_ALPHA = 255;
		public static double TRANSMISSION_PORT_HANGTIME = 1.50;
		// Cinematic mode settings
		public static double CINEMODE_INTERFACEFADE = 0.50;
		public static BJGameSpeed CINEMODE_GAMESPEED = MAP_SPEED_NORMAL;
		// Cinematic mode volume levels
		public static double CINEMODE_VOLUME_UNITMOVEMENT = 0.40;
		public static double CINEMODE_VOLUME_UNITSOUNDS = 0.00;
		public static double CINEMODE_VOLUME_COMBAT = 0.40;
		public static double CINEMODE_VOLUME_SPELLS = 0.40;
		public static double CINEMODE_VOLUME_UI = 0.00;
		public static double CINEMODE_VOLUME_MUSIC = 0.55;
		public static double CINEMODE_VOLUME_AMBIENTSOUNDS = 1.00;
		public static double CINEMODE_VOLUME_FIRE = 0.60;
		// Speech mode volume levels
		public static double SPEECH_VOLUME_UNITMOVEMENT = 0.25;
		public static double SPEECH_VOLUME_UNITSOUNDS = 0.00;
		public static double SPEECH_VOLUME_COMBAT = 0.25;
		public static double SPEECH_VOLUME_SPELLS = 0.25;
		public static double SPEECH_VOLUME_UI = 0.00;
		public static double SPEECH_VOLUME_MUSIC = 0.55;
		public static double SPEECH_VOLUME_AMBIENTSOUNDS = 1.00;
		public static double SPEECH_VOLUME_FIRE = 0.60;
		// Smart pan settings
		public static double SMARTPAN_TRESHOLD_PAN = 500;
		public static double SMARTPAN_TRESHOLD_SNAP = 3500;
		// QueuedTriggerExecute settings
		public static int MAX_QUEUED_TRIGGERS = 100;
		public static double QUEUED_TRIGGER_TIMEOUT = 180.00;
		// Campaign indexing constants
		public static int CAMPAIGN_INDEX_T = 0;
		public static int CAMPAIGN_INDEX_H = 1;
		public static int CAMPAIGN_INDEX_U = 2;
		public static int CAMPAIGN_INDEX_O = 3;
		public static int CAMPAIGN_INDEX_N = 4;
		public static int CAMPAIGN_INDEX_XN = 5;
		public static int CAMPAIGN_INDEX_XH = 6;
		public static int CAMPAIGN_INDEX_XU = 7;
		public static int CAMPAIGN_INDEX_XO = 8;
		// Campaign offset constants (for mission indexing)
		public static int CAMPAIGN_OFFSET_T = 0;
		public static int CAMPAIGN_OFFSET_H = 1;
		public static int CAMPAIGN_OFFSET_U = 2;
		public static int CAMPAIGN_OFFSET_O = 3;
		public static int CAMPAIGN_OFFSET_N = 4;
		public static int CAMPAIGN_OFFSET_XN = 0;
		public static int CAMPAIGN_OFFSET_XH = 1;
		public static int CAMPAIGN_OFFSET_XU = 2;
		public static int CAMPAIGN_OFFSET_XO = 3;
		// Mission indexing constants
		// Tutorial
		public static int MISSION_INDEX_T00 = CAMPAIGN_OFFSET_T * 1000 + 0;
		public static int MISSION_INDEX_T01 = CAMPAIGN_OFFSET_T * 1000 + 1;
		// Human
		public static int MISSION_INDEX_H00 = CAMPAIGN_OFFSET_H * 1000 + 0;
		public static int MISSION_INDEX_H01 = CAMPAIGN_OFFSET_H * 1000 + 1;
		public static int MISSION_INDEX_H02 = CAMPAIGN_OFFSET_H * 1000 + 2;
		public static int MISSION_INDEX_H03 = CAMPAIGN_OFFSET_H * 1000 + 3;
		public static int MISSION_INDEX_H04 = CAMPAIGN_OFFSET_H * 1000 + 4;
		public static int MISSION_INDEX_H05 = CAMPAIGN_OFFSET_H * 1000 + 5;
		public static int MISSION_INDEX_H06 = CAMPAIGN_OFFSET_H * 1000 + 6;
		public static int MISSION_INDEX_H07 = CAMPAIGN_OFFSET_H * 1000 + 7;
		public static int MISSION_INDEX_H08 = CAMPAIGN_OFFSET_H * 1000 + 8;
		public static int MISSION_INDEX_H09 = CAMPAIGN_OFFSET_H * 1000 + 9;
		public static int MISSION_INDEX_H10 = CAMPAIGN_OFFSET_H * 1000 + 10;
		public static int MISSION_INDEX_H11 = CAMPAIGN_OFFSET_H * 1000 + 11;
		// Undead
		public static int MISSION_INDEX_U00 = CAMPAIGN_OFFSET_U * 1000 + 0;
		public static int MISSION_INDEX_U01 = CAMPAIGN_OFFSET_U * 1000 + 1;
		public static int MISSION_INDEX_U02 = CAMPAIGN_OFFSET_U * 1000 + 2;
		public static int MISSION_INDEX_U03 = CAMPAIGN_OFFSET_U * 1000 + 3;
		public static int MISSION_INDEX_U05 = CAMPAIGN_OFFSET_U * 1000 + 4;
		public static int MISSION_INDEX_U07 = CAMPAIGN_OFFSET_U * 1000 + 5;
		public static int MISSION_INDEX_U08 = CAMPAIGN_OFFSET_U * 1000 + 6;
		public static int MISSION_INDEX_U09 = CAMPAIGN_OFFSET_U * 1000 + 7;
		public static int MISSION_INDEX_U10 = CAMPAIGN_OFFSET_U * 1000 + 8;
		public static int MISSION_INDEX_U11 = CAMPAIGN_OFFSET_U * 1000 + 9;
		// Orc
		public static int MISSION_INDEX_O00 = CAMPAIGN_OFFSET_O * 1000 + 0;
		public static int MISSION_INDEX_O01 = CAMPAIGN_OFFSET_O * 1000 + 1;
		public static int MISSION_INDEX_O02 = CAMPAIGN_OFFSET_O * 1000 + 2;
		public static int MISSION_INDEX_O03 = CAMPAIGN_OFFSET_O * 1000 + 3;
		public static int MISSION_INDEX_O04 = CAMPAIGN_OFFSET_O * 1000 + 4;
		public static int MISSION_INDEX_O05 = CAMPAIGN_OFFSET_O * 1000 + 5;
		public static int MISSION_INDEX_O06 = CAMPAIGN_OFFSET_O * 1000 + 6;
		public static int MISSION_INDEX_O07 = CAMPAIGN_OFFSET_O * 1000 + 7;
		public static int MISSION_INDEX_O08 = CAMPAIGN_OFFSET_O * 1000 + 8;
		public static int MISSION_INDEX_O09 = CAMPAIGN_OFFSET_O * 1000 + 9;
		public static int MISSION_INDEX_O10 = CAMPAIGN_OFFSET_O * 1000 + 10;
		// Night Elf
		public static int MISSION_INDEX_N00 = CAMPAIGN_OFFSET_N * 1000 + 0;
		public static int MISSION_INDEX_N01 = CAMPAIGN_OFFSET_N * 1000 + 1;
		public static int MISSION_INDEX_N02 = CAMPAIGN_OFFSET_N * 1000 + 2;
		public static int MISSION_INDEX_N03 = CAMPAIGN_OFFSET_N * 1000 + 3;
		public static int MISSION_INDEX_N04 = CAMPAIGN_OFFSET_N * 1000 + 4;
		public static int MISSION_INDEX_N05 = CAMPAIGN_OFFSET_N * 1000 + 5;
		public static int MISSION_INDEX_N06 = CAMPAIGN_OFFSET_N * 1000 + 6;
		public static int MISSION_INDEX_N07 = CAMPAIGN_OFFSET_N * 1000 + 7;
		public static int MISSION_INDEX_N08 = CAMPAIGN_OFFSET_N * 1000 + 8;
		public static int MISSION_INDEX_N09 = CAMPAIGN_OFFSET_N * 1000 + 9;
		// Expansion Night Elf
		public static int MISSION_INDEX_XN00 = CAMPAIGN_OFFSET_XN * 1000 + 0;
		public static int MISSION_INDEX_XN01 = CAMPAIGN_OFFSET_XN * 1000 + 1;
		public static int MISSION_INDEX_XN02 = CAMPAIGN_OFFSET_XN * 1000 + 2;
		public static int MISSION_INDEX_XN03 = CAMPAIGN_OFFSET_XN * 1000 + 3;
		public static int MISSION_INDEX_XN04 = CAMPAIGN_OFFSET_XN * 1000 + 4;
		public static int MISSION_INDEX_XN05 = CAMPAIGN_OFFSET_XN * 1000 + 5;
		public static int MISSION_INDEX_XN06 = CAMPAIGN_OFFSET_XN * 1000 + 6;
		public static int MISSION_INDEX_XN07 = CAMPAIGN_OFFSET_XN * 1000 + 7;
		public static int MISSION_INDEX_XN08 = CAMPAIGN_OFFSET_XN * 1000 + 8;
		public static int MISSION_INDEX_XN09 = CAMPAIGN_OFFSET_XN * 1000 + 9;
		public static int MISSION_INDEX_XN10 = CAMPAIGN_OFFSET_XN * 1000 + 10;
		// Expansion Human
		public static int MISSION_INDEX_XH00 = CAMPAIGN_OFFSET_XH * 1000 + 0;
		public static int MISSION_INDEX_XH01 = CAMPAIGN_OFFSET_XH * 1000 + 1;
		public static int MISSION_INDEX_XH02 = CAMPAIGN_OFFSET_XH * 1000 + 2;
		public static int MISSION_INDEX_XH03 = CAMPAIGN_OFFSET_XH * 1000 + 3;
		public static int MISSION_INDEX_XH04 = CAMPAIGN_OFFSET_XH * 1000 + 4;
		public static int MISSION_INDEX_XH05 = CAMPAIGN_OFFSET_XH * 1000 + 5;
		public static int MISSION_INDEX_XH06 = CAMPAIGN_OFFSET_XH * 1000 + 6;
		public static int MISSION_INDEX_XH07 = CAMPAIGN_OFFSET_XH * 1000 + 7;
		public static int MISSION_INDEX_XH08 = CAMPAIGN_OFFSET_XH * 1000 + 8;
		public static int MISSION_INDEX_XH09 = CAMPAIGN_OFFSET_XH * 1000 + 9;
		// Expansion Undead
		public static int MISSION_INDEX_XU00 = CAMPAIGN_OFFSET_XU * 1000 + 0;
		public static int MISSION_INDEX_XU01 = CAMPAIGN_OFFSET_XU * 1000 + 1;
		public static int MISSION_INDEX_XU02 = CAMPAIGN_OFFSET_XU * 1000 + 2;
		public static int MISSION_INDEX_XU03 = CAMPAIGN_OFFSET_XU * 1000 + 3;
		public static int MISSION_INDEX_XU04 = CAMPAIGN_OFFSET_XU * 1000 + 4;
		public static int MISSION_INDEX_XU05 = CAMPAIGN_OFFSET_XU * 1000 + 5;
		public static int MISSION_INDEX_XU06 = CAMPAIGN_OFFSET_XU * 1000 + 6;
		public static int MISSION_INDEX_XU07 = CAMPAIGN_OFFSET_XU * 1000 + 7;
		public static int MISSION_INDEX_XU08 = CAMPAIGN_OFFSET_XU * 1000 + 8;
		public static int MISSION_INDEX_XU09 = CAMPAIGN_OFFSET_XU * 1000 + 9;
		public static int MISSION_INDEX_XU10 = CAMPAIGN_OFFSET_XU * 1000 + 10;
		public static int MISSION_INDEX_XU11 = CAMPAIGN_OFFSET_XU * 1000 + 11;
		public static int MISSION_INDEX_XU12 = CAMPAIGN_OFFSET_XU * 1000 + 12;
		public static int MISSION_INDEX_XU13 = CAMPAIGN_OFFSET_XU * 1000 + 13;
		// Expansion Orc
		public static int MISSION_INDEX_XO00 = CAMPAIGN_OFFSET_XO * 1000 + 0;
		// Cinematic indexing constants
		public static int CINEMATICINDEX_TOP = 0;
		public static int CINEMATICINDEX_HOP = 1;
		public static int CINEMATICINDEX_HED = 2;
		public static int CINEMATICINDEX_OOP = 3;
		public static int CINEMATICINDEX_OED = 4;
		public static int CINEMATICINDEX_UOP = 5;
		public static int CINEMATICINDEX_UED = 6;
		public static int CINEMATICINDEX_NOP = 7;
		public static int CINEMATICINDEX_NED = 8;
		public static int CINEMATICINDEX_XOP = 9;
		public static int CINEMATICINDEX_XED = 10;
		// Alliance settings
		public static int ALLIANCE_UNALLIED = 0;
		public static int ALLIANCE_UNALLIED_VISION = 1;
		public static int ALLIANCE_ALLIED = 2;
		public static int ALLIANCE_ALLIED_VISION = 3;
		public static int ALLIANCE_ALLIED_UNITS = 4;
		public static int ALLIANCE_ALLIED_ADVUNITS = 5;
		public static int ALLIANCE_NEUTRAL = 6;
		public static int ALLIANCE_NEUTRAL_VISION = 7;
		// Keyboard Event Types
		public static int KEYEVENTTYPE_DEPRESS = 0;
		public static int KEYEVENTTYPE_RELEASE = 1;
		// Keyboard Event Keys
		public static int KEYEVENTKEY_LEFT = 0;
		public static int KEYEVENTKEY_RIGHT = 1;
		public static int KEYEVENTKEY_DOWN = 2;
		public static int KEYEVENTKEY_UP = 3;
		// Transmission timing methods
		public static int TIMETYPE_ADD = 0;
		public static int TIMETYPE_SET = 1;
		public static int TIMETYPE_SUB = 2;
		// Camera bounds adjustment methods
		public static int CAMERABOUNDS_ADJUST_ADD = 0;
		public static int CAMERABOUNDS_ADJUST_SUB = 1;
		// Quest creation states
		public static int QUESTTYPE_REQ_DISCOVERED = 0;
		public static int QUESTTYPE_REQ_UNDISCOVERED = 1;
		public static int QUESTTYPE_OPT_DISCOVERED = 2;
		public static int QUESTTYPE_OPT_UNDISCOVERED = 3;
		// Quest message types
		public static int QUESTMESSAGE_DISCOVERED = 0;
		public static int QUESTMESSAGE_UPDATED = 1;
		public static int QUESTMESSAGE_COMPLETED = 2;
		public static int QUESTMESSAGE_FAILED = 3;
		public static int QUESTMESSAGE_REQUIREMENT = 4;
		public static int QUESTMESSAGE_MISSIONFAILED = 5;
		public static int QUESTMESSAGE_ALWAYSHINT = 6;
		public static int QUESTMESSAGE_HINT = 7;
		public static int QUESTMESSAGE_SECRET = 8;
		public static int QUESTMESSAGE_UNITACQUIRED = 9;
		public static int QUESTMESSAGE_UNITAVAILABLE = 10;
		public static int QUESTMESSAGE_ITEMACQUIRED = 11;
		public static int QUESTMESSAGE_WARNING = 12;
		// Leaderboard sorting methods
		public static int SORTTYPE_SORTBYVALUE = 0;
		public static int SORTTYPE_SORTBYPLAYER = 1;
		public static int SORTTYPE_SORTBYLABEL = 2;
		// Cinematic fade filter methods
		public static int CINEFADETYPE_FADEIN = 0;
		public static int CINEFADETYPE_FADEOUT = 1;
		public static int CINEFADETYPE_FADEOUTIN = 2;
		// Buff removal methods
		public static int REMOVEBUFFS_POSITIVE = 0;
		public static int REMOVEBUFFS_NEGATIVE = 1;
		public static int REMOVEBUFFS_ALL = 2;
		public static int REMOVEBUFFS_NONTLIFE = 3;
		// Buff properties - polarity
		public static int BUFF_POLARITY_POSITIVE = 0;
		public static int BUFF_POLARITY_NEGATIVE = 1;
		public static int BUFF_POLARITY_EITHER = 2;
		// Buff properties - resist type
		public static int BUFF_RESIST_MAGIC = 0;
		public static int BUFF_RESIST_PHYSICAL = 1;
		public static int BUFF_RESIST_EITHER = 2;
		public static int BUFF_RESIST_BOTH = 3;
		// Hero stats
		public static int HEROSTAT_STR = 0;
		public static int HEROSTAT_AGI = 1;
		public static int HEROSTAT_INT = 2;
		// Hero skill point modification methods
		public static int MODIFYMETHOD_ADD = 0;
		public static int MODIFYMETHOD_SUB = 1;
		public static int MODIFYMETHOD_SET = 2;
		// Unit state adjustment methods (for replaced units)
		public static int UNIT_STATE_METHOD_ABSOLUTE = 0;
		public static int UNIT_STATE_METHOD_RELATIVE = 1;
		public static int UNIT_STATE_METHOD_DEFAULTS = 2;
		public static int UNIT_STATE_METHOD_MAXIMUM = 3;
		// Gate operations
		public static int GATEOPERATION_CLOSE = 0;
		public static int GATEOPERATION_OPEN = 1;
		public static int GATEOPERATION_DESTROY = 2;
		// Game cache value types
		public static int GAMECACHE_BOOLEAN = 0;
		public static int GAMECACHE_INTEGER = 1;
		public static int GAMECACHE_REAL = 2;
		public static int GAMECACHE_UNIT = 3;
		public static int GAMECACHE_STRING = 4;
		// Item status types
		public static int ITEM_STATUS_HIDDEN = 0;
		public static int ITEM_STATUS_OWNED = 1;
		public static int ITEM_STATUS_INVULNERABLE = 2;
		public static int ITEM_STATUS_POWERUP = 3;
		public static int ITEM_STATUS_SELLABLE = 4;
		public static int ITEM_STATUS_PAWNABLE = 5;
		// Itemcode status types
		public static int ITEMCODE_STATUS_POWERUP = 0;
		public static int ITEMCODE_STATUS_SELLABLE = 1;
		public static int ITEMCODE_STATUS_PAWNABLE = 2;
		// Minimap ping styles
		public static int MINIMAPPINGSTYLE_SIMPLE = 0;
		public static int MINIMAPPINGSTYLE_FLASHY = 1;
		public static int MINIMAPPINGSTYLE_ATTACK = 2;
		// Corpse creation settings
		public static double CORPSE_MAX_DEATH_TIME = 8.00;
		// Corpse creation styles
		public static int CORPSETYPE_FLESH = 0;
		public static int CORPSETYPE_BONE = 1;
		// Elevator pathing-blocker destructable code
		public static int ELEVATOR_BLOCKER_CODE = UnitId( "DTep" );
		public static int ELEVATOR_CODE01 = UnitId( "DTrf" );
		public static int ELEVATOR_CODE02 = UnitId( "DTrx" );
		// Elevator wall codes
		public static int ELEVATOR_WALL_TYPE_ALL = 0;
		public static int ELEVATOR_WALL_TYPE_EAST = 1;
		public static int ELEVATOR_WALL_TYPE_NORTH = 2;
		public static int ELEVATOR_WALL_TYPE_SOUTH = 3;
		public static int ELEVATOR_WALL_TYPE_WEST = 4;
		//-----------------------------------------------------------------------
		// Variables
		//
		// Force predefs
		public static BJForce  FORCE_ALL_PLAYERS = null;
        public static BJForce[] FORCE_PLAYER = new BJForce[ MAX_PLAYER_SLOTS ];
		public static int  MELEE_MAX_TWINKED_HEROES = 0;
		// Map area rects
		public static BJRect  mapInitialPlayableArea = null;
		public static BJRect  mapInitialCameraBounds = null;
		// Utility function vars
		public static int  forLoopAIndex = 0;
		public static int  forLoopBIndex = 0;
		public static int  forLoopAIndexEnd = 0;
		public static int  forLoopBIndexEnd = 0;
		public static bool  slotControlReady = false;
		public static bool [] slotControlUsed;
		public static BJMapControl [] slotControl;
		// Game started detection vars
		public static BJTimer  gameStartedTimer = null;
		public static bool  gameStarted = false;
		public static BJTimer  volumeGroupsTimer = CreateTimer();
		// Singleplayer check
		public static bool  isSinglePlayer = false;
		// Day/Night Cycle vars
		public static BJTrigger  dncSoundsDay = null;
		public static BJTrigger  dncSoundsNight = null;
		public static BJSound  dayAmbientSound = null;
		public static BJSound  nightAmbientSound = null;
		public static BJTrigger  dncSoundsDawn = null;
		public static BJTrigger  dncSoundsDusk = null;
		public static BJSound  dawnSound = null;
		public static BJSound  duskSound = null;
		public static bool  useDawnDuskSounds = true;
		public static bool  dncIsDaytime = false;
		// Triggered sounds
		//sound              pingMinimapSound         = null
		public static BJSound  rescueSound = null;
		public static BJSound  questDiscoveredSound = null;
		public static BJSound  questUpdatedSound = null;
		public static BJSound  questCompletedSound = null;
		public static BJSound  questFailedSound = null;
		public static BJSound  questHintSound = null;
		public static BJSound  questSecretSound = null;
		public static BJSound  questItemAcquiredSound = null;
		public static BJSound  questWarningSound = null;
		public static BJSound  victoryDialogSound = null;
		public static BJSound  defeatDialogSound = null;
		// Marketplace vars
		public static BJTrigger  stockItemPurchased = null;
		public static BJTimer  stockUpdateTimer = null;
        public static bool[] stockAllowedPermanent = new bool[ MAX_ITEM_LEVEL + 1 ];
        public static bool[] stockAllowedCharged = new bool[ MAX_ITEM_LEVEL + 1 ];
        public static bool[] stockAllowedArtifact = new bool[ MAX_ITEM_LEVEL + 1 ];
		public static int  stockPickedItemLevel = 0;
		public static BJItemType  stockPickedItemType;
		// Melee vars
		public static BJTrigger  meleeVisibilityTrained = null;
		public static bool  meleeVisibilityIsDay = true;
		public static bool  meleeGrantHeroItems = false;
		public static BJLocation  meleeNearestMineToLoc = null;
		public static BJUnit  meleeNearestMine = null;
		public static double  meleeNearestMineDist = 0.00;
		public static bool  meleeGameOver = false;
		public static bool [] meleeDefeated;
		public static bool [] meleeVictoried;
		public static BJUnit [] ghoul;
		public static BJTimer [] crippledTimer;
		public static BJTimerDialog [] crippledTimerWindows;
		public static bool [] playerIsCrippled;
		public static bool [] playerIsExposed;
		public static bool  finishSoonAllExposed = false;
		public static BJTimerDialog  finishSoonTimerDialog = null;
		public static int [] meleeTwinkedHeroes;
		// Rescue behavior vars
		public static BJTrigger  rescueUnitBehavior = null;
		public static bool  rescueChangeColorUnit = true;
		public static bool  rescueChangeColorBldg = true;
		// Transmission vars
		public static BJTimer  cineSceneEndingTimer = null;
		public static BJSound  cineSceneLastSound = null;
		public static BJTrigger  cineSceneBeingSkipped = null;
		// Cinematic mode vars
		public static BJGameSpeed  cineModePriorSpeed = MAP_SPEED_NORMAL;
		public static bool  cineModePriorFogSetting = false;
		public static bool  cineModePriorMaskSetting = false;
		public static bool  cineModeAlreadyIn = false;
		public static bool  cineModePriorDawnDusk = false;
		public static int  cineModeSavedSeed = 0;
		// Cinematic fade vars
		public static BJTimer  cineFadeFinishTimer = null;
		public static BJTimer  cineFadeContinueTimer = null;
		public static double  cineFadeContinueRed = 0;
		public static double  cineFadeContinueGreen = 0;
		public static double  cineFadeContinueBlue = 0;
		public static double  cineFadeContinueTrans = 0;
		public static double  cineFadeContinueDuration = 0;
		public static string  cineFadeContinueTex = "";
		// QueuedTriggerExecute vars
		public static int  queuedExecTotal = 0;
        public static BJTrigger[] queuedExecTriggers = new BJTrigger[ MAX_QUEUED_TRIGGERS ];
        public static bool[] queuedExecUseConds = new bool[ MAX_QUEUED_TRIGGERS ];
		public static BJTimer  queuedExecTimeoutTimer = CreateTimer();
		public static BJTrigger  queuedExecTimeout = null;
		// Helper vars (for Filter and Enum funcs)
		public static int  destInRegionDiesCount = 0;
		public static BJTrigger  destInRegionDiesTrig = null;
		public static int  groupCountUnits = 0;
		public static int  forceCountPlayers = 0;
		public static int  groupEnumTypeId = 0;
		public static BJPlayer  groupEnumOwningPlayer = null;
		public static BJGroup  groupAddGroupDest = null;
		public static BJGroup  groupRemoveGroupDest = null;
		public static int  groupRandomConsidered = 0;
		public static BJUnit  groupRandomCurrentPick = null;
		public static BJGroup  groupLastCreatedDest = null;
		public static BJGroup  randomSubGroupGroup = null;
		public static int  randomSubGroupWant = 0;
		public static int  randomSubGroupTotal = 0;
		public static double  randomSubGroupChance = 0;
		public static int  destRandomConsidered = 0;
		public static BJDestructAble  destRandomCurrentPick = null;
		public static BJDestructAble  elevatorWallBlocker = null;
		public static BJDestructAble  elevatorNeighbor = null;
		public static int  itemRandomConsidered = 0;
		public static BJItem  itemRandomCurrentPick = null;
		public static int  forceRandomConsidered = 0;
		public static BJPlayer  forceRandomCurrentPick = null;
		public static BJUnit  makeUnitRescuableUnit = null;
		public static bool  makeUnitRescuableFlag = true;
		public static bool  pauseAllUnitsFlag = true;
		public static BJLocation  enumDestructableCenter = null;
		public static double  enumDestructableRadius = 0;
		public static BJPlayerColor  setPlayerTargetColor = null;
		public static bool  isUnitGroupDeadResult = true;
		public static bool  isUnitGroupEmptyResult = true;
		public static bool  isUnitGroupInRectResult = true;
		public static BJRect  isUnitGroupInRectRect = null;
		public static bool  changeLevelShowScores = false;
		public static string  changeLevelMapName = null;
		public static BJGroup  suspendDecayFleshGroup = CreateGroup();
		public static BJGroup  suspendDecayBoneGroup = CreateGroup();
		public static BJTimer  delayedSuspendDecayTimer = CreateTimer();
		public static BJTrigger  delayedSuspendDecayTrig = null;
		public static int  livingPlayerUnitsTypeId = 0;
		public static BJWidget  lastDyingWidget = null;
		// Random distribution vars
		public static int  randDistCount = 0;
		public static int [] randDistID;
		public static int [] randDistChance;
		// Last X'd vars
		public static BJUnit  lastCreatedUnit = null;
		public static BJItem  lastCreatedItem = null;
		public static BJItem  lastRemovedItem = null;
		public static BJUnit  lastHauntedGoldMine = null;
		public static BJDestructAble  lastCreatedDestructable = null;
		public static BJGroup  lastCreatedGroup = CreateGroup();
		public static BJFogModifier  lastCreatedFogModifier = null;
		public static BJEffect  lastCreatedEffect = null;
		public static BJWeatherEffect  lastCreatedWeatherEffect = null;
		public static BJTerrainDeformation  lastCreatedTerrainDeformation = null;
		public static BJQuest  lastCreatedQuest = null;
		public static BJQuestItem  lastCreatedQuestItem = null;
		public static BJDefeatCondition  lastCreatedDefeatCondition = null;
		public static BJTimer  lastStartedTimer = CreateTimer();
		public static BJTimerDialog  lastCreatedTimerDialog = null;
		public static BJLeaderBoard  lastCreatedLeaderboard = null;
		public static BJSound  lastPlayedSound = null;
		public static string  lastPlayedMusic = "";
		public static double  lastTransmissionDuration = 0;
		public static BJGameCache  lastCreatedGameCache = null;
		public static BJUnit  lastLoadedUnit = null;
		public static BJButton  lastCreatedButton = null;
		public static BJUnit  lastReplacedUnit = null;
		public static BJTextTag  lastCreatedTextTag = null;
		// Filter function vars
		public static BJBoolExpr  filterIssueHauntOrderAtLocBJ = null;
		public static BJBoolExpr  filterEnumDestructablesInCircleBJ = null;
		public static BJBoolExpr  filterGetUnitsInRectOfPlayer = null;
		public static BJBoolExpr  filterGetUnitsOfTypeIdAll = null;
		public static BJBoolExpr  filterGetUnitsOfPlayerAndTypeId = null;
		public static BJBoolExpr  filterMeleeTrainedUnitIsHeroBJ = null;
		public static BJBoolExpr  filterLivingPlayerUnitsOfTypeId = null;
		// Memory cleanup vars
		public static bool  wantDestroyGroup = false;
		//***************************************************************************
		//*
		//*  Debugging Functions
		//*
		//***************************************************************************
		//===========================================================================
		public static void BJDebugMsg( string msg )
		{
			// Original JassCode
			int i = 0;
			while( true )
			{
				DisplayTimedTextToPlayer(Player(i),0,0,60,msg);
				i = i + 1;
				if(  i == MAX_PLAYERS )
					break;
			}
		}

		//***************************************************************************
		//*
		//*  Math Utility Functions
		//*
		//***************************************************************************
		//===========================================================================
		public static double RMinBJ( double a , double b )
		{
			// Original JassCode
			if(  (a < b)  )
			{
				return a;
			}
			else
			{
				return b;
			}
		}

		//===========================================================================
		public static double RMaxBJ( double a , double b )
		{
			// Original JassCode
			if(  (a < b)  )
			{
				return b;
			}
			else
			{
				return a;
			}
		}

		//===========================================================================
		public static double RAbsBJ( double a )
		{
			// Original JassCode
			if(  (a >= 0)  )
			{
				return a;
			}
			else
			{
				return -a;
			}
		}

		//===========================================================================
		public static double RSignBJ( double a )
		{
			// Original JassCode
			if(  (a >= 0.0)  )
			{
				return 1.0;
			}
			else
			{
				return -1.0;
			}
		}

		//===========================================================================
		public static int IMinBJ( int a , int b )
		{
			// Original JassCode
			if(  (a < b)  )
			{
				return a;
			}
			else
			{
				return b;
			}
		}

		//===========================================================================
		public static int IMaxBJ( int a , int b )
		{
			// Original JassCode
			if(  (a < b)  )
			{
				return b;
			}
			else
			{
				return a;
			}
		}

		//===========================================================================
		public static int IAbsBJ( int a )
		{
			// Original JassCode
			if(  (a >= 0)  )
			{
				return a;
			}
			else
			{
				return -a;
			}
		}

		//===========================================================================
		public static int ISignBJ( int a )
		{
			// Original JassCode
			if(  (a >= 0)  )
			{
				return 1;
			}
			else
			{
				return -1;
			}
		}

		//===========================================================================
		public static double SinBJ( double degrees )
		{
			// Original JassCode
			return Sin(degrees * DEGTORAD);
		}

		//===========================================================================
		public static double CosBJ( double degrees )
		{
			// Original JassCode
			return Cos(degrees * DEGTORAD);
		}

		//===========================================================================
		public static double TanBJ( double degrees )
		{
			// Original JassCode
			return Tan(degrees * DEGTORAD);
		}

		//===========================================================================
		public static double AsinBJ( double degrees )
		{
			// Original JassCode
			return Asin(degrees) * RADTODEG;
		}

		//===========================================================================
		public static double AcosBJ( double degrees )
		{
			// Original JassCode
			return Acos(degrees) * RADTODEG;
		}

		//===========================================================================
		public static double AtanBJ( double degrees )
		{
			// Original JassCode
			return Atan(degrees) * RADTODEG;
		}

		//===========================================================================
		public static double Atan2BJ( double y , double x )
		{
			// Original JassCode
			return Atan2(y, x) * RADTODEG;
		}

		//===========================================================================
		public static double AngleBetweenPoints( BJLocation locA , BJLocation locB )
		{
			// Original JassCode
			return RADTODEG * Atan2(GetLocationY(locB) - GetLocationY(locA), GetLocationX(locB) - GetLocationX(locA));
		}

		//===========================================================================
		public static double DistanceBetweenPoints( BJLocation locA , BJLocation locB )
		{
			// Original JassCode
			double dx = GetLocationX(locB) - GetLocationX(locA);
			double dy = GetLocationY(locB) - GetLocationY(locA);
			return SquareRoot(dx * dx + dy * dy);
		}

		//===========================================================================
		public static BJLocation PolarProjectionBJ( BJLocation source , double dist , double angle )
		{
			// Original JassCode
			double x = GetLocationX(source) + dist * Cos(angle * DEGTORAD);
			double y = GetLocationY(source) + dist * Sin(angle * DEGTORAD);
			return Location(x, y);
		}

		//===========================================================================
		public static double GetRandomDirectionDeg(  )
		{
			// Original JassCode
			return GetRandomReal(0, 360);
		}

		//===========================================================================
		public static double GetRandomPercentageBJ(  )
		{
			// Original JassCode
			return GetRandomReal(0, 100);
		}

		//===========================================================================
		public static BJLocation GetRandomLocInRect( BJRect whichRect )
		{
			// Original JassCode
			return Location(GetRandomReal(GetRectMinX(whichRect), GetRectMaxX(whichRect)), GetRandomReal(GetRectMinY(whichRect), GetRectMaxY(whichRect)));
		}

		//===========================================================================
		// Calculate the modulus/remainder of (dividend) divided by (divisor).
		// Examples:  18 mod 5 = 3.  15 mod 5 = 0.  -8 mod 5 = 2.
		//
		public static int ModuloInteger( int dividend , int divisor )
		{
			// Original JassCode
			int modulus = dividend - (dividend / divisor) * divisor;
			// If the dividend was negative, the above modulus calculation will
			// be negative, but within (-divisor..0).  We can add (divisor) to
			// shift this result into the desired range of (0..divisor).
			if(  (modulus < 0)  )
			{
				modulus = modulus + divisor;
			}
			return modulus;
		}

		//===========================================================================
		// Calculate the modulus/remainder of (dividend) divided by (divisor).
		// Examples:  13.000 mod 2.500 = 0.500.  -6.000 mod 2.500 = 1.500.
		//
		public static double ModuloReal( double dividend , double divisor )
		{
			// Original JassCode
			double modulus = dividend - I2R(R2I(dividend / divisor)) * divisor;
			// If the dividend was negative, the above modulus calculation will
			// be negative, but within (-divisor..0).  We can add (divisor) to
			// shift this result into the desired range of (0..divisor).
			if(  (modulus < 0)  )
			{
				modulus = modulus + divisor;
			}
			return modulus;
		}

		//===========================================================================
		public static BJLocation OffsetLocation( BJLocation loc , double dx , double dy )
		{
			// Original JassCode
			return Location(GetLocationX(loc) + dx, GetLocationY(loc) + dy);
		}

		//===========================================================================
		public static BJRect OffsetRectBJ( BJRect r , double dx , double dy )
		{
			// Original JassCode
			return Rect( GetRectMinX(r) + dx, GetRectMinY(r) + dy, GetRectMaxX(r) + dx, GetRectMaxY(r) + dy );
		}

		//===========================================================================
		public static BJRect RectFromCenterSizeBJ( BJLocation center , double width , double height )
		{
			// Original JassCode
			double x = GetLocationX( center );
			double y = GetLocationY( center );
			return Rect( x - width*0.5, y - height*0.5, x + width*0.5, y + height*0.5 );
		}

		//===========================================================================
		public static bool RectContainsCoords( BJRect r , double x , double y )
		{
			// Original JassCode
			return (GetRectMinX(r) <= x) && (x <= GetRectMaxX(r)) && (GetRectMinY(r) <= y) && (y <= GetRectMaxY(r));
		}

		//===========================================================================
		public static bool RectContainsLoc( BJRect r , BJLocation loc )
		{
			// Original JassCode
			return RectContainsCoords(r, GetLocationX(loc), GetLocationY(loc));
		}

		//===========================================================================
		public static bool RectContainsUnit( BJRect r , BJUnit whichUnit )
		{
			// Original JassCode
			return RectContainsCoords(r, GetUnitX(whichUnit), GetUnitY(whichUnit));
		}

		//===========================================================================
		public static bool RectContainsItem( BJItem whichItem , BJRect r )
		{
			// Original JassCode
			if(  (whichItem == null)  )
			{
				return false;
			}
			if(  (IsItemOwned(whichItem))  )
			{
				return false;
			}
			return RectContainsCoords(r, GetItemX(whichItem), GetItemY(whichItem));
		}

		//***************************************************************************
		//*
		//*  Utility Constructs
		//*
		//***************************************************************************
		//===========================================================================
		// Runs the trigger's actions if the trigger's conditions evaluate to true.
		//
		public static void ConditionalTriggerExecute( BJTrigger trig )
		{
			// Original JassCode
			if(  TriggerEvaluate(trig)  )
			{
				TriggerExecute(trig);
			}
		}

		//===========================================================================
		// Runs the trigger's actions if the trigger's conditions evaluate to true.
		//
		public static bool TriggerExecuteBJ( BJTrigger trig , bool checkConditions )
		{
			// Original JassCode
			if(  checkConditions  )
			{
				if(  ! (TriggerEvaluate(trig))  )
				{
					return false;
				}
			}
			TriggerExecute(trig);
			return true;
		}

		//===========================================================================
		// Arranges for a trigger to fire almost immediately, except that the calling
		// trigger is not interrupted as is the case with a TriggerExecute call.
		// Since the trigger executes normally, its conditions are still evaluated.
		//
		public static bool PostTriggerExecuteBJ( BJTrigger trig , bool checkConditions )
		{
			// Original JassCode
			if(  checkConditions  )
			{
				if(  ! (TriggerEvaluate(trig))  )
				{
					return false;
				}
			}
			TriggerRegisterTimerEvent(trig, 0, false);
			return true;
		}

		//===========================================================================
		// Debug - Display the contents of the trigger queue (as either null or "x"
		// for each entry).
		public static void QueuedTriggerCheck(  )
		{
			// Original JassCode
			string s = "TrigQueue Check ";
			int i;
			i = 0;
			while( true )
			{
				if(  i >= queuedExecTotal )
					break;
				s = s + "q[" + I2S(i) + "]=";
				if(  (queuedExecTriggers[i] == null)  )
				{
					s = s + "null ";
				}
				else
				{
					s = s + "x ";
				}
				i = i + 1;
			}
			s = s + "(" + I2S(queuedExecTotal) + " total)";
			DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,600,s);
		}

		//===========================================================================
		// Searches the queue for a given trigger, returning the index of the
		// trigger within the queue if it is found, or -1 if it is not found.
		//
		public static int QueuedTriggerGetIndex( BJTrigger trig )
		{
			// Original JassCode
			// Determine which, if any, of the queued triggers is being removed.
			int index = 0;
			while( true )
			{
				if(  index >= queuedExecTotal )
					break;
				if(  (queuedExecTriggers[index] == trig)  )
				{
					return index;
				}
				index = index + 1;
			}
			return -1;
		}

		//===========================================================================
		// Removes a trigger from the trigger queue, shifting other triggers down
		// to fill the unused space.  If the currently running trigger is removed
		// in this manner, this function does NOT attempt to run the next trigger.
		//
		public static bool QueuedTriggerRemoveByIndex( int trigIndex )
		{
			// Original JassCode
			int index;
			// If the to-be-removed index is out of range, fail.
			if(  (trigIndex >= queuedExecTotal)  )
			{
				return false;
			}
			// Shift all queue entries down to fill in the gap.
			queuedExecTotal = queuedExecTotal - 1;
			index = trigIndex;
			while( true )
			{
				if(  index >= queuedExecTotal )
					break;
				queuedExecTriggers[index] = queuedExecTriggers[index + 1];
				queuedExecUseConds[index] = queuedExecUseConds[index + 1];
				index = index + 1;
			}
			return true;
		}

		//===========================================================================
		// Attempt to execute the first trigger in the queue.  If it fails, remove
		// it and execute the next one.  Continue this cycle until a trigger runs,
		// or until the queue is empty.
		//
		public static bool QueuedTriggerAttemptExec(  )
		{
			// Original JassCode
			while( true )
			{
				if(  queuedExecTotal == 0 )
					break;
				if(  TriggerExecuteBJ(queuedExecTriggers[0], queuedExecUseConds[0])  )
				{
					// Timeout the queue if it sits at the front of the queue for too long.
					TimerStart(queuedExecTimeoutTimer, QUEUED_TRIGGER_TIMEOUT, false, null);
					return true;
				}
				QueuedTriggerRemoveByIndex(0);
			}
			return false;
		}

		//===========================================================================
		// Queues a trigger to be executed, assuring that such triggers are not
		// executed at the same time.
		//
		public static bool QueuedTriggerAddBJ( BJTrigger trig , bool checkConditions )
		{
			// Original JassCode
			// Make sure our queue isn't full.  If it is, return failure.
			if(  (queuedExecTotal >= MAX_QUEUED_TRIGGERS)  )
			{
				return false;
			}
			// Add the trigger to an array of to-be-executed triggers.
			queuedExecTriggers[queuedExecTotal] = trig;
			queuedExecUseConds[queuedExecTotal] = checkConditions;
			queuedExecTotal = queuedExecTotal + 1;
			// If this is the only trigger in the queue, run it.
			if(  (queuedExecTotal == 1)  )
			{
				QueuedTriggerAttemptExec();
			}
			return true;
		}

		//===========================================================================
		// Denotes the end of a queued trigger. Be sure to call this only once per
		// queued trigger, or risk stepping on the toes of other queued triggers.
		//
		public static void QueuedTriggerRemoveBJ( BJTrigger trig )
		{
			// Original JassCode
			int index;
			int trigIndex;
			bool trigExecuted;
			// Find the trigger's index.
			trigIndex = QueuedTriggerGetIndex(trig);
			if(  (trigIndex == -1)  )
			{
				return;
			}
			// Shuffle the other trigger entries down to fill in the gap.
			QueuedTriggerRemoveByIndex(trigIndex);
			// If we just axed the currently running trigger, run the next one.
			if(  (trigIndex == 0)  )
			{
				PauseTimer(queuedExecTimeoutTimer);
				QueuedTriggerAttemptExec();
			}
		}

		//===========================================================================
		// Denotes the end of a queued trigger. Be sure to call this only once per
		// queued trigger, lest you step on the toes of other queued triggers.
		//
		public static void QueuedTriggerDoneBJ(  )
		{
			// Original JassCode
			int index;
			// Make sure there's something on the queue to remove.
			if(  (queuedExecTotal <= 0)  )
			{
				return;
			}
			// Remove the currently running trigger from the array.
			QueuedTriggerRemoveByIndex(0);
			// If other triggers are waiting to run, run one of them.
			PauseTimer(queuedExecTimeoutTimer);
			QueuedTriggerAttemptExec();
		}

		//===========================================================================
		// Empty the trigger queue.
		//
		public static void QueuedTriggerClearBJ(  )
		{
			// Original JassCode
			PauseTimer(queuedExecTimeoutTimer);
			queuedExecTotal = 0;
		}

		//===========================================================================
		// Remove all but the currently executing trigger from the trigger queue.
		//
		public static void QueuedTriggerClearInactiveBJ(  )
		{
			// Original JassCode
			queuedExecTotal = IMinBJ(queuedExecTotal, 1);
		}

		//===========================================================================
		public static int QueuedTriggerCountBJ(  )
		{
			// Original JassCode
			return queuedExecTotal;
		}

		//===========================================================================
		public static bool IsTriggerQueueEmptyBJ(  )
		{
			// Original JassCode
			return queuedExecTotal <= 0;
		}

		//===========================================================================
		public static bool IsTriggerQueuedBJ( BJTrigger trig )
		{
			// Original JassCode
			return QueuedTriggerGetIndex(trig) != -1;
		}

		//===========================================================================
		public static int GetForLoopIndexA(  )
		{
			// Original JassCode
			return forLoopAIndex;
		}

		//===========================================================================
		public static void SetForLoopIndexA( int newIndex )
		{
			// Original JassCode
			forLoopAIndex = newIndex;
		}

		//===========================================================================
		public static int GetForLoopIndexB(  )
		{
			// Original JassCode
			return forLoopBIndex;
		}

		//===========================================================================
		public static void SetForLoopIndexB( int newIndex )
		{
			// Original JassCode
			forLoopBIndex = newIndex;
		}

		//===========================================================================
		// We can't do game-time waits, so this simulates one by starting a timer
		// and polling until the timer expires.
		public static void PolledWait( double duration )
		{
			// Original JassCode
			BJTimer t;
			double timeRemaining;
			if(  (duration > 0)  )
			{
				t = CreateTimer();
				TimerStart(t, duration, false, null);
				while( true )
				{
					timeRemaining = TimerGetRemaining(t);
					if(  timeRemaining <= 0 )
						break;
					// If we have a bit of time left, skip past 10% of the remaining
					// duration instead of checking every interval, to minimize the
					// polling on long waits.
					if(  (timeRemaining > POLLED_WAIT_SKIP_THRESHOLD)  )
					{
						TriggerSleepAction(0.1 * timeRemaining);
					}
					else
					{
						TriggerSleepAction(POLLED_WAIT_INTERVAL);
					}
				}
				DestroyTimer(t);
			}
		}

		//===========================================================================
		public static int IntegerTertiaryOp( bool flag , int valueA , int valueB )
		{
			// Original JassCode
			if(  flag  )
			{
				return valueA;
			}
			else
			{
				return valueB;
			}
		}

		//***************************************************************************
		//*
		//*  General Utility Functions
		//*  These functions exist purely to make the trigger dialogs cleaner and
		//*  more comprehensible.
		//*
		//***************************************************************************
		//===========================================================================
		public static void DoNothing(  )
		{
			// Original JassCode
		}

		//===========================================================================
		// This function does nothing.  WorldEdit should should eventually ignore
		// CommentString triggers during script generation, but until such a time,
		// this function will serve as a stub.
		//
		public static void CommentString( string commentString )
		{
			// Original JassCode
		}

		//===========================================================================
		// This seemingly useless function is used to trick the trigger editor into
		// externalizing arbitrary strings.  Especially useful for storing externalized
		// string references in variables.
		//
		public static string StringIdentity( string theString )
		{
			// Original JassCode
			return theString;
		}

		//===========================================================================
		public static bool GetBooleanAnd( bool valueA , bool valueB )
		{
			// Original JassCode
			return valueA && valueB;
		}

		//===========================================================================
		public static bool GetBooleanOr( bool valueA , bool valueB )
		{
			// Original JassCode
			return valueA || valueB;
		}

		//===========================================================================
		// Converts a percentage (real, 0..100) into a scaled integer (0..max),
		// clipping the result to 0..max in case the input is invalid.
		//
		public static int PercentToInt( double percentage , int max )
		{
			// Original JassCode
			int result = R2I(percentage * I2R(max) * 0.01);
			if(  (result < 0)  )
			{
				result = 0;
			}
			else if(  (result > max)  )
			{
				result = max;
			}
			return result;
		}

		//===========================================================================
		public static int PercentTo255( double percentage )
		{
			// Original JassCode
			return PercentToInt(percentage, 255);
		}

		//===========================================================================
		public static double GetTimeOfDay(  )
		{
			// Original JassCode
			return GetFloatGameState(GAME_STATE_TIME_OF_DAY);
		}

		//===========================================================================
		public static void SetTimeOfDay( double whatTime )
		{
			// Original JassCode
			SetFloatGameState(GAME_STATE_TIME_OF_DAY, whatTime);
		}

		//===========================================================================
		public static void SetTimeOfDayScalePercentBJ( double scalePercent )
		{
			// Original JassCode
			SetTimeOfDayScale(scalePercent * 0.01);
		}

		//===========================================================================
		public static double GetTimeOfDayScalePercentBJ(  )
		{
			// Original JassCode
			return GetTimeOfDayScale() * 100;
		}

		//===========================================================================
		public static void PlaySound( string soundName )
		{
			// Original JassCode
			BJSound soundHandle = CreateSound(soundName, false, false, true, 12700, 12700, "");
			StartSound(soundHandle);
			KillSoundWhenDone(soundHandle);
		}

		//===========================================================================
		public static bool CompareLocationsBJ( BJLocation A , BJLocation B )
		{
			// Original JassCode
			return GetLocationX(A) == GetLocationX(B) && GetLocationY(A) == GetLocationY(B);
		}

		//===========================================================================
		public static bool CompareRectsBJ( BJRect A , BJRect B )
		{
			// Original JassCode
			return GetRectMinX(A) == GetRectMinX(B) && GetRectMinY(A) == GetRectMinY(B) && GetRectMaxX(A) == GetRectMaxX(B) && GetRectMaxY(A) == GetRectMaxY(B);
		}

		//===========================================================================
		// Returns a square rect that exactly encompasses the specified circle.
		//
		public static BJRect GetRectFromCircleBJ( BJLocation center , double radius )
		{
			// Original JassCode
			double centerX = GetLocationX(center);
			double centerY = GetLocationY(center);
			return Rect(centerX - radius, centerY - radius, centerX + radius, centerY + radius);
		}

		//***************************************************************************
		//*
		//*  Camera Utility Functions
		//*
		//***************************************************************************
		//===========================================================================
		public static BJCameraSetup GetCurrentCameraSetup(  )
		{
			// Original JassCode
			BJCameraSetup theCam = CreateCameraSetup();
			double duration = 0;
			CameraSetupSetField(theCam, CAMERA_FIELD_TARGET_DISTANCE, GetCameraField(CAMERA_FIELD_TARGET_DISTANCE), duration);
			CameraSetupSetField(theCam, CAMERA_FIELD_FARZ, GetCameraField(CAMERA_FIELD_FARZ), duration);
			CameraSetupSetField(theCam, CAMERA_FIELD_ZOFFSET, GetCameraField(CAMERA_FIELD_ZOFFSET), duration);
			CameraSetupSetField(theCam, CAMERA_FIELD_ANGLE_OF_ATTACK, RADTODEG * GetCameraField(CAMERA_FIELD_ANGLE_OF_ATTACK), duration);
			CameraSetupSetField(theCam, CAMERA_FIELD_FIELD_OF_VIEW, RADTODEG * GetCameraField(CAMERA_FIELD_FIELD_OF_VIEW), duration);
			CameraSetupSetField(theCam, CAMERA_FIELD_ROLL, RADTODEG * GetCameraField(CAMERA_FIELD_ROLL), duration);
			CameraSetupSetField(theCam, CAMERA_FIELD_ROTATION, RADTODEG * GetCameraField(CAMERA_FIELD_ROTATION), duration);
			CameraSetupSetDestPosition(theCam, GetCameraTargetPositionX(), GetCameraTargetPositionY(), duration);
			return theCam;
		}

		//===========================================================================
		public static void CameraSetupApplyForPlayer( bool doPan , BJCameraSetup whichSetup , BJPlayer whichPlayer , double duration )
		{
			// Original JassCode
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				CameraSetupApplyForceDuration(whichSetup, doPan, duration);
			}
		}

		//===========================================================================
		public static double CameraSetupGetFieldSwap( BJCameraField whichField , BJCameraSetup whichSetup )
		{
			// Original JassCode
			return CameraSetupGetField(whichSetup, whichField);
		}

		//===========================================================================
		public static void SetCameraFieldForPlayer( BJPlayer whichPlayer , BJCameraField whichField , double value , double duration )
		{
			// Original JassCode
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				SetCameraField(whichField, value, duration);
			}
		}

		//===========================================================================
		public static void SetCameraTargetControllerNoZForPlayer( BJPlayer whichPlayer , BJUnit whichUnit , double xoffset , double yoffset , bool inheritOrientation )
		{
			// Original JassCode
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				SetCameraTargetController(whichUnit, xoffset, yoffset, inheritOrientation);
			}
		}

		//===========================================================================
		public static void SetCameraPositionForPlayer( BJPlayer whichPlayer , double x , double y )
		{
			// Original JassCode
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				SetCameraPosition(x, y);
			}
		}

		//===========================================================================
		public static void SetCameraPositionLocForPlayer( BJPlayer whichPlayer , BJLocation loc )
		{
			// Original JassCode
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				SetCameraPosition(GetLocationX(loc), GetLocationY(loc));
			}
		}

		//===========================================================================
		public static void RotateCameraAroundLocBJ( double degrees , BJLocation loc , BJPlayer whichPlayer , double duration )
		{
			// Original JassCode
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				SetCameraRotateMode(GetLocationX(loc), GetLocationY(loc), DEGTORAD * degrees, duration);
			}
		}

		//===========================================================================
		public static void PanCameraToForPlayer( BJPlayer whichPlayer , double x , double y )
		{
			// Original JassCode
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				PanCameraTo(x, y);
			}
		}

		//===========================================================================
		public static void PanCameraToLocForPlayer( BJPlayer whichPlayer , BJLocation loc )
		{
			// Original JassCode
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				PanCameraTo(GetLocationX(loc), GetLocationY(loc));
			}
		}

		//===========================================================================
		public static void PanCameraToTimedForPlayer( BJPlayer whichPlayer , double x , double y , double duration )
		{
			// Original JassCode
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				PanCameraToTimed(x, y, duration);
			}
		}

		//===========================================================================
		public static void PanCameraToTimedLocForPlayer( BJPlayer whichPlayer , BJLocation loc , double duration )
		{
			// Original JassCode
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				PanCameraToTimed(GetLocationX(loc), GetLocationY(loc), duration);
			}
		}

		//===========================================================================
		public static void PanCameraToTimedLocWithZForPlayer( BJPlayer whichPlayer , BJLocation loc , double zOffset , double duration )
		{
			// Original JassCode
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				PanCameraToTimedWithZ(GetLocationX(loc), GetLocationY(loc), zOffset, duration);
			}
		}

		//===========================================================================
		public static void SmartCameraPanBJ( BJPlayer whichPlayer , BJLocation loc , double duration )
		{
			// Original JassCode
			double dist;
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				dist = DistanceBetweenPoints(loc, GetCameraTargetPositionLoc());
				if(  (dist >= SMARTPAN_TRESHOLD_SNAP)  )
				{
					// If the user is too far away, snap the camera.
					PanCameraToTimed(GetLocationX(loc), GetLocationY(loc), 0);
				}
				else if(  (dist >= SMARTPAN_TRESHOLD_PAN)  )
				{
					// If the user is moderately close, pan the camera.
					PanCameraToTimed(GetLocationX(loc), GetLocationY(loc), duration);
				}
				else
				{
					// User is close enough, so don't touch the camera.
				}
			}
		}

		//===========================================================================
		public static void SetCinematicCameraForPlayer( BJPlayer whichPlayer , string cameraModelFile )
		{
			// Original JassCode
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				SetCinematicCamera(cameraModelFile);
			}
		}

		//===========================================================================
		public static void ResetToGameCameraForPlayer( BJPlayer whichPlayer , double duration )
		{
			// Original JassCode
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				ResetToGameCamera(duration);
			}
		}

		//===========================================================================
		public static void CameraSetSourceNoiseForPlayer( BJPlayer whichPlayer , double magnitude , double velocity )
		{
			// Original JassCode
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				CameraSetSourceNoise(magnitude, velocity);
			}
		}

		//===========================================================================
		public static void CameraSetTargetNoiseForPlayer( BJPlayer whichPlayer , double magnitude , double velocity )
		{
			// Original JassCode
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				CameraSetTargetNoise(magnitude, velocity);
			}
		}

		//===========================================================================
		public static void CameraSetEQNoiseForPlayer( BJPlayer whichPlayer , double magnitude )
		{
			// Original JassCode
			double richter = magnitude;
			if(  (richter > 5.0)  )
			{
				richter = 5.0;
			}
			if(  (richter < 2.0)  )
			{
				richter = 2.0;
			}
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				CameraSetTargetNoiseEx(magnitude*2.0, magnitude*Pow(10,richter),true);
				CameraSetSourceNoiseEx(magnitude*2.0, magnitude*Pow(10,richter),true);
			}
		}

		//===========================================================================
		public static void CameraClearNoiseForPlayer( BJPlayer whichPlayer )
		{
			// Original JassCode
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				CameraSetSourceNoise(0, 0);
				CameraSetTargetNoise(0, 0);
			}
		}

		//===========================================================================
		// Query the current camera bounds.
		//
		public static BJRect GetCurrentCameraBoundsMapRectBJ(  )
		{
			// Original JassCode
			return Rect(GetCameraBoundMinX(), GetCameraBoundMinY(), GetCameraBoundMaxX(), GetCameraBoundMaxY());
		}

		//===========================================================================
		// Query the initial camera bounds, as defined at map init.
		//
		public static BJRect GetCameraBoundsMapRect(  )
		{
			// Original JassCode
			return mapInitialCameraBounds;
		}

		//===========================================================================
		// Query the playable map area, as defined at map init.
		//
		public static BJRect GetPlayableMapRect(  )
		{
			// Original JassCode
			return mapInitialPlayableArea;
		}

		//===========================================================================
		// Query the entire map area, as defined at map init.
		//
		public static BJRect GetEntireMapRect(  )
		{
			// Original JassCode
			return GetWorldBounds();
		}

		//===========================================================================
		public static void SetCameraBoundsToRect( BJRect r )
		{
			// Original JassCode
			double minX = GetRectMinX(r);
			double minY = GetRectMinY(r);
			double maxX = GetRectMaxX(r);
			double maxY = GetRectMaxY(r);
			SetCameraBounds(minX, minY, minX, maxY, maxX, maxY, maxX, minY);
		}

		//===========================================================================
		public static void SetCameraBoundsToRectForPlayerBJ( BJPlayer whichPlayer , BJRect r )
		{
			// Original JassCode
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				SetCameraBoundsToRect(r);
			}
		}

		//===========================================================================
		public static void AdjustCameraBoundsBJ( int adjustMethod , double dxWest , double dxEast , double dyNorth , double dySouth )
		{
			// Original JassCode
			double minX = 0;
			double minY = 0;
			double maxX = 0;
			double maxY = 0;
			double scale = 0;
			if(  (adjustMethod == CAMERABOUNDS_ADJUST_ADD)  )
			{
				scale = 1;
			}
			else if(  (adjustMethod == CAMERABOUNDS_ADJUST_SUB)  )
			{
				scale = -1;
			}
			else
			{
				// Unrecognized adjustment method - ignore the request.
				return;
			}
			// Adjust the actual camera values
			minX = GetCameraBoundMinX() - scale * dxWest;
			maxX = GetCameraBoundMaxX() + scale * dxEast;
			minY = GetCameraBoundMinY() - scale * dySouth;
			maxY = GetCameraBoundMaxY() + scale * dyNorth;
			// Make sure the camera bounds are still valid.
			if(  (maxX < minX)  )
			{
				minX = (minX + maxX) * 0.5;
				maxX = minX;
			}
			if(  (maxY < minY)  )
			{
				minY = (minY + maxY) * 0.5;
				maxY = minY;
			}
			// Apply the new camera values.
			SetCameraBounds(minX, minY, minX, maxY, maxX, maxY, maxX, minY);
		}

		//===========================================================================
		public static void AdjustCameraBoundsForPlayerBJ( int adjustMethod , BJPlayer whichPlayer , double dxWest , double dxEast , double dyNorth , double dySouth )
		{
			// Original JassCode
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				AdjustCameraBoundsBJ(adjustMethod, dxWest, dxEast, dyNorth, dySouth);
			}
		}

		//===========================================================================
		public static void SetCameraQuickPositionForPlayer( BJPlayer whichPlayer , double x , double y )
		{
			// Original JassCode
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				SetCameraQuickPosition(x, y);
			}
		}

		//===========================================================================
		public static void SetCameraQuickPositionLocForPlayer( BJPlayer whichPlayer , BJLocation loc )
		{
			// Original JassCode
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				SetCameraQuickPosition(GetLocationX(loc), GetLocationY(loc));
			}
		}

		//===========================================================================
		public static void SetCameraQuickPositionLoc( BJLocation loc )
		{
			// Original JassCode
			SetCameraQuickPosition(GetLocationX(loc), GetLocationY(loc));
		}

		//===========================================================================
		public static void StopCameraForPlayerBJ( BJPlayer whichPlayer )
		{
			// Original JassCode
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				StopCamera();
			}
		}

		//===========================================================================
		public static void SetCameraOrientControllerForPlayerBJ( BJPlayer whichPlayer , BJUnit whichUnit , double xoffset , double yoffset )
		{
			// Original JassCode
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				SetCameraOrientController(whichUnit, xoffset, yoffset);
			}
		}

		//===========================================================================
		public static void CameraSetSmoothingFactorBJ( double factor )
		{
			// Original JassCode
			CameraSetSmoothingFactor(factor);
		}

		//===========================================================================
		public static void CameraResetSmoothingFactorBJ(  )
		{
			// Original JassCode
			CameraSetSmoothingFactor(0);
		}

		//***************************************************************************
		//*
		//*  Text Utility Functions
		//*
		//***************************************************************************
		//===========================================================================
		public static void DisplayTextToForce( BJForce toForce , string message )
		{
			// Original JassCode
			if(  (IsPlayerInForce(GetLocalPlayer(), toForce))  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				DisplayTextToPlayer(GetLocalPlayer(), 0, 0, message);
			}
		}

		//===========================================================================
		public static void DisplayTimedTextToForce( BJForce toForce , double duration , string message )
		{
			// Original JassCode
			if(  (IsPlayerInForce(GetLocalPlayer(), toForce))  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, duration, message);
			}
		}

		//===========================================================================
		public static void ClearTextMessagesBJ( BJForce toForce )
		{
			// Original JassCode
			if(  (IsPlayerInForce(GetLocalPlayer(), toForce))  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				ClearTextMessages();
			}
		}

		//===========================================================================
		// The parameters for the API Substring function are unintuitive, so this
		// merely performs a translation for the starting index.
		//
		public static string SubStringBJ( string source , int start , int end )
		{
			// Original JassCode
			return SubString(source, start-1, end);
		}

		//***************************************************************************
		//*
		//*  Event Registration Utility Functions
		//*
		//***************************************************************************
		//===========================================================================
		public static BJEvent TriggerRegisterTimerEventPeriodic( BJTrigger trig , double timeout )
		{
			// Original JassCode
			return TriggerRegisterTimerEvent(trig, timeout, true);
		}

		//===========================================================================
		public static BJEvent TriggerRegisterTimerEventSingle( BJTrigger trig , double timeout )
		{
			// Original JassCode
			return TriggerRegisterTimerEvent(trig, timeout, false);
		}

		//===========================================================================
		public static BJEvent TriggerRegisterTimerExpireEventBJ( BJTrigger trig , BJTimer t )
		{
			// Original JassCode
			return TriggerRegisterTimerExpireEvent(trig, t);
		}

		//===========================================================================
		public static BJEvent TriggerRegisterPlayerUnitEventSimple( BJTrigger trig , BJPlayer whichPlayer , BJPlayerUnitEvent whichEvent )
		{
			// Original JassCode
			return TriggerRegisterPlayerUnitEvent(trig, whichPlayer, whichEvent, null);
		}

		//===========================================================================
		public static void TriggerRegisterAnyUnitEventBJ( BJTrigger trig , BJPlayerUnitEvent whichEvent )
		{
			// Original JassCode
			int index;
			index = 0;
			while( true )
			{
				TriggerRegisterPlayerUnitEvent(trig, Player(index), whichEvent, null);
				index = index + 1;
				if(  index == MAX_PLAYER_SLOTS )
					break;
			}
		}

		//===========================================================================
		public static BJEvent TriggerRegisterPlayerSelectionEventBJ( BJTrigger trig , BJPlayer whichPlayer , bool selected )
		{
			// Original JassCode
			if(  selected  )
			{
				return TriggerRegisterPlayerUnitEvent(trig, whichPlayer, EVENT_PLAYER_UNIT_SELECTED, null);
			}
			else
			{
				return TriggerRegisterPlayerUnitEvent(trig, whichPlayer, EVENT_PLAYER_UNIT_DESELECTED, null);
			}
		}

		//===========================================================================
		public static BJEvent TriggerRegisterPlayerKeyEventBJ( BJTrigger trig , BJPlayer whichPlayer , int keType , int keKey )
		{
			// Original JassCode
			if(  (keType == KEYEVENTTYPE_DEPRESS)  )
			{
				// Depress event - find out what key
				if(  (keKey == KEYEVENTKEY_LEFT)  )
				{
					return TriggerRegisterPlayerEvent(trig, whichPlayer, EVENT_PLAYER_ARROW_LEFT_DOWN);
				}
				else if(  (keKey == KEYEVENTKEY_RIGHT)  )
				{
					return TriggerRegisterPlayerEvent(trig, whichPlayer, EVENT_PLAYER_ARROW_RIGHT_DOWN);
				}
				else if(  (keKey == KEYEVENTKEY_DOWN)  )
				{
					return TriggerRegisterPlayerEvent(trig, whichPlayer, EVENT_PLAYER_ARROW_DOWN_DOWN);
				}
				else if(  (keKey == KEYEVENTKEY_UP)  )
				{
					return TriggerRegisterPlayerEvent(trig, whichPlayer, EVENT_PLAYER_ARROW_UP_DOWN);
				}
				else
				{
					// Unrecognized key - ignore the request and return failure.
					return null;
				}
			}
			else if(  (keType == KEYEVENTTYPE_RELEASE)  )
			{
				// Release event - find out what key
				if(  (keKey == KEYEVENTKEY_LEFT)  )
				{
					return TriggerRegisterPlayerEvent(trig, whichPlayer, EVENT_PLAYER_ARROW_LEFT_UP);
				}
				else if(  (keKey == KEYEVENTKEY_RIGHT)  )
				{
					return TriggerRegisterPlayerEvent(trig, whichPlayer, EVENT_PLAYER_ARROW_RIGHT_UP);
				}
				else if(  (keKey == KEYEVENTKEY_DOWN)  )
				{
					return TriggerRegisterPlayerEvent(trig, whichPlayer, EVENT_PLAYER_ARROW_DOWN_UP);
				}
				else if(  (keKey == KEYEVENTKEY_UP)  )
				{
					return TriggerRegisterPlayerEvent(trig, whichPlayer, EVENT_PLAYER_ARROW_UP_UP);
				}
				else
				{
					// Unrecognized key - ignore the request and return failure.
					return null;
				}
			}
			else
			{
				// Unrecognized type - ignore the request and return failure.
				return null;
			}
		}

		//===========================================================================
		public static BJEvent TriggerRegisterPlayerEventVictory( BJTrigger trig , BJPlayer whichPlayer )
		{
			// Original JassCode
			return TriggerRegisterPlayerEvent(trig, whichPlayer, EVENT_PLAYER_VICTORY);
		}

		//===========================================================================
		public static BJEvent TriggerRegisterPlayerEventDefeat( BJTrigger trig , BJPlayer whichPlayer )
		{
			// Original JassCode
			return TriggerRegisterPlayerEvent(trig, whichPlayer, EVENT_PLAYER_DEFEAT);
		}

		//===========================================================================
		public static BJEvent TriggerRegisterPlayerEventAllianceChanged( BJTrigger trig , BJPlayer whichPlayer )
		{
			// Original JassCode
			return TriggerRegisterPlayerEvent(trig, whichPlayer, EVENT_PLAYER_ALLIANCE_CHANGED);
		}

		//===========================================================================
		public static BJEvent TriggerRegisterPlayerEventEndCinematic( BJTrigger trig , BJPlayer whichPlayer )
		{
			// Original JassCode
			return TriggerRegisterPlayerEvent(trig, whichPlayer, EVENT_PLAYER_END_CINEMATIC);
		}

		//===========================================================================
		public static BJEvent TriggerRegisterGameStateEventTimeOfDay( BJTrigger trig , BJLimitOP opcode , double limitval )
		{
			// Original JassCode
			return TriggerRegisterGameStateEvent(trig, GAME_STATE_TIME_OF_DAY, opcode, limitval);
		}

		//===========================================================================
		public static BJEvent TriggerRegisterEnterRegionSimple( BJTrigger trig , BJRegion whichRegion )
		{
			// Original JassCode
			return TriggerRegisterEnterRegion(trig, whichRegion, null);
		}

		//===========================================================================
		public static BJEvent TriggerRegisterLeaveRegionSimple( BJTrigger trig , BJRegion whichRegion )
		{
			// Original JassCode
			return TriggerRegisterLeaveRegion(trig, whichRegion, null);
		}

		//===========================================================================
		public static BJEvent TriggerRegisterEnterRectSimple( BJTrigger trig , BJRect r )
		{
			// Original JassCode
			BJRegion rectRegion = CreateRegion();
			RegionAddRect(rectRegion, r);
			return TriggerRegisterEnterRegion(trig, rectRegion, null);
		}

		//===========================================================================
		public static BJEvent TriggerRegisterLeaveRectSimple( BJTrigger trig , BJRect r )
		{
			// Original JassCode
			BJRegion rectRegion = CreateRegion();
			RegionAddRect(rectRegion, r);
			return TriggerRegisterLeaveRegion(trig, rectRegion, null);
		}

		//===========================================================================
		public static BJEvent TriggerRegisterDistanceBetweenUnits( BJTrigger trig , BJUnit whichUnit , BJBoolExpr condition , double range )
		{
			// Original JassCode
			return TriggerRegisterUnitInRange(trig, whichUnit, range, condition);
		}

		//===========================================================================
		public static BJEvent TriggerRegisterUnitInRangeSimple( BJTrigger trig , double range , BJUnit whichUnit )
		{
			// Original JassCode
			return TriggerRegisterUnitInRange(trig, whichUnit, range, null);
		}

		//===========================================================================
		public static BJEvent TriggerRegisterUnitLifeEvent( BJTrigger trig , BJUnit whichUnit , BJLimitOP opcode , double limitval )
		{
			// Original JassCode
			return TriggerRegisterUnitStateEvent(trig, whichUnit, UNIT_STATE_LIFE, opcode, limitval);
		}

		//===========================================================================
		public static BJEvent TriggerRegisterUnitManaEvent( BJTrigger trig , BJUnit whichUnit , BJLimitOP opcode , double limitval )
		{
			// Original JassCode
			return TriggerRegisterUnitStateEvent(trig, whichUnit, UNIT_STATE_MANA, opcode, limitval);
		}

		//===========================================================================
		public static BJEvent TriggerRegisterDialogEventBJ( BJTrigger trig , BJDialog whichDialog )
		{
			// Original JassCode
			return TriggerRegisterDialogEvent(trig, whichDialog);
		}

		//===========================================================================
		public static BJEvent TriggerRegisterShowSkillEventBJ( BJTrigger trig )
		{
			// Original JassCode
			return TriggerRegisterGameEvent(trig, EVENT_GAME_SHOW_SKILL);
		}

		//===========================================================================
		public static BJEvent TriggerRegisterBuildSubmenuEventBJ( BJTrigger trig )
		{
			// Original JassCode
			return TriggerRegisterGameEvent(trig, EVENT_GAME_BUILD_SUBMENU);
		}

		//===========================================================================
		public static BJEvent TriggerRegisterGameLoadedEventBJ( BJTrigger trig )
		{
			// Original JassCode
			return TriggerRegisterGameEvent(trig, EVENT_GAME_LOADED);
		}

		//===========================================================================
		public static BJEvent TriggerRegisterGameSavedEventBJ( BJTrigger trig )
		{
			// Original JassCode
			return TriggerRegisterGameEvent(trig, EVENT_GAME_SAVE);
		}

		//===========================================================================
		public static void RegisterDestDeathInRegionEnum(  )
		{
			// Original JassCode
			destInRegionDiesCount = destInRegionDiesCount + 1;
			if(  (destInRegionDiesCount <= MAX_DEST_IN_REGION_EVENTS)  )
			{
				TriggerRegisterDeathEvent(destInRegionDiesTrig, GetEnumDestructable());
			}
		}

		//===========================================================================
		public static BJEvent TriggerRegisterDestDeathInRegionEvent( BJTrigger trig , BJRect r )
		{
			// Original JassCode
			destInRegionDiesTrig = trig;
			destInRegionDiesCount = 0;
			EnumDestructablesInRect(r, null,  RegisterDestDeathInRegionEnum);
			return trig;
		}

		//***************************************************************************
		//*
		//*  Environment Utility Functions
		//*
		//***************************************************************************
		//===========================================================================
		public static BJWeatherEffect AddWeatherEffectSaveLast( BJRect where , int effectID )
		{
			// Original JassCode
			lastCreatedWeatherEffect = AddWeatherEffect(where, effectID);
			return lastCreatedWeatherEffect;
		}

		//===========================================================================
		public static BJWeatherEffect GetLastCreatedWeatherEffect(  )
		{
			// Original JassCode
			return lastCreatedWeatherEffect;
		}

		//===========================================================================
		public static void RemoveWeatherEffectBJ( BJWeatherEffect whichWeatherEffect )
		{
			// Original JassCode
			RemoveWeatherEffect(whichWeatherEffect);
		}

		//===========================================================================
		public static BJTerrainDeformation TerrainDeformationCraterBJ( double duration , bool permanent , BJLocation where , double radius , double depth )
		{
			// Original JassCode
			lastCreatedTerrainDeformation = TerrainDeformCrater(GetLocationX(where), GetLocationY(where), radius, depth, R2I(duration * 1000), permanent);
			return lastCreatedTerrainDeformation;
		}

		//===========================================================================
		public static BJTerrainDeformation TerrainDeformationRippleBJ( double duration , bool limitNeg , BJLocation where , double startRadius , double endRadius , double depth , double wavePeriod , double waveWidth )
		{
			// Original JassCode
			double spaceWave;
			double timeWave;
			double radiusRatio;
			if(  (endRadius <= 0 || waveWidth <= 0 || wavePeriod <= 0)  )
			{
				return null;
			}
			timeWave = 2.0 * duration / wavePeriod;
			spaceWave = 2.0 * endRadius / waveWidth;
			radiusRatio = startRadius / endRadius;
			lastCreatedTerrainDeformation = TerrainDeformRipple(GetLocationX(where), GetLocationY(where), endRadius, depth, R2I(duration * 1000), 1, spaceWave, timeWave, radiusRatio, limitNeg);
			return lastCreatedTerrainDeformation;
		}

		//===========================================================================
		public static BJTerrainDeformation TerrainDeformationWaveBJ( double duration , BJLocation source , BJLocation target , double radius , double depth , double trailDelay )
		{
			// Original JassCode
			double distance;
			double dirX;
			double dirY;
			double speed;
			distance = DistanceBetweenPoints(source, target);
			if(  (distance == 0 || duration <= 0)  )
			{
				return null;
			}
			dirX = (GetLocationX(target) - GetLocationX(source)) / distance;
			dirY = (GetLocationY(target) - GetLocationY(source)) / distance;
			speed = distance / duration;
			lastCreatedTerrainDeformation = TerrainDeformWave(GetLocationX(source), GetLocationY(source), dirX, dirY, distance, speed, radius, depth, R2I(trailDelay * 1000), 1);
			return lastCreatedTerrainDeformation;
		}

		//===========================================================================
		public static BJTerrainDeformation TerrainDeformationRandomBJ( double duration , BJLocation where , double radius , double minDelta , double maxDelta , double updateInterval )
		{
			// Original JassCode
			lastCreatedTerrainDeformation = TerrainDeformRandom(GetLocationX(where), GetLocationY(where), radius, minDelta, maxDelta, R2I(duration * 1000), R2I(updateInterval * 1000));
			return lastCreatedTerrainDeformation;
		}

		//===========================================================================
		public static void TerrainDeformationStopBJ( BJTerrainDeformation deformation , double duration )
		{
			// Original JassCode
			TerrainDeformStop(deformation, R2I(duration * 1000));
		}

		//===========================================================================
		public static BJTerrainDeformation GetLastCreatedTerrainDeformation(  )
		{
			// Original JassCode
			return lastCreatedTerrainDeformation;
		}

		//===========================================================================
		public static int GetTerrainCliffLevelBJ( BJLocation where )
		{
			// Original JassCode
			return GetTerrainCliffLevel(GetLocationX(where), GetLocationY(where));
		}

		//===========================================================================
		public static void SetWaterBaseColorBJ( double red , double green , double blue , double transparency )
		{
			// Original JassCode
			SetWaterBaseColor(PercentTo255(red), PercentTo255(green), PercentTo255(blue), PercentTo255(100.0-transparency));
		}

		//===========================================================================
		public static BJFogModifier CreateFogModifierRectSimple( BJPlayer whichPlayer , BJfogState whichFogState , BJRect r , bool afterUnits )
		{
			// Original JassCode
			lastCreatedFogModifier = CreateFogModifierRect(whichPlayer, whichFogState, r, true, afterUnits);
			return lastCreatedFogModifier;
		}

		//===========================================================================
		public static BJFogModifier CreateFogModifierRadiusLocSimple( BJPlayer whichPlayer , BJfogState whichFogState , BJLocation center , double radius , bool afterUnits )
		{
			// Original JassCode
			lastCreatedFogModifier = CreateFogModifierRadiusLoc(whichPlayer, whichFogState, center, radius, true, afterUnits);
			return lastCreatedFogModifier;
		}

		//===========================================================================
		// Version of CreateFogModifierRect that assumes use of sharedVision and
		// gives the option of immediately enabling the modifier, so that triggers
		// can default to modifiers that are immediately enabled.
		//
		public static BJFogModifier CreateFogModifierRectBJ( bool enabled , BJPlayer whichPlayer , BJfogState whichFogState , BJRect r )
		{
			// Original JassCode
			lastCreatedFogModifier = CreateFogModifierRect(whichPlayer, whichFogState, r, true, false);
			if(  enabled  )
			{
				FogModifierStart(lastCreatedFogModifier);
			}
			return lastCreatedFogModifier;
		}

		//===========================================================================
		// Version of CreateFogModifierRadius that assumes use of sharedVision and
		// gives the option of immediately enabling the modifier, so that triggers
		// can default to modifiers that are immediately enabled.
		//
		public static BJFogModifier CreateFogModifierRadiusLocBJ( bool enabled , BJPlayer whichPlayer , BJfogState whichFogState , BJLocation center , double radius )
		{
			// Original JassCode
			lastCreatedFogModifier = CreateFogModifierRadiusLoc(whichPlayer, whichFogState, center, radius, true, false);
			if(  enabled  )
			{
				FogModifierStart(lastCreatedFogModifier);
			}
			return lastCreatedFogModifier;
		}

		//===========================================================================
		public static BJFogModifier GetLastCreatedFogModifier(  )
		{
			// Original JassCode
			return lastCreatedFogModifier;
		}

		//===========================================================================
		public static void FogEnableOn(  )
		{
			// Original JassCode
			FogEnable(true);
		}

		//===========================================================================
		public static void FogEnableOff(  )
		{
			// Original JassCode
			FogEnable(false);
		}

		//===========================================================================
		public static void FogMaskEnableOn(  )
		{
			// Original JassCode
			FogMaskEnable(true);
		}

		//===========================================================================
		public static void FogMaskEnableOff(  )
		{
			// Original JassCode
			FogMaskEnable(false);
		}

		//===========================================================================
		public static void UseTimeOfDayBJ( bool flag )
		{
			// Original JassCode
			SuspendTimeOfDay(! flag);
		}

		//===========================================================================
		public static void SetTerrainFogExBJ( int style , double zstart , double zend , double density , double red , double green , double blue )
		{
			// Original JassCode
			SetTerrainFogEx(style, zstart, zend, density, red * 0.01, green * 0.01, blue * 0.01);
		}

		//===========================================================================
		public static void ResetTerrainFogBJ(  )
		{
			// Original JassCode
			ResetTerrainFog();
		}

		//===========================================================================
		public static void SetDoodadAnimationBJ( string animName , int doodadID , double radius , BJLocation center )
		{
			// Original JassCode
			SetDoodadAnimation(GetLocationX(center), GetLocationY(center), radius, doodadID, false, animName, false);
		}

		//===========================================================================
		public static void SetDoodadAnimationRectBJ( string animName , int doodadID , BJRect r )
		{
			// Original JassCode
			SetDoodadAnimationRect(r, doodadID, animName, false);
		}

		//===========================================================================
		public static void AddUnitAnimationPropertiesBJ( bool add , string animProperties , BJUnit whichUnit )
		{
			// Original JassCode
			AddUnitAnimationProperties(whichUnit, animProperties, add);
		}

		//***************************************************************************
		//*
		//*  Sound Utility Functions
		//*
		//***************************************************************************
		//===========================================================================
		public static void PlaySoundBJ( BJSound soundHandle )
		{
			// Original JassCode
			lastPlayedSound = soundHandle;
			if(  (soundHandle != null)  )
			{
				StartSound(soundHandle);
			}
		}

		//===========================================================================
		public static void StopSoundBJ( BJSound soundHandle , bool fadeOut )
		{
			// Original JassCode
			StopSound(soundHandle, false, fadeOut);
		}

		//===========================================================================
		public static void SetSoundVolumeBJ( BJSound soundHandle , double volumePercent )
		{
			// Original JassCode
			SetSoundVolume(soundHandle, PercentToInt(volumePercent, 127));
		}

		//===========================================================================
		public static void SetSoundOffsetBJ( double newOffset , BJSound soundHandle )
		{
			// Original JassCode
			SetSoundPlayPosition(soundHandle, R2I(newOffset * 1000));
		}

		//===========================================================================
		public static void SetSoundDistanceCutoffBJ( BJSound soundHandle , double cutoff )
		{
			// Original JassCode
			SetSoundDistanceCutoff(soundHandle, cutoff);
		}

		//===========================================================================
		public static void SetSoundPitchBJ( BJSound soundHandle , double pitch )
		{
			// Original JassCode
			SetSoundPitch(soundHandle, pitch);
		}

		//===========================================================================
		public static void SetSoundPositionLocBJ( BJSound soundHandle , BJLocation loc , double z )
		{
			// Original JassCode
			SetSoundPosition(soundHandle, GetLocationX(loc), GetLocationY(loc), z);
		}

		//===========================================================================
		public static void AttachSoundToUnitBJ( BJSound soundHandle , BJUnit whichUnit )
		{
			// Original JassCode
			AttachSoundToUnit(soundHandle, whichUnit);
		}

		//===========================================================================
		public static void SetSoundConeAnglesBJ( BJSound soundHandle , double inside , double outside , double outsideVolumePercent )
		{
			// Original JassCode
			SetSoundConeAngles(soundHandle, inside, outside, PercentToInt(outsideVolumePercent, 127));
		}

		//===========================================================================
		public static void KillSoundWhenDoneBJ( BJSound soundHandle )
		{
			// Original JassCode
			KillSoundWhenDone(soundHandle);
		}

		//===========================================================================
		public static void PlaySoundAtPointBJ( BJSound soundHandle , double volumePercent , BJLocation loc , double z )
		{
			// Original JassCode
			SetSoundPositionLocBJ(soundHandle, loc, z);
			SetSoundVolumeBJ(soundHandle, volumePercent);
			PlaySoundBJ(soundHandle);
		}

		//===========================================================================
		public static void PlaySoundOnUnitBJ( BJSound soundHandle , double volumePercent , BJUnit whichUnit )
		{
			// Original JassCode
			AttachSoundToUnitBJ(soundHandle, whichUnit);
			SetSoundVolumeBJ(soundHandle, volumePercent);
			PlaySoundBJ(soundHandle);
		}

		//===========================================================================
		public static void PlaySoundFromOffsetBJ( BJSound soundHandle , double volumePercent , double startingOffset )
		{
			// Original JassCode
			SetSoundVolumeBJ(soundHandle, volumePercent);
			PlaySoundBJ(soundHandle);
			SetSoundOffsetBJ(startingOffset, soundHandle);
		}

		//===========================================================================
		public static void PlayMusicBJ( string musicFileName )
		{
			// Original JassCode
			lastPlayedMusic = musicFileName;
			PlayMusic(musicFileName);
		}

		//===========================================================================
		public static void PlayMusicExBJ( string musicFileName , double startingOffset , double fadeInTime )
		{
			// Original JassCode
			lastPlayedMusic = musicFileName;
			PlayMusicEx(musicFileName, R2I(startingOffset * 1000), R2I(fadeInTime * 1000));
		}

		//===========================================================================
		public static void SetMusicOffsetBJ( double newOffset )
		{
			// Original JassCode
			SetMusicPlayPosition(R2I(newOffset * 1000));
		}

		//===========================================================================
		public static void PlayThematicMusicBJ( string musicName )
		{
			// Original JassCode
			PlayThematicMusic(musicName);
		}

		//===========================================================================
		public static void PlayThematicMusicExBJ( string musicName , double startingOffset )
		{
			// Original JassCode
			PlayThematicMusicEx(musicName, R2I(startingOffset * 1000));
		}

		//===========================================================================
		public static void SetThematicMusicOffsetBJ( double newOffset )
		{
			// Original JassCode
			SetThematicMusicPlayPosition(R2I(newOffset * 1000));
		}

		//===========================================================================
		public static void EndThematicMusicBJ(  )
		{
			// Original JassCode
			EndThematicMusic();
		}

		//===========================================================================
		public static void StopMusicBJ( bool fadeOut )
		{
			// Original JassCode
			StopMusic(fadeOut);
		}

		//===========================================================================
		public static void ResumeMusicBJ(  )
		{
			// Original JassCode
			ResumeMusic();
		}

		//===========================================================================
		public static void SetMusicVolumeBJ( double volumePercent )
		{
			// Original JassCode
			SetMusicVolume(PercentToInt(volumePercent, 127));
		}

		//===========================================================================
		public static double GetSoundDurationBJ( BJSound soundHandle )
		{
			// Original JassCode
			if(  (soundHandle == null)  )
			{
				return NOTHING_SOUND_DURATION;
			}
			else
			{
				return I2R(GetSoundDuration(soundHandle)) * 0.001;
			}
		}

		//===========================================================================
		public static double GetSoundFileDurationBJ( string musicFileName )
		{
			// Original JassCode
			return I2R(GetSoundFileDuration(musicFileName)) * 0.001;
		}

		//===========================================================================
		public static BJSound GetLastPlayedSound(  )
		{
			// Original JassCode
			return lastPlayedSound;
		}

		//===========================================================================
		public static string GetLastPlayedMusic(  )
		{
			// Original JassCode
			return lastPlayedMusic;
		}

		//===========================================================================
		public static void VolumeGroupSetVolumeBJ( BJVolumeGroup vgroup , double percent )
		{
			// Original JassCode
			VolumeGroupSetVolume(vgroup, percent * 0.01);
		}

		//===========================================================================
		public static void SetCineModeVolumeGroupsImmediateBJ(  )
		{
			// Original JassCode
			VolumeGroupSetVolume(SOUND_VOLUMEGROUP_UNITMOVEMENT, CINEMODE_VOLUME_UNITMOVEMENT);
			VolumeGroupSetVolume(SOUND_VOLUMEGROUP_UNITSOUNDS, CINEMODE_VOLUME_UNITSOUNDS);
			VolumeGroupSetVolume(SOUND_VOLUMEGROUP_COMBAT, CINEMODE_VOLUME_COMBAT);
			VolumeGroupSetVolume(SOUND_VOLUMEGROUP_SPELLS, CINEMODE_VOLUME_SPELLS);
			VolumeGroupSetVolume(SOUND_VOLUMEGROUP_UI, CINEMODE_VOLUME_UI);
			VolumeGroupSetVolume(SOUND_VOLUMEGROUP_MUSIC, CINEMODE_VOLUME_MUSIC);
			VolumeGroupSetVolume(SOUND_VOLUMEGROUP_AMBIENTSOUNDS, CINEMODE_VOLUME_AMBIENTSOUNDS);
			VolumeGroupSetVolume(SOUND_VOLUMEGROUP_FIRE, CINEMODE_VOLUME_FIRE);
		}

		//===========================================================================
		public static void SetCineModeVolumeGroupsBJ(  )
		{
			// Original JassCode
			// Delay the request if it occurs at map init.
			if(  gameStarted  )
			{
				SetCineModeVolumeGroupsImmediateBJ();
			}
			else
			{
				TimerStart(volumeGroupsTimer, GAME_STARTED_THRESHOLD, false,  SetCineModeVolumeGroupsImmediateBJ);
			}
		}

		//===========================================================================
		public static void SetSpeechVolumeGroupsImmediateBJ(  )
		{
			// Original JassCode
			VolumeGroupSetVolume(SOUND_VOLUMEGROUP_UNITMOVEMENT, SPEECH_VOLUME_UNITMOVEMENT);
			VolumeGroupSetVolume(SOUND_VOLUMEGROUP_UNITSOUNDS, SPEECH_VOLUME_UNITSOUNDS);
			VolumeGroupSetVolume(SOUND_VOLUMEGROUP_COMBAT, SPEECH_VOLUME_COMBAT);
			VolumeGroupSetVolume(SOUND_VOLUMEGROUP_SPELLS, SPEECH_VOLUME_SPELLS);
			VolumeGroupSetVolume(SOUND_VOLUMEGROUP_UI, SPEECH_VOLUME_UI);
			VolumeGroupSetVolume(SOUND_VOLUMEGROUP_MUSIC, SPEECH_VOLUME_MUSIC);
			VolumeGroupSetVolume(SOUND_VOLUMEGROUP_AMBIENTSOUNDS, SPEECH_VOLUME_AMBIENTSOUNDS);
			VolumeGroupSetVolume(SOUND_VOLUMEGROUP_FIRE, SPEECH_VOLUME_FIRE);
		}

		//===========================================================================
		public static void SetSpeechVolumeGroupsBJ(  )
		{
			// Original JassCode
			// Delay the request if it occurs at map init.
			if(  gameStarted  )
			{
				SetSpeechVolumeGroupsImmediateBJ();
			}
			else
			{
				TimerStart(volumeGroupsTimer, GAME_STARTED_THRESHOLD, false,  SetSpeechVolumeGroupsImmediateBJ);
			}
		}

		//===========================================================================
		public static void VolumeGroupResetImmediateBJ(  )
		{
			// Original JassCode
			VolumeGroupReset();
		}

		//===========================================================================
		public static void VolumeGroupResetBJ(  )
		{
			// Original JassCode
			// Delay the request if it occurs at map init.
			if(  gameStarted  )
			{
				VolumeGroupResetImmediateBJ();
			}
			else
			{
				TimerStart(volumeGroupsTimer, GAME_STARTED_THRESHOLD, false,  VolumeGroupResetImmediateBJ);
			}
		}

		//===========================================================================
		public static bool GetSoundIsPlayingBJ( BJSound soundHandle )
		{
			// Original JassCode
			return GetSoundIsLoading(soundHandle) || GetSoundIsPlaying(soundHandle);
		}

		//===========================================================================
		public static void WaitForSoundBJ( BJSound soundHandle , double offset )
		{
			// Original JassCode
			TriggerWaitForSound( soundHandle, offset );
		}

		//===========================================================================
		public static void SetMapMusicIndexedBJ( string musicName , int index )
		{
			// Original JassCode
			SetMapMusic(musicName, false, index);
		}

		//===========================================================================
		public static void SetMapMusicRandomBJ( string musicName )
		{
			// Original JassCode
			SetMapMusic(musicName, true, 0);
		}

		//===========================================================================
		public static void ClearMapMusicBJ(  )
		{
			// Original JassCode
			ClearMapMusic();
		}

		//===========================================================================
		public static void SetStackedSoundBJ( bool add , BJSound soundHandle , BJRect r )
		{
			// Original JassCode
			double width = GetRectMaxX(r) - GetRectMinX(r);
			double height = GetRectMaxY(r) - GetRectMinY(r);
			SetSoundPosition(soundHandle, GetRectCenterX(r), GetRectCenterY(r), 0);
			if(  add  )
			{
				RegisterStackedSound(soundHandle, true, width, height);
			}
			else
			{
				UnregisterStackedSound(soundHandle, true, width, height);
			}
		}

		//===========================================================================
		public static void StartSoundForPlayerBJ( BJPlayer whichPlayer , BJSound soundHandle )
		{
			// Original JassCode
			if(  (whichPlayer == GetLocalPlayer())  )
			{
				StartSound(soundHandle);
			}
		}

		//===========================================================================
		public static void VolumeGroupSetVolumeForPlayerBJ( BJPlayer whichPlayer , BJVolumeGroup vgroup , double scale )
		{
			// Original JassCode
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				VolumeGroupSetVolume(vgroup, scale);
			}
		}

		//===========================================================================
		public static void EnableDawnDusk( bool flag )
		{
			// Original JassCode
			useDawnDuskSounds = flag;
		}

		//===========================================================================
		public static bool IsDawnDuskEnabled(  )
		{
			// Original JassCode
			return useDawnDuskSounds;
		}

		//***************************************************************************
		//*
		//*  Day/Night ambient sounds
		//*
		//***************************************************************************
		//===========================================================================
		public static void SetAmbientDaySound( string inLabel )
		{
			// Original JassCode
			double ToD;
			// Stop old sound, if necessary
			if(  (dayAmbientSound != null)  )
			{
				StopSound(dayAmbientSound, true, true);
			}
			// Create new sound
			dayAmbientSound = CreateMIDISound(inLabel, 20, 20);
			// Start the sound if necessary, based on current time
			ToD = GetTimeOfDay();
			if(  (ToD >= TOD_DAWN && ToD < TOD_DUSK)  )
			{
				StartSound(dayAmbientSound);
			}
		}

		//===========================================================================
		public static void SetAmbientNightSound( string inLabel )
		{
			// Original JassCode
			double ToD;
			// Stop old sound, if necessary
			if(  (nightAmbientSound != null)  )
			{
				StopSound(nightAmbientSound, true, true);
			}
			// Create new sound
			nightAmbientSound = CreateMIDISound(inLabel, 20, 20);
			// Start the sound if necessary, based on current time
			ToD = GetTimeOfDay();
			if(  (ToD < TOD_DAWN || ToD >= TOD_DUSK)  )
			{
				StartSound(nightAmbientSound);
			}
		}

		//***************************************************************************
		//*
		//*  Special Effect Utility Functions
		//*
		//***************************************************************************
		//===========================================================================
		public static BJEffect AddSpecialEffectLocBJ( BJLocation where , string modelName )
		{
			// Original JassCode
			lastCreatedEffect = AddSpecialEffectLoc(modelName, where);
			return lastCreatedEffect;
		}

		//===========================================================================
		public static BJEffect AddSpecialEffectTargetUnitBJ( string attachPointName , BJWidget targetWidget , string modelName )
		{
			// Original JassCode
			lastCreatedEffect = AddSpecialEffectTarget(modelName, targetWidget, attachPointName);
			return lastCreatedEffect;
		}

		//===========================================================================
		// Two distinct trigger actions can't share the same function name, so this
		// dummy function simply mimics the behavior of an existing call.
		//
		// Commented out - Destructibles have no attachment points.
		//
		//function AddSpecialEffectTargetDestructableBJ takes string attachPointName, widget targetWidget, string modelName returns effect
		//    return AddSpecialEffectTargetUnitBJ(attachPointName, targetWidget, modelName)
		//endfunction
		//===========================================================================
		// Two distinct trigger actions can't share the same function name, so this
		// dummy function simply mimics the behavior of an existing call.
		//
		// Commented out - Items have no attachment points.
		//
		//function AddSpecialEffectTargetItemBJ takes string attachPointName, widget targetWidget, string modelName returns effect
		//    return AddSpecialEffectTargetUnitBJ(attachPointName, targetWidget, modelName)
		//endfunction
		//===========================================================================
		public static void DestroyEffectBJ( BJEffect whichEffect )
		{
			// Original JassCode
			DestroyEffect(whichEffect);
		}

		//===========================================================================
		public static BJEffect GetLastCreatedEffectBJ(  )
		{
			// Original JassCode
			return lastCreatedEffect;
		}

		//***************************************************************************
		//*
		//*  Hero and Item Utility Functions
		//*
		//***************************************************************************
		//===========================================================================
		public static BJLocation GetItemLoc( BJItem whichItem )
		{
			// Original JassCode
			return Location(GetItemX(whichItem), GetItemY(whichItem));
		}

		//===========================================================================
		public static double GetItemLifeBJ( BJWidget whichWidget )
		{
			// Original JassCode
			return GetWidgetLife(whichWidget);
		}

		//===========================================================================
		public static void SetItemLifeBJ( BJWidget whichWidget , double life )
		{
			// Original JassCode
			SetWidgetLife(whichWidget, life);
		}

		//===========================================================================
		public static void AddHeroXPSwapped( int xpToAdd , BJUnit whichHero , bool showEyeCandy )
		{
			// Original JassCode
			AddHeroXP(whichHero, xpToAdd, showEyeCandy);
		}

		//===========================================================================
		public static void SetHeroLevelBJ( BJUnit whichHero , int newLevel , bool showEyeCandy )
		{
			// Original JassCode
			int oldLevel = GetHeroLevel(whichHero);
			if(  (newLevel > oldLevel)  )
			{
				SetHeroLevel(whichHero, newLevel, showEyeCandy);
			}
			else if(  (newLevel < oldLevel)  )
			{
				UnitStripHeroLevel(whichHero, oldLevel - newLevel);
			}
			else
			{
				// No change in level - ignore the request.
			}
		}

		//===========================================================================
		public static bool UnitAddItemSwapped( BJItem whichItem , BJUnit whichHero )
		{
			// Original JassCode
			return UnitAddItem(whichHero, whichItem);
		}

		//===========================================================================
		public static BJItem UnitAddItemByIdSwapped( int itemId , BJUnit whichHero )
		{
			// Original JassCode
			// Create the item at the hero's feet first, and then give it to him.
			// This is to ensure that the item will be left at the hero's feet if
			// his inventory is full. 
			lastCreatedItem = CreateItem(itemId, GetUnitX(whichHero), GetUnitY(whichHero));
			UnitAddItem(whichHero, lastCreatedItem);
			return lastCreatedItem;
		}

		//===========================================================================
		public static void UnitRemoveItemSwapped( BJItem whichItem , BJUnit whichHero )
		{
			// Original JassCode
			lastRemovedItem = whichItem;
			UnitRemoveItem(whichHero, whichItem);
		}

		//===========================================================================
		// Translates 0-based slot indices to 1-based slot indices.
		//
		public static BJItem UnitRemoveItemFromSlotSwapped( int itemSlot , BJUnit whichHero )
		{
			// Original JassCode
			lastRemovedItem = UnitRemoveItemFromSlot(whichHero, itemSlot-1);
			return lastRemovedItem;
		}

		//===========================================================================
		public static BJItem CreateItemLoc( int itemId , BJLocation loc )
		{
			// Original JassCode
			lastCreatedItem = CreateItem(itemId, GetLocationX(loc), GetLocationY(loc));
			return lastCreatedItem;
		}

		//===========================================================================
		public static BJItem GetLastCreatedItem(  )
		{
			// Original JassCode
			return lastCreatedItem;
		}

		//===========================================================================
		public static BJItem GetLastRemovedItem(  )
		{
			// Original JassCode
			return lastRemovedItem;
		}

		//===========================================================================
		public static void SetItemPositionLoc( BJItem whichItem , BJLocation loc )
		{
			// Original JassCode
			SetItemPosition(whichItem, GetLocationX(loc), GetLocationY(loc));
		}

		//===========================================================================
		public static int GetLearnedSkillBJ(  )
		{
			// Original JassCode
			return GetLearnedSkill();
		}

		//===========================================================================
		public static void SuspendHeroXPBJ( bool flag , BJUnit whichHero )
		{
			// Original JassCode
			SuspendHeroXP(whichHero, ! flag);
		}

		//===========================================================================
		public static void SetPlayerHandicapXPBJ( BJPlayer whichPlayer , double handicapPercent )
		{
			// Original JassCode
			SetPlayerHandicapXP(whichPlayer, handicapPercent * 0.01);
		}

		//===========================================================================
		public static double GetPlayerHandicapXPBJ( BJPlayer whichPlayer )
		{
			// Original JassCode
			return GetPlayerHandicapXP(whichPlayer) * 100;
		}

		//===========================================================================
		public static void SetPlayerHandicapBJ( BJPlayer whichPlayer , double handicapPercent )
		{
			// Original JassCode
			SetPlayerHandicap(whichPlayer, handicapPercent * 0.01);
		}

		//===========================================================================
		public static double GetPlayerHandicapBJ( BJPlayer whichPlayer )
		{
			// Original JassCode
			return GetPlayerHandicap(whichPlayer) * 100;
		}

		//===========================================================================
		public static int GetHeroStatBJ( int whichStat , BJUnit whichHero , bool includeBonuses )
		{
			// Original JassCode
			if(  (whichStat == HEROSTAT_STR)  )
			{
				return GetHeroStr(whichHero, includeBonuses);
			}
			else if(  (whichStat == HEROSTAT_AGI)  )
			{
				return GetHeroAgi(whichHero, includeBonuses);
			}
			else if(  (whichStat == HEROSTAT_INT)  )
			{
				return GetHeroInt(whichHero, includeBonuses);
			}
			else
			{
				// Unrecognized hero stat - return 0
				return 0;
			}
		}

		//===========================================================================
		public static void SetHeroStat( BJUnit whichHero , int whichStat , int value )
		{
			// Original JassCode
			// Ignore requests for negative hero stats.
			if(  (value <= 0)  )
			{
				return;
			}
			if(  (whichStat == HEROSTAT_STR)  )
			{
				SetHeroStr(whichHero, value, true);
			}
			else if(  (whichStat == HEROSTAT_AGI)  )
			{
				SetHeroAgi(whichHero, value, true);
			}
			else if(  (whichStat == HEROSTAT_INT)  )
			{
				SetHeroInt(whichHero, value, true);
			}
			else
			{
				// Unrecognized hero stat - ignore the request.
			}
		}

		//===========================================================================
		public static void ModifyHeroStat( int whichStat , BJUnit whichHero , int modifyMethod , int value )
		{
			// Original JassCode
			if(  (modifyMethod == MODIFYMETHOD_ADD)  )
			{
				SetHeroStat(whichHero, whichStat, GetHeroStatBJ(whichStat, whichHero, false) + value);
			}
			else if(  (modifyMethod == MODIFYMETHOD_SUB)  )
			{
				SetHeroStat(whichHero, whichStat, GetHeroStatBJ(whichStat, whichHero, false) - value);
			}
			else if(  (modifyMethod == MODIFYMETHOD_SET)  )
			{
				SetHeroStat(whichHero, whichStat, value);
			}
			else
			{
				// Unrecognized modification method - ignore the request.
			}
		}

		//===========================================================================
		public static bool ModifyHeroSkillPoints( BJUnit whichHero , int modifyMethod , int value )
		{
			// Original JassCode
			if(  (modifyMethod == MODIFYMETHOD_ADD)  )
			{
				return UnitModifySkillPoints(whichHero, value);
			}
			else if(  (modifyMethod == MODIFYMETHOD_SUB)  )
			{
				return UnitModifySkillPoints(whichHero, -value);
			}
			else if(  (modifyMethod == MODIFYMETHOD_SET)  )
			{
				return UnitModifySkillPoints(whichHero, value - GetHeroSkillPoints(whichHero));
			}
			else
			{
				// Unrecognized modification method - ignore the request and return failure.
				return false;
			}
		}

		//===========================================================================
		// Two distinct trigger actions can't share the same function name, so this
		// dummy function simply mimics the behavior of an existing call.
		//
		public static bool UnitUseItemDestructable( BJUnit whichUnit , BJItem whichItem , BJWidget target )
		{
			// Original JassCode
			return UnitUseItemTarget(whichUnit, whichItem, target);
		}

		//===========================================================================
		public static bool UnitUseItemPointLoc( BJUnit whichUnit , BJItem whichItem , BJLocation loc )
		{
			// Original JassCode
			return UnitUseItemPoint(whichUnit, whichItem, GetLocationX(loc), GetLocationY(loc));
		}

		//===========================================================================
		// Translates 0-based slot indices to 1-based slot indices.
		//
		public static BJItem UnitItemInSlotBJ( BJUnit whichUnit , int itemSlot )
		{
			// Original JassCode
			return UnitItemInSlot(whichUnit, itemSlot-1);
		}

		//===========================================================================
		// Translates 0-based slot indices to 1-based slot indices.
		//
		public static int GetInventoryIndexOfItemTypeBJ( BJUnit whichUnit , int itemId )
		{
			// Original JassCode
			int index;
			BJItem indexItem;
			index = 0;
			while( true )
			{
				indexItem = UnitItemInSlot(whichUnit, index);
				if(  (indexItem != null) && (GetItemTypeId(indexItem) == itemId)  )
				{
					return index + 1;
				}
				index = index + 1;
				if(  index >= MAX_INVENTORY )
					break;
			}
			return 0;
		}

		//===========================================================================
		public static BJItem GetItemOfTypeFromUnitBJ( BJUnit whichUnit , int itemId )
		{
			// Original JassCode
			int index = GetInventoryIndexOfItemTypeBJ(whichUnit, itemId);
			if(  (index == 0)  )
			{
				return null;
			}
			else
			{
				return UnitItemInSlot(whichUnit, index - 1);
			}
		}

		//===========================================================================
		public static bool UnitHasItemOfTypeBJ( BJUnit whichUnit , int itemId )
		{
			// Original JassCode
			return GetInventoryIndexOfItemTypeBJ(whichUnit, itemId) > 0;
		}

		//===========================================================================
		public static void SetItemInvulnerableBJ( BJItem whichItem , bool flag )
		{
			// Original JassCode
			SetItemInvulnerable(whichItem, flag);
		}

		//===========================================================================
		public static void SetItemDropOnDeathBJ( BJItem whichItem , bool flag )
		{
			// Original JassCode
			SetItemDropOnDeath(whichItem, flag);
		}

		//===========================================================================
		public static void SetItemDroppableBJ( BJItem whichItem , bool flag )
		{
			// Original JassCode
			SetItemDroppable(whichItem, flag);
		}

		//===========================================================================
		public static void SetItemPlayerBJ( BJItem whichItem , BJPlayer whichPlayer , bool changeColor )
		{
			// Original JassCode
			SetItemPlayer(whichItem, whichPlayer, changeColor);
		}

		//===========================================================================
		public static void SetItemVisibleBJ( bool show , BJItem whichItem )
		{
			// Original JassCode
			SetItemVisible(whichItem, show);
		}

		//===========================================================================
		public static bool IsItemHiddenBJ( BJItem whichItem )
		{
			// Original JassCode
			return ! IsItemVisible(whichItem);
		}

		//===========================================================================
		public static int ChooseRandomItemBJ( int level )
		{
			// Original JassCode
			return ChooseRandomItem(level);
		}

		//===========================================================================
		public static int ChooseRandomItemExBJ( int level , BJItemType whichType )
		{
			// Original JassCode
			return ChooseRandomItemEx(whichType, level);
		}

		//===========================================================================
		public static int ChooseRandomNPBuildingBJ(  )
		{
			// Original JassCode
			return ChooseRandomNPBuilding();
		}

		//===========================================================================
		public static int ChooseRandomCreepBJ( int level )
		{
			// Original JassCode
			return ChooseRandomCreep(level);
		}

		//===========================================================================
		public static void EnumItemsInRectBJ( BJRect r , BJCode actionFunc )
		{
			// Original JassCode
			EnumItemsInRect(r, null, actionFunc);
		}

		//===========================================================================
		// See GroupPickRandomUnitEnum for the details of this algorithm.
		//
		public static void RandomItemInRectBJEnum(  )
		{
			// Original JassCode
			itemRandomConsidered = itemRandomConsidered + 1;
			if(  (GetRandomInt(1, itemRandomConsidered) == 1)  )
			{
				itemRandomCurrentPick = GetEnumItem();
			}
		}

		//===========================================================================
		// Picks a random item from within a rect, matching a condition
		//
		public static BJItem RandomItemInRectBJ( BJRect r , BJBoolExpr filter )
		{
			// Original JassCode
			itemRandomConsidered = 0;
			itemRandomCurrentPick = null;
			EnumItemsInRect(r, filter,  RandomItemInRectBJEnum);
			DestroyBoolExpr(filter);
			return itemRandomCurrentPick;
		}

		//===========================================================================
		// Picks a random item from within a rect
		//
		public static BJItem RandomItemInRectSimpleBJ( BJRect r )
		{
			// Original JassCode
			return RandomItemInRectBJ(r, null);
		}

		//===========================================================================
		public static bool CheckItemStatus( BJItem whichItem , int status )
		{
			// Original JassCode
			if(  (status == ITEM_STATUS_HIDDEN)  )
			{
				return ! IsItemVisible(whichItem);
			}
			else if(  (status == ITEM_STATUS_OWNED)  )
			{
				return IsItemOwned(whichItem);
			}
			else if(  (status == ITEM_STATUS_INVULNERABLE)  )
			{
				return IsItemInvulnerable(whichItem);
			}
			else if(  (status == ITEM_STATUS_POWERUP)  )
			{
				return IsItemPowerup(whichItem);
			}
			else if(  (status == ITEM_STATUS_SELLABLE)  )
			{
				return IsItemSellable(whichItem);
			}
			else if(  (status == ITEM_STATUS_PAWNABLE)  )
			{
				return IsItemPawnable(whichItem);
			}
			else
			{
				// Unrecognized status - return false
				return false;
			}
		}

		//===========================================================================
		public static bool CheckItemcodeStatus( int itemId , int status )
		{
			// Original JassCode
			if(  (status == ITEMCODE_STATUS_POWERUP)  )
			{
				return IsItemIdPowerup(itemId);
			}
			else if(  (status == ITEMCODE_STATUS_SELLABLE)  )
			{
				return IsItemIdSellable(itemId);
			}
			else if(  (status == ITEMCODE_STATUS_PAWNABLE)  )
			{
				return IsItemIdPawnable(itemId);
			}
			else
			{
				// Unrecognized status - return false
				return false;
			}
		}

		//***************************************************************************
		//*
		//*  Unit Utility Functions
		//*
		//***************************************************************************
		//===========================================================================
		public static int UnitId2OrderIdBJ( int unitId )
		{
			// Original JassCode
			return unitId;
		}

		//===========================================================================
		public static int String2UnitIdBJ( string unitIdString )
		{
			// Original JassCode
			return UnitId(unitIdString);
		}

		//===========================================================================
		public static string UnitId2StringBJ( int unitId )
		{
			// Original JassCode
			string unitString = UnitId2String(unitId);
			if(  (unitString != null)  )
			{
				return unitString;
			}
			// The unitId was not recognized - return an empty string.
			return "";
		}

		//===========================================================================
		public static int String2OrderIdBJ( string orderIdString )
		{
			// Original JassCode
			int orderId;
			// Check to see if it's a generic order.
			orderId = OrderId(orderIdString);
			if(  (orderId != 0)  )
			{
				return orderId;
			}
			// Check to see if it's a (train) unit order.
			orderId = UnitId(orderIdString);
			if(  (orderId != 0)  )
			{
				return orderId;
			}
			// Unrecognized - return 0
			return 0;
		}

		//===========================================================================
		public static string OrderId2StringBJ( int orderId )
		{
			// Original JassCode
			string orderString;
			// Check to see if it's a generic order.
			orderString = OrderId2String(orderId);
			if(  (orderString != null)  )
			{
				return orderString;
			}
			// Check to see if it's a (train) unit order.
			orderString = UnitId2String(orderId);
			if(  (orderString != null)  )
			{
				return orderString;
			}
			// Unrecognized - return an empty string.
			return "";
		}

		//===========================================================================
		public static int GetIssuedOrderIdBJ(  )
		{
			// Original JassCode
			return GetIssuedOrderId();
		}

		//===========================================================================
		public static BJUnit GetKillingUnitBJ(  )
		{
			// Original JassCode
			return GetKillingUnit();
		}

		//===========================================================================
		public static BJUnit CreateUnitAtLocSaveLast( BJPlayer id , int unitid , BJLocation loc , double face )
		{
			// Original JassCode
			if(  (unitid == UnitId( "ugol" ))  )
			{
				lastCreatedUnit = CreateBlightedGoldmine(id, GetLocationX(loc), GetLocationY(loc), face);
			}
			else
			{
				lastCreatedUnit = CreateUnitAtLoc(id, unitid, loc, face);
			}
			return lastCreatedUnit;
		}

		//===========================================================================
		public static BJUnit GetLastCreatedUnit(  )
		{
			// Original JassCode
			return lastCreatedUnit;
		}

		//===========================================================================
		public static BJGroup CreateNUnitsAtLoc( int count , int unitId , BJPlayer whichPlayer , BJLocation loc , double face )
		{
			// Original JassCode
			GroupClear(lastCreatedGroup);
			while( true )
			{
				count = count - 1;
				if(  count < 0 )
					break;
				CreateUnitAtLocSaveLast(whichPlayer, unitId, loc, face);
				GroupAddUnit(lastCreatedGroup, lastCreatedUnit);
			}
			return lastCreatedGroup;
		}

		//===========================================================================
		public static BJGroup CreateNUnitsAtLocFacingLocBJ( int count , int unitId , BJPlayer whichPlayer , BJLocation loc , BJLocation lookAt )
		{
			// Original JassCode
			return CreateNUnitsAtLoc(count, unitId, whichPlayer, loc, AngleBetweenPoints(loc, lookAt));
		}

		//===========================================================================
		public static void GetLastCreatedGroupEnum(  )
		{
			// Original JassCode
			GroupAddUnit(groupLastCreatedDest, GetEnumUnit());
		}

		//===========================================================================
		public static BJGroup GetLastCreatedGroup(  )
		{
			// Original JassCode
			groupLastCreatedDest = CreateGroup();
			ForGroup(lastCreatedGroup,  GetLastCreatedGroupEnum);
			return groupLastCreatedDest;
		}

		//===========================================================================
		public static BJUnit CreateCorpseLocBJ( int unitid , BJPlayer whichPlayer , BJLocation loc )
		{
			// Original JassCode
			lastCreatedUnit = CreateCorpse(whichPlayer, unitid, GetLocationX(loc), GetLocationY(loc), GetRandomReal(0, 360));
			return lastCreatedUnit;
		}

		//===========================================================================
		public static void UnitSuspendDecayBJ( bool suspend , BJUnit whichUnit )
		{
			// Original JassCode
			UnitSuspendDecay(whichUnit, suspend);
		}

		//===========================================================================
		public static void DelayedSuspendDecayStopAnimEnum(  )
		{
			// Original JassCode
			BJUnit enumUnit = GetEnumUnit();
			if(  (GetUnitState(enumUnit, UNIT_STATE_LIFE) <= 0)  )
			{
				SetUnitTimeScale(enumUnit, 0.0001);
			}
		}

		//===========================================================================
		public static void DelayedSuspendDecayBoneEnum(  )
		{
			// Original JassCode
			BJUnit enumUnit = GetEnumUnit();
			if(  (GetUnitState(enumUnit, UNIT_STATE_LIFE) <= 0)  )
			{
				UnitSuspendDecay(enumUnit, true);
				SetUnitTimeScale(enumUnit, 0.0001);
			}
		}

		//===========================================================================
		// Game code explicitly sets the animation back to "decay bone" after the
		// initial corpse fades away, so we reset it now.  It's best not to show
		// off corpses thus created until after this grace period has passed.
		//
		public static void DelayedSuspendDecayFleshEnum(  )
		{
			// Original JassCode
			BJUnit enumUnit = GetEnumUnit();
			if(  (GetUnitState(enumUnit, UNIT_STATE_LIFE) <= 0)  )
			{
				UnitSuspendDecay(enumUnit, true);
				SetUnitTimeScale(enumUnit, 10.0);
				SetUnitAnimation(enumUnit, "decay flesh");
			}
		}

		//===========================================================================
		// Waits a short period of time to ensure that the corpse is decaying, and
		// then suspend the animation and corpse decay.
		//
		public static void DelayedSuspendDecay(  )
		{
			// Original JassCode
			BJGroup boneGroup;
			BJGroup fleshGroup;
			// Switch the global unit groups over to local variables and recreate
			// the global versions, so that this function can handle overlapping
			// calls.
			boneGroup = suspendDecayBoneGroup;
			fleshGroup = suspendDecayFleshGroup;
			suspendDecayBoneGroup = CreateGroup();
			suspendDecayFleshGroup = CreateGroup();
			ForGroup(fleshGroup,  DelayedSuspendDecayStopAnimEnum);
			ForGroup(boneGroup,  DelayedSuspendDecayStopAnimEnum);
			TriggerSleepAction(CORPSE_MAX_DEATH_TIME);
			ForGroup(fleshGroup,  DelayedSuspendDecayFleshEnum);
			ForGroup(boneGroup,  DelayedSuspendDecayBoneEnum);
			TriggerSleepAction(0.05);
			ForGroup(fleshGroup,  DelayedSuspendDecayStopAnimEnum);
			DestroyGroup(boneGroup);
			DestroyGroup(fleshGroup);
		}

		//===========================================================================
		public static void DelayedSuspendDecayCreate(  )
		{
			// Original JassCode
			delayedSuspendDecayTrig = CreateTrigger();
			TriggerRegisterTimerExpireEvent(delayedSuspendDecayTrig, delayedSuspendDecayTimer);
			TriggerAddAction(delayedSuspendDecayTrig,  DelayedSuspendDecay);
		}

		//===========================================================================
		public static BJUnit CreatePermanentCorpseLocBJ( int style , int unitid , BJPlayer whichPlayer , BJLocation loc , double facing )
		{
			// Original JassCode
			lastCreatedUnit = CreateCorpse(whichPlayer, unitid, GetLocationX(loc), GetLocationY(loc), facing);
			SetUnitBlendTime(lastCreatedUnit, 0);
			if(  (style == CORPSETYPE_FLESH)  )
			{
				SetUnitAnimation(lastCreatedUnit, "decay flesh");
				GroupAddUnit(suspendDecayFleshGroup, lastCreatedUnit);
			}
			else if(  (style == CORPSETYPE_BONE)  )
			{
				SetUnitAnimation(lastCreatedUnit, "decay bone");
				GroupAddUnit(suspendDecayBoneGroup, lastCreatedUnit);
			}
			else
			{
				// Unknown decay style - treat as skeletal.
				SetUnitAnimation(lastCreatedUnit, "decay bone");
				GroupAddUnit(suspendDecayBoneGroup, lastCreatedUnit);
			}
			TimerStart(delayedSuspendDecayTimer, 0.05, false, null);
			return lastCreatedUnit;
		}

		//===========================================================================
		public static double GetUnitStateSwap( BJUnitState whichState , BJUnit whichUnit )
		{
			// Original JassCode
			return GetUnitState(whichUnit, whichState);
		}

		//===========================================================================
		public static double GetUnitStatePercent( BJUnit whichUnit , BJUnitState whichState , BJUnitState whichMaxState )
		{
			// Original JassCode
			double value = GetUnitState(whichUnit, whichState);
			double maxValue = GetUnitState(whichUnit, whichMaxState);
			// Return 0 for null units.
			if(  (whichUnit == null) || (maxValue == 0)  )
			{
				return 0.0;
			}
			return value / maxValue * 100.0;
		}

		//===========================================================================
		public static double GetUnitLifePercent( BJUnit whichUnit )
		{
			// Original JassCode
			return GetUnitStatePercent(whichUnit, UNIT_STATE_LIFE, UNIT_STATE_MAX_LIFE);
		}

		//===========================================================================
		public static double GetUnitManaPercent( BJUnit whichUnit )
		{
			// Original JassCode
			return GetUnitStatePercent(whichUnit, UNIT_STATE_MANA, UNIT_STATE_MAX_MANA);
		}

		//===========================================================================
		public static void SelectUnitSingle( BJUnit whichUnit )
		{
			// Original JassCode
			ClearSelection();
			SelectUnit(whichUnit, true);
		}

		//===========================================================================
		public static void SelectGroupBJEnum(  )
		{
			// Original JassCode
			SelectUnit( GetEnumUnit(), true );
		}

		//===========================================================================
		public static void SelectGroupBJ( BJGroup g )
		{
			// Original JassCode
			ClearSelection();
			ForGroup( g,  SelectGroupBJEnum );
		}

		//===========================================================================
		public static void SelectUnitAdd( BJUnit whichUnit )
		{
			// Original JassCode
			SelectUnit(whichUnit, true);
		}

		//===========================================================================
		public static void SelectUnitRemove( BJUnit whichUnit )
		{
			// Original JassCode
			SelectUnit(whichUnit, false);
		}

		//===========================================================================
		public static void ClearSelectionForPlayer( BJPlayer whichPlayer )
		{
			// Original JassCode
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				ClearSelection();
			}
		}

		//===========================================================================
		public static void SelectUnitForPlayerSingle( BJUnit whichUnit , BJPlayer whichPlayer )
		{
			// Original JassCode
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				ClearSelection();
				SelectUnit(whichUnit, true);
			}
		}

		//===========================================================================
		public static void SelectGroupForPlayerBJ( BJGroup g , BJPlayer whichPlayer )
		{
			// Original JassCode
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				ClearSelection();
				ForGroup( g,  SelectGroupBJEnum );
			}
		}

		//===========================================================================
		public static void SelectUnitAddForPlayer( BJUnit whichUnit , BJPlayer whichPlayer )
		{
			// Original JassCode
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				SelectUnit(whichUnit, true);
			}
		}

		//===========================================================================
		public static void SelectUnitRemoveForPlayer( BJUnit whichUnit , BJPlayer whichPlayer )
		{
			// Original JassCode
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				SelectUnit(whichUnit, false);
			}
		}

		//===========================================================================
		public static void SetUnitLifeBJ( BJUnit whichUnit , double newValue )
		{
			// Original JassCode
			SetUnitState(whichUnit, UNIT_STATE_LIFE, RMaxBJ(0,newValue));
		}

		//===========================================================================
		public static void SetUnitManaBJ( BJUnit whichUnit , double newValue )
		{
			// Original JassCode
			SetUnitState(whichUnit, UNIT_STATE_MANA, RMaxBJ(0,newValue));
		}

		//===========================================================================
		public static void SetUnitLifePercentBJ( BJUnit whichUnit , double percent )
		{
			// Original JassCode
			SetUnitState(whichUnit, UNIT_STATE_LIFE, GetUnitState(whichUnit, UNIT_STATE_MAX_LIFE) * RMaxBJ(0,percent) * 0.01);
		}

		//===========================================================================
		public static void SetUnitManaPercentBJ( BJUnit whichUnit , double percent )
		{
			// Original JassCode
			SetUnitState(whichUnit, UNIT_STATE_MANA, GetUnitState(whichUnit, UNIT_STATE_MAX_MANA) * RMaxBJ(0,percent) * 0.01);
		}

		//===========================================================================
		public static bool IsUnitDeadBJ( BJUnit whichUnit )
		{
			// Original JassCode
			return GetUnitState(whichUnit, UNIT_STATE_LIFE) <= 0;
		}

		//===========================================================================
		public static bool IsUnitAliveBJ( BJUnit whichUnit )
		{
			// Original JassCode
			return ! IsUnitDeadBJ(whichUnit);
		}

		//===========================================================================
		public static void IsUnitGroupDeadBJEnum(  )
		{
			// Original JassCode
			if(  ! IsUnitDeadBJ(GetEnumUnit())  )
			{
				isUnitGroupDeadResult = false;
			}
		}

		//===========================================================================
		// Returns true if every unit of the group is dead.
		//
		public static bool IsUnitGroupDeadBJ( BJGroup g )
		{
			// Original JassCode
			// If the user wants the group destroyed, remember that fact and clear
			// the flag, in case it is used again in the callback.
			bool wantDestroy = wantDestroyGroup;
			wantDestroyGroup = false;
			isUnitGroupDeadResult = true;
			ForGroup(g,  IsUnitGroupDeadBJEnum);
			// If the user wants the group destroyed, do so now.
			if(  (wantDestroy)  )
			{
				DestroyGroup(g);
			}
			return isUnitGroupDeadResult;
		}

		//===========================================================================
		public static void IsUnitGroupEmptyBJEnum(  )
		{
			// Original JassCode
			isUnitGroupEmptyResult = false;
		}

		//===========================================================================
		// Returns true if the group contains no units.
		//
		public static bool IsUnitGroupEmptyBJ( BJGroup g )
		{
			// Original JassCode
			// If the user wants the group destroyed, remember that fact and clear
			// the flag, in case it is used again in the callback.
			bool wantDestroy = wantDestroyGroup;
			wantDestroyGroup = false;
			isUnitGroupEmptyResult = true;
			ForGroup(g,  IsUnitGroupEmptyBJEnum);
			// If the user wants the group destroyed, do so now.
			if(  (wantDestroy)  )
			{
				DestroyGroup(g);
			}
			return isUnitGroupEmptyResult;
		}

		//===========================================================================
		public static void IsUnitGroupInRectBJEnum(  )
		{
			// Original JassCode
			if(  ! RectContainsUnit(isUnitGroupInRectRect, GetEnumUnit())  )
			{
				isUnitGroupInRectResult = false;
			}
		}

		//===========================================================================
		// Returns true if every unit of the group is within the given rect.
		//
		public static bool IsUnitGroupInRectBJ( BJGroup g , BJRect r )
		{
			// Original JassCode
			isUnitGroupInRectResult = true;
			isUnitGroupInRectRect = r;
			ForGroup(g,  IsUnitGroupInRectBJEnum);
			return isUnitGroupInRectResult;
		}

		//===========================================================================
		public static bool IsUnitHiddenBJ( BJUnit whichUnit )
		{
			// Original JassCode
			return IsUnitHidden(whichUnit);
		}

		//===========================================================================
		public static void ShowUnitHide( BJUnit whichUnit )
		{
			// Original JassCode
			ShowUnit(whichUnit, false);
		}

		//===========================================================================
		public static void ShowUnitShow( BJUnit whichUnit )
		{
			// Original JassCode
			// Prevent dead heroes from being unhidden.
			if(  (IsUnitType(whichUnit, UNIT_TYPE_HERO) && IsUnitDeadBJ(whichUnit))  )
			{
				return;
			}
			ShowUnit(whichUnit, true);
		}

		//===========================================================================
		public static bool IssueHauntOrderAtLocBJFilter(  )
		{
			// Original JassCode
			return GetUnitTypeId(GetFilterUnit()) == UnitId( "ngol" );
		}

		//===========================================================================
		public static bool IssueHauntOrderAtLocBJ( BJUnit whichPeon , BJLocation loc )
		{
			// Original JassCode
			BJGroup g = null;
			BJUnit goldMine = null;
			// Search for a gold mine within a 1-cell radius of the specified location.
			g = CreateGroup();
			GroupEnumUnitsInRangeOfLoc(g, loc, 2*CELLWIDTH, filterIssueHauntOrderAtLocBJ);
			goldMine = FirstOfGroup(g);
			DestroyGroup(g);
			// If no mine was found, abort the request.
			if(  (goldMine == null)  )
			{
				return false;
			}
			// Issue the Haunt Gold Mine order.
			return IssueTargetOrderById(whichPeon, UnitId( "ugol" ), goldMine);
		}

		//===========================================================================
		public static bool IssueBuildOrderByIdLocBJ( BJUnit whichPeon , int unitId , BJLocation loc )
		{
			// Original JassCode
			if(  (unitId == UnitId( "ugol" ))  )
			{
				return IssueHauntOrderAtLocBJ(whichPeon, loc);
			}
			else
			{
				return IssueBuildOrderById(whichPeon, unitId, GetLocationX(loc), GetLocationY(loc));
			}
		}

		//===========================================================================
		public static bool IssueTrainOrderByIdBJ( BJUnit whichUnit , int unitId )
		{
			// Original JassCode
			return IssueImmediateOrderById(whichUnit, unitId);
		}

		//===========================================================================
		public static bool GroupTrainOrderByIdBJ( BJGroup g , int unitId )
		{
			// Original JassCode
			return GroupImmediateOrderById(g, unitId);
		}

		//===========================================================================
		public static bool IssueUpgradeOrderByIdBJ( BJUnit whichUnit , int techId )
		{
			// Original JassCode
			return IssueImmediateOrderById(whichUnit, techId);
		}

		//===========================================================================
		public static BJUnit GetAttackedUnitBJ(  )
		{
			// Original JassCode
			return GetTriggerUnit();
		}

		//===========================================================================
		public static void SetUnitFlyHeightBJ( BJUnit whichUnit , double newHeight , double rate )
		{
			// Original JassCode
			SetUnitFlyHeight(whichUnit, newHeight, rate);
		}

		//===========================================================================
		public static void SetUnitTurnSpeedBJ( BJUnit whichUnit , double turnSpeed )
		{
			// Original JassCode
			SetUnitTurnSpeed(whichUnit, turnSpeed);
		}

		//===========================================================================
		public static void SetUnitPropWindowBJ( BJUnit whichUnit , double propWindow )
		{
			// Original JassCode
			double angle = propWindow;
			if(  (angle <= 0)  )
			{
				angle = 1;
			}
			else if(  (angle >= 360)  )
			{
				angle = 359;
			}
			angle = angle * DEGTORAD;
			SetUnitPropWindow(whichUnit, angle);
		}

		//===========================================================================
		public static double GetUnitPropWindowBJ( BJUnit whichUnit )
		{
			// Original JassCode
			return GetUnitPropWindow(whichUnit) * RADTODEG;
		}

		//===========================================================================
		public static double GetUnitDefaultPropWindowBJ( BJUnit whichUnit )
		{
			// Original JassCode
			return GetUnitDefaultPropWindow(whichUnit);
		}

		//===========================================================================
		public static void SetUnitBlendTimeBJ( BJUnit whichUnit , double blendTime )
		{
			// Original JassCode
			SetUnitBlendTime(whichUnit, blendTime);
		}

		//===========================================================================
		public static void SetUnitAcquireRangeBJ( BJUnit whichUnit , double acquireRange )
		{
			// Original JassCode
			SetUnitAcquireRange(whichUnit, acquireRange);
		}

		//===========================================================================
		public static void UnitSetCanSleepBJ( BJUnit whichUnit , bool canSleep )
		{
			// Original JassCode
			UnitAddSleep(whichUnit, canSleep);
		}

		//===========================================================================
		public static bool UnitCanSleepBJ( BJUnit whichUnit )
		{
			// Original JassCode
			return UnitCanSleep(whichUnit);
		}

		//===========================================================================
		public static void UnitWakeUpBJ( BJUnit whichUnit )
		{
			// Original JassCode
			UnitWakeUp(whichUnit);
		}

		//===========================================================================
		public static bool UnitIsSleepingBJ( BJUnit whichUnit )
		{
			// Original JassCode
			return UnitIsSleeping(whichUnit);
		}

		//===========================================================================
		public static void WakePlayerUnitsEnum(  )
		{
			// Original JassCode
			UnitWakeUp(GetEnumUnit());
		}

		//===========================================================================
		public static void WakePlayerUnits( BJPlayer whichPlayer )
		{
			// Original JassCode
			BJGroup g = CreateGroup();
			GroupEnumUnitsOfPlayer(g, whichPlayer, null);
			ForGroup(g,  WakePlayerUnitsEnum);
			DestroyGroup(g);
		}

		//===========================================================================
		public static void EnableCreepSleepBJ( bool enable )
		{
			// Original JassCode
			SetPlayerState(Player(PLAYER_NEUTRAL_AGGRESSIVE), PLAYER_STATE_NO_CREEP_SLEEP, IntegerTertiaryOp(enable, 0, 1));
			// If we're disabling, attempt to wake any already-sleeping creeps.
			if(  (! enable)  )
			{
				WakePlayerUnits(Player(PLAYER_NEUTRAL_AGGRESSIVE));
			}
		}

		//===========================================================================
		public static bool UnitGenerateAlarms( BJUnit whichUnit , bool generate )
		{
			// Original JassCode
			return UnitIgnoreAlarm(whichUnit, ! generate);
		}

		//===========================================================================
		public static bool DoesUnitGenerateAlarms( BJUnit whichUnit )
		{
			// Original JassCode
			return ! UnitIgnoreAlarmToggled(whichUnit);
		}

		//===========================================================================
		public static void PauseAllUnitsBJEnum(  )
		{
			// Original JassCode
			PauseUnit( GetEnumUnit(), pauseAllUnitsFlag );
		}

		//===========================================================================
		// Pause all units 
		public static void PauseAllUnitsBJ( bool pause )
		{
			// Original JassCode
			int index;
			BJPlayer indexPlayer;
			BJGroup g;
			pauseAllUnitsFlag = pause;
			g = CreateGroup();
			index = 0;
			while( true )
			{
				indexPlayer = Player( index );
				// If this is a computer slot, pause/resume the AI.
				if(  (GetPlayerController( indexPlayer ) == MAP_CONTROL_COMPUTER)  )
				{
					PauseCompAI( indexPlayer, pause );
				}
				// Enumerate and unpause every unit owned by the player.
				GroupEnumUnitsOfPlayer( g, indexPlayer, null );
				ForGroup( g,  PauseAllUnitsBJEnum );
				GroupClear( g );
				index = index + 1;
				if(  index == MAX_PLAYER_SLOTS )
					break;
			}
			DestroyGroup(g);
		}

		//===========================================================================
		public static void PauseUnitBJ( bool pause , BJUnit whichUnit )
		{
			// Original JassCode
			PauseUnit(whichUnit, pause);
		}

		//===========================================================================
		public static bool IsUnitPausedBJ( BJUnit whichUnit )
		{
			// Original JassCode
			return IsUnitPaused(whichUnit);
		}

		//===========================================================================
		public static void UnitPauseTimedLifeBJ( bool flag , BJUnit whichUnit )
		{
			// Original JassCode
			UnitPauseTimedLife(whichUnit, flag);
		}

		//===========================================================================
		public static void UnitApplyTimedLifeBJ( double duration , int buffId , BJUnit whichUnit )
		{
			// Original JassCode
			UnitApplyTimedLife(whichUnit, buffId, duration);
		}

		//===========================================================================
		public static void UnitShareVisionBJ( bool share , BJUnit whichUnit , BJPlayer whichPlayer )
		{
			// Original JassCode
			UnitShareVision(whichUnit, whichPlayer, share);
		}

		//===========================================================================
		public static void UnitRemoveBuffsBJ( int buffType , BJUnit whichUnit )
		{
			// Original JassCode
			if(  (buffType == REMOVEBUFFS_POSITIVE)  )
			{
				UnitRemoveBuffs(whichUnit, true, false);
			}
			else if(  (buffType == REMOVEBUFFS_NEGATIVE)  )
			{
				UnitRemoveBuffs(whichUnit, false, true);
			}
			else if(  (buffType == REMOVEBUFFS_ALL)  )
			{
				UnitRemoveBuffs(whichUnit, true, true);
			}
			else if(  (buffType == REMOVEBUFFS_NONTLIFE)  )
			{
				UnitRemoveBuffsEx(whichUnit, true, true, false, false, false, true, false);
			}
			else
			{
				// Unrecognized dispel type - ignore the request.
			}
		}

		//===========================================================================
		public static void UnitRemoveBuffsExBJ( int polarity , int resist , BJUnit whichUnit , bool bTLife , bool bAura )
		{
			// Original JassCode
			bool bPos = (polarity == BUFF_POLARITY_EITHER) || (polarity == BUFF_POLARITY_POSITIVE);
			bool bNeg = (polarity == BUFF_POLARITY_EITHER) || (polarity == BUFF_POLARITY_NEGATIVE);
			bool bMagic = (resist == BUFF_RESIST_BOTH) || (resist == BUFF_RESIST_MAGIC);
			bool bPhys = (resist == BUFF_RESIST_BOTH) || (resist == BUFF_RESIST_PHYSICAL);
			UnitRemoveBuffsEx(whichUnit, bPos, bNeg, bMagic, bPhys, bTLife, bAura, false);
		}

		//===========================================================================
		public static int UnitCountBuffsExBJ( int polarity , int resist , BJUnit whichUnit , bool bTLife , bool bAura )
		{
			// Original JassCode
			bool bPos = (polarity == BUFF_POLARITY_EITHER) || (polarity == BUFF_POLARITY_POSITIVE);
			bool bNeg = (polarity == BUFF_POLARITY_EITHER) || (polarity == BUFF_POLARITY_NEGATIVE);
			bool bMagic = (resist == BUFF_RESIST_BOTH) || (resist == BUFF_RESIST_MAGIC);
			bool bPhys = (resist == BUFF_RESIST_BOTH) || (resist == BUFF_RESIST_PHYSICAL);
			return UnitCountBuffsEx(whichUnit, bPos, bNeg, bMagic, bPhys, bTLife, bAura, false);
		}

		//===========================================================================
		public static bool UnitRemoveAbilityBJ( int abilityId , BJUnit whichUnit )
		{
			// Original JassCode
			return UnitRemoveAbility(whichUnit, abilityId);
		}

		//===========================================================================
		public static bool UnitAddAbilityBJ( int abilityId , BJUnit whichUnit )
		{
			// Original JassCode
			return UnitAddAbility(whichUnit, abilityId);
		}

		//===========================================================================
		public static void SetUnitExplodedBJ( BJUnit whichUnit , bool exploded )
		{
			// Original JassCode
			SetUnitExploded(whichUnit, exploded);
		}

		//===========================================================================
		public static void ExplodeUnitBJ( BJUnit whichUnit )
		{
			// Original JassCode
			SetUnitExploded(whichUnit, true);
			KillUnit(whichUnit);
		}

		//===========================================================================
		public static BJUnit GetTransportUnitBJ(  )
		{
			// Original JassCode
			return GetTransportUnit();
		}

		//===========================================================================
		public static BJUnit GetLoadedUnitBJ(  )
		{
			// Original JassCode
			return GetLoadedUnit();
		}

		//===========================================================================
		public static bool IsUnitInTransportBJ( BJUnit whichUnit , BJUnit whichTransport )
		{
			// Original JassCode
			return IsUnitInTransport(whichUnit, whichTransport);
		}

		//===========================================================================
		public static bool IsUnitLoadedBJ( BJUnit whichUnit )
		{
			// Original JassCode
			return IsUnitLoaded(whichUnit);
		}

		//===========================================================================
		public static bool IsUnitIllusionBJ( BJUnit whichUnit )
		{
			// Original JassCode
			return IsUnitIllusion(whichUnit);
		}

		//===========================================================================
		// This attempts to replace a unit with a new unit type by creating a new
		// unit of the desired type using the old unit's location, facing, etc.
		//
		public static BJUnit ReplaceUnitBJ( BJUnit whichUnit , int newUnitId , int unitStateMethod )
		{
			// Original JassCode
			BJUnit oldUnit = whichUnit;
			BJUnit newUnit;
			bool wasHidden;
			int index;
			BJItem indexItem;
			double oldRatio;
			// If we have bogus data, don't attempt the replace.
			if(  (oldUnit == null)  )
			{
				lastReplacedUnit = oldUnit;
				return oldUnit;
			}
			// Hide the original unit.
			wasHidden = IsUnitHidden(oldUnit);
			ShowUnit(oldUnit, false);
			// Create the replacement unit.
			if(  (newUnitId == UnitId( "ugol" ))  )
			{
				newUnit = CreateBlightedGoldmine(GetOwningPlayer(oldUnit), GetUnitX(oldUnit), GetUnitY(oldUnit), GetUnitFacing(oldUnit));
			}
			else
			{
				newUnit = CreateUnit(GetOwningPlayer(oldUnit), newUnitId, GetUnitX(oldUnit), GetUnitY(oldUnit), GetUnitFacing(oldUnit));
			}
			// Set the unit's life and mana according to the requested method.
			if(  (unitStateMethod == UNIT_STATE_METHOD_RELATIVE)  )
			{
				// Set the replacement's current/max life ratio to that of the old unit.
				// If both units have mana, do the same for mana.
				if(  (GetUnitState(oldUnit, UNIT_STATE_MAX_LIFE) > 0)  )
				{
					oldRatio = GetUnitState(oldUnit, UNIT_STATE_LIFE) / GetUnitState(oldUnit, UNIT_STATE_MAX_LIFE);
					SetUnitState(newUnit, UNIT_STATE_LIFE, oldRatio * GetUnitState(newUnit, UNIT_STATE_MAX_LIFE));
				}
				if(  (GetUnitState(oldUnit, UNIT_STATE_MAX_MANA) > 0) && (GetUnitState(newUnit, UNIT_STATE_MAX_MANA) > 0)  )
				{
					oldRatio = GetUnitState(oldUnit, UNIT_STATE_MANA) / GetUnitState(oldUnit, UNIT_STATE_MAX_MANA);
					SetUnitState(newUnit, UNIT_STATE_MANA, oldRatio * GetUnitState(newUnit, UNIT_STATE_MAX_MANA));
				}
			}
			else if(  (unitStateMethod == UNIT_STATE_METHOD_ABSOLUTE)  )
			{
				// Set the replacement's current life to that of the old unit.
				// If the new unit has mana, do the same for mana.
				SetUnitState(newUnit, UNIT_STATE_LIFE, GetUnitState(oldUnit, UNIT_STATE_LIFE));
				if(  (GetUnitState(newUnit, UNIT_STATE_MAX_MANA) > 0)  )
				{
					SetUnitState(newUnit, UNIT_STATE_MANA, GetUnitState(oldUnit, UNIT_STATE_MANA));
				}
			}
			else if(  (unitStateMethod == UNIT_STATE_METHOD_DEFAULTS)  )
			{
				// The newly created unit should already have default life and mana.
			}
			else if(  (unitStateMethod == UNIT_STATE_METHOD_MAXIMUM)  )
			{
				// Use max life and mana.
				SetUnitState(newUnit, UNIT_STATE_LIFE, GetUnitState(newUnit, UNIT_STATE_MAX_LIFE));
				SetUnitState(newUnit, UNIT_STATE_MANA, GetUnitState(newUnit, UNIT_STATE_MAX_MANA));
			}
			else
			{
				// Unrecognized unit state method - ignore the request.
			}
			// Mirror properties of the old unit onto the new unit.
			//call PauseUnit(newUnit, IsUnitPaused(oldUnit))
			SetResourceAmount(newUnit, GetResourceAmount(oldUnit));
			// If both the old and new units are heroes, handle their hero info.
			if(  (IsUnitType(oldUnit, UNIT_TYPE_HERO) && IsUnitType(newUnit, UNIT_TYPE_HERO))  )
			{
				SetHeroXP(newUnit, GetHeroXP(oldUnit), false);
				index = 0;
				while( true )
				{
					indexItem = UnitItemInSlot(oldUnit, index);
					if(  (indexItem != null)  )
					{
						UnitRemoveItem(oldUnit, indexItem);
						UnitAddItem(newUnit, indexItem);
					}
					index = index + 1;
					if(  index >= MAX_INVENTORY )
						break;
				}
			}
			// Remove or kill the original unit.  It is sometimes unsafe to remove
			// hidden units, so kill the original unit if it was previously hidden.
			if(  wasHidden  )
			{
				KillUnit(oldUnit);
				RemoveUnit(oldUnit);
			}
			else
			{
				RemoveUnit(oldUnit);
			}
			lastReplacedUnit = newUnit;
			return newUnit;
		}

		//===========================================================================
		public static BJUnit GetLastReplacedUnitBJ(  )
		{
			// Original JassCode
			return lastReplacedUnit;
		}

		//===========================================================================
		public static void SetUnitPositionLocFacingBJ( BJUnit whichUnit , BJLocation loc , double facing )
		{
			// Original JassCode
			SetUnitPositionLoc(whichUnit, loc);
			SetUnitFacing(whichUnit, facing);
		}

		//===========================================================================
		public static void SetUnitPositionLocFacingLocBJ( BJUnit whichUnit , BJLocation loc , BJLocation lookAt )
		{
			// Original JassCode
			SetUnitPositionLoc(whichUnit, loc);
			SetUnitFacing(whichUnit, AngleBetweenPoints(loc, lookAt));
		}

		//===========================================================================
		public static void AddItemToStockBJ( int itemId , BJUnit whichUnit , int currentStock , int stockMax )
		{
			// Original JassCode
			AddItemToStock(whichUnit, itemId, currentStock, stockMax);
		}

		//===========================================================================
		public static void AddUnitToStockBJ( int unitId , BJUnit whichUnit , int currentStock , int stockMax )
		{
			// Original JassCode
			AddUnitToStock(whichUnit, unitId, currentStock, stockMax);
		}

		//===========================================================================
		public static void RemoveItemFromStockBJ( int itemId , BJUnit whichUnit )
		{
			// Original JassCode
			RemoveItemFromStock(whichUnit, itemId);
		}

		//===========================================================================
		public static void RemoveUnitFromStockBJ( int unitId , BJUnit whichUnit )
		{
			// Original JassCode
			RemoveUnitFromStock(whichUnit, unitId);
		}

		//===========================================================================
		public static void SetUnitUseFoodBJ( bool enable , BJUnit whichUnit )
		{
			// Original JassCode
			SetUnitUseFood(whichUnit, enable);
		}

		//***************************************************************************
		//*
		//*  Destructable Utility Functions
		//*
		//***************************************************************************
		//===========================================================================
		public static BJDestructAble CreateDestructableLoc( int objectid , BJLocation loc , double facing , double scale , int variation )
		{
			// Original JassCode
			lastCreatedDestructable = CreateDestructable(objectid, GetLocationX(loc), GetLocationY(loc), facing, scale, variation);
			return lastCreatedDestructable;
		}

		//===========================================================================
		public static BJDestructAble CreateDeadDestructableLocBJ( int objectid , BJLocation loc , double facing , double scale , int variation )
		{
			// Original JassCode
			lastCreatedDestructable = CreateDeadDestructable(objectid, GetLocationX(loc), GetLocationY(loc), facing, scale, variation);
			return lastCreatedDestructable;
		}

		//===========================================================================
		public static BJDestructAble GetLastCreatedDestructable(  )
		{
			// Original JassCode
			return lastCreatedDestructable;
		}

		//===========================================================================
		public static void ShowDestructableBJ( bool flag , BJDestructAble d )
		{
			// Original JassCode
			ShowDestructable(d, flag);
		}

		//===========================================================================
		public static void SetDestructableInvulnerableBJ( BJDestructAble d , bool flag )
		{
			// Original JassCode
			SetDestructableInvulnerable(d, flag);
		}

		//===========================================================================
		public static bool IsDestructableInvulnerableBJ( BJDestructAble d )
		{
			// Original JassCode
			return IsDestructableInvulnerable(d);
		}

		//===========================================================================
		public static BJLocation GetDestructableLoc( BJDestructAble whichDestructable )
		{
			// Original JassCode
			return Location(GetDestructableX(whichDestructable), GetDestructableY(whichDestructable));
		}

		//===========================================================================
		public static void EnumDestructablesInRectAll( BJRect r , BJCode actionFunc )
		{
			// Original JassCode
			EnumDestructablesInRect(r, null, actionFunc);
		}

		//===========================================================================
		public static bool EnumDestructablesInCircleBJFilter(  )
		{
			// Original JassCode
			BJLocation destLoc = GetDestructableLoc(GetFilterDestructable());
			bool result;
			result = DistanceBetweenPoints(destLoc, enumDestructableCenter) <= enumDestructableRadius;
			RemoveLocation(destLoc);
			return result;
		}

		//===========================================================================
		public static bool IsDestructableDeadBJ( BJDestructAble d )
		{
			// Original JassCode
			return GetDestructableLife(d) <= 0;
		}

		//===========================================================================
		public static bool IsDestructableAliveBJ( BJDestructAble d )
		{
			// Original JassCode
			return ! IsDestructableDeadBJ(d);
		}

		//===========================================================================
		// See GroupPickRandomUnitEnum for the details of this algorithm.
		//
		public static void RandomDestructableInRectBJEnum(  )
		{
			// Original JassCode
			destRandomConsidered = destRandomConsidered + 1;
			if(  (GetRandomInt(1,destRandomConsidered) == 1)  )
			{
				destRandomCurrentPick = GetEnumDestructable();
			}
		}

		//===========================================================================
		// Picks a random destructable from within a rect, matching a condition
		//
		public static BJDestructAble RandomDestructableInRectBJ( BJRect r , BJBoolExpr filter )
		{
			// Original JassCode
			destRandomConsidered = 0;
			destRandomCurrentPick = null;
			EnumDestructablesInRect(r, filter,  RandomDestructableInRectBJEnum);
			DestroyBoolExpr(filter);
			return destRandomCurrentPick;
		}

		//===========================================================================
		// Picks a random destructable from within a rect
		//
		public static BJDestructAble RandomDestructableInRectSimpleBJ( BJRect r )
		{
			// Original JassCode
			return RandomDestructableInRectBJ(r, null);
		}

		//===========================================================================
		// Enumerates within a rect, with a filter to narrow the enumeration down
		// objects within a circular area.
		//
		public static void EnumDestructablesInCircleBJ( double radius , BJLocation loc , BJCode actionFunc )
		{
			// Original JassCode
			BJRect r;
			if(  (radius >= 0)  )
			{
				enumDestructableCenter = loc;
				enumDestructableRadius = radius;
				r = GetRectFromCircleBJ(loc, radius);
				EnumDestructablesInRect(r, filterEnumDestructablesInCircleBJ, actionFunc);
				RemoveRect(r);
			}
		}

		//===========================================================================
		public static void SetDestructableLifePercentBJ( BJDestructAble d , double percent )
		{
			// Original JassCode
			SetDestructableLife(d, GetDestructableMaxLife(d) * percent * 0.01);
		}

		//===========================================================================
		public static void SetDestructableMaxLifeBJ( BJDestructAble d , double max )
		{
			// Original JassCode
			SetDestructableMaxLife(d, max);
		}

		//===========================================================================
		public static void ModifyGateBJ( int gateOperation , BJDestructAble d )
		{
			// Original JassCode
			if(  (gateOperation == GATEOPERATION_CLOSE)  )
			{
				if(  (GetDestructableLife(d) <= 0)  )
				{
					DestructableRestoreLife(d, GetDestructableMaxLife(d), true);
				}
				SetDestructableAnimation(d, "stand");
			}
			else if(  (gateOperation == GATEOPERATION_OPEN)  )
			{
				if(  (GetDestructableLife(d) > 0)  )
				{
					KillDestructable(d);
				}
				SetDestructableAnimation(d, "death alternate");
			}
			else if(  (gateOperation == GATEOPERATION_DESTROY)  )
			{
				if(  (GetDestructableLife(d) > 0)  )
				{
					KillDestructable(d);
				}
				SetDestructableAnimation(d, "death");
			}
			else
			{
				// Unrecognized gate state - ignore the request.
			}
		}

		//===========================================================================
		// Determine the elevator's height from its occlusion height.
		//
		public static int GetElevatorHeight( BJDestructAble d )
		{
			// Original JassCode
			int height;
			height = 1 + R2I(GetDestructableOccluderHeight(d) / CLIFFHEIGHT);
			if(  (height < 1) || (height > 3)  )
			{
				height = 1;
			}
			return height;
		}

		//===========================================================================
		// To properly animate an elevator, we must know not only what height we
		// want to change to, but also what height we are currently at.  This code
		// determines the elevator's current height from its occlusion height.
		// Arbitrarily changing an elevator's occlusion height is thus inadvisable.
		//
		public static void ChangeElevatorHeight( BJDestructAble d , int newHeight )
		{
			// Original JassCode
			int oldHeight;
			// Cap the new height within the supported range.
			newHeight = IMaxBJ(1, newHeight);
			newHeight = IMinBJ(3, newHeight);
			// Find out what height the elevator is already at.
			oldHeight = GetElevatorHeight(d);
			// Set the elevator's occlusion height.
			SetDestructableOccluderHeight(d, CLIFFHEIGHT*(newHeight-1));
			if(  (newHeight == 1)  )
			{
				if(  (oldHeight == 2)  )
				{
					SetDestructableAnimation(d, "birth");
					QueueDestructableAnimation(d, "stand");
				}
				else if(  (oldHeight == 3)  )
				{
					SetDestructableAnimation(d, "birth third");
					QueueDestructableAnimation(d, "stand");
				}
				else
				{
					// Unrecognized old height - snap to new height.
					SetDestructableAnimation(d, "stand");
				}
			}
			else if(  (newHeight == 2)  )
			{
				if(  (oldHeight == 1)  )
				{
					SetDestructableAnimation(d, "death");
					QueueDestructableAnimation(d, "stand second");
				}
				else if(  (oldHeight == 3)  )
				{
					SetDestructableAnimation(d, "birth second");
					QueueDestructableAnimation(d, "stand second");
				}
				else
				{
					// Unrecognized old height - snap to new height.
					SetDestructableAnimation(d, "stand second");
				}
			}
			else if(  (newHeight == 3)  )
			{
				if(  (oldHeight == 1)  )
				{
					SetDestructableAnimation(d, "death third");
					QueueDestructableAnimation(d, "stand third");
				}
				else if(  (oldHeight == 2)  )
				{
					SetDestructableAnimation(d, "death second");
					QueueDestructableAnimation(d, "stand third");
				}
				else
				{
					// Unrecognized old height - snap to new height.
					SetDestructableAnimation(d, "stand third");
				}
			}
			else
			{
				// Unrecognized new height - ignore the request.
			}
		}

		//===========================================================================
		// Grab the unit and throw his own coords in his face, forcing him to push
		// and shove until he finds a spot where noone will bother him.
		//
		public static void NudgeUnitsInRectEnum(  )
		{
			// Original JassCode
			BJUnit nudgee = GetEnumUnit();
			SetUnitPosition(nudgee, GetUnitX(nudgee), GetUnitY(nudgee));
		}

		//===========================================================================
		public static void NudgeItemsInRectEnum(  )
		{
			// Original JassCode
			BJItem nudgee = GetEnumItem();
			SetItemPosition(nudgee, GetItemX(nudgee), GetItemY(nudgee));
		}

		//===========================================================================
		// Nudge the items and units within a given rect ever so gently, so as to
		// encourage them to find locations where they can peacefully coexist with
		// pathing restrictions and live happy, fruitful lives.
		//
		public static void NudgeObjectsInRect( BJRect nudgeArea )
		{
			// Original JassCode
			BJGroup g;
			g = CreateGroup();
			GroupEnumUnitsInRect(g, nudgeArea, null);
			ForGroup(g,  NudgeUnitsInRectEnum);
			DestroyGroup(g);
			EnumItemsInRect(nudgeArea, null,  NudgeItemsInRectEnum);
		}

		//===========================================================================
		public static void NearbyElevatorExistsEnum(  )
		{
			// Original JassCode
			BJDestructAble d = GetEnumDestructable();
			int dType = GetDestructableTypeId(d);
			if(  (dType == ELEVATOR_CODE01) || (dType == ELEVATOR_CODE02)  )
			{
				elevatorNeighbor = d;
			}
		}

		//===========================================================================
		public static bool NearbyElevatorExists( double x , double y )
		{
			// Original JassCode
			double findThreshold = 32;
			BJRect r;
			// If another elevator is overlapping this one, ignore the wall.
			r = Rect(x - findThreshold, y - findThreshold, x + findThreshold, y + findThreshold);
			elevatorNeighbor = null;
			EnumDestructablesInRect(r, null,  NearbyElevatorExistsEnum);
			RemoveRect(r);
			return elevatorNeighbor != null;
		}

		//===========================================================================
		public static void FindElevatorWallBlockerEnum(  )
		{
			// Original JassCode
			elevatorWallBlocker = GetEnumDestructable();
		}

		//===========================================================================
		// This toggles pathing on or off for one wall of an elevator by killing
		// or reviving a pathing blocker at the appropriate location (and creating
		// the pathing blocker in the first place, if it does not yet exist).
		//
		public static void ChangeElevatorWallBlocker( double x , double y , double facing , bool open )
		{
			// Original JassCode
			BJDestructAble blocker = null;
			double findThreshold = 32;
			double nudgeLength = 4.25 * CELLWIDTH;
			double nudgeWidth = 1.25 * CELLWIDTH;
			BJRect r;
			// Search for the pathing blocker within the general area.
			r = Rect(x - findThreshold, y - findThreshold, x + findThreshold, y + findThreshold);
			elevatorWallBlocker = null;
			EnumDestructablesInRect(r, null,  FindElevatorWallBlockerEnum);
			RemoveRect(r);
			blocker = elevatorWallBlocker;
			// Ensure that the blocker exists.
			if(  (blocker == null)  )
			{
				blocker = CreateDeadDestructable(ELEVATOR_BLOCKER_CODE, x, y, facing, 1, 0);
			}
			else if(  (GetDestructableTypeId(blocker) != ELEVATOR_BLOCKER_CODE)  )
			{
				// If a different destructible exists in the blocker's spot, ignore
				// the request.  (Two destructibles cannot occupy the same location
				// on the map, so we cannot create an elevator blocker here.)
				return;
			}
			if(  (open)  )
			{
				// Ensure that the blocker is dead.
				if(  (GetDestructableLife(blocker) > 0)  )
				{
					KillDestructable(blocker);
				}
			}
			else
			{
				// Ensure that the blocker is alive.
				if(  (GetDestructableLife(blocker) <= 0)  )
				{
					DestructableRestoreLife(blocker, GetDestructableMaxLife(blocker), false);
				}
				// Nudge any objects standing in the blocker's way.
				if(  (facing == 0)  )
				{
					r = Rect(x - nudgeWidth/2, y - nudgeLength/2, x + nudgeWidth/2, y + nudgeLength/2);
					NudgeObjectsInRect(r);
					RemoveRect(r);
				}
				else if(  (facing == 90)  )
				{
					r = Rect(x - nudgeLength/2, y - nudgeWidth/2, x + nudgeLength/2, y + nudgeWidth/2);
					NudgeObjectsInRect(r);
					RemoveRect(r);
				}
				else
				{
					// Unrecognized blocker angle - don't nudge anything.
				}
			}
		}

		//===========================================================================
		public static void ChangeElevatorWalls( bool open , int walls , BJDestructAble d )
		{
			// Original JassCode
			double x = GetDestructableX(d);
			double y = GetDestructableY(d);
			double distToBlocker = 192;
			double distToNeighbor = 256;
			if(  (walls == ELEVATOR_WALL_TYPE_ALL) || (walls == ELEVATOR_WALL_TYPE_EAST)  )
			{
				if(  (! NearbyElevatorExists(x + distToNeighbor, y))  )
				{
					ChangeElevatorWallBlocker(x + distToBlocker, y, 0, open);
				}
			}
			if(  (walls == ELEVATOR_WALL_TYPE_ALL) || (walls == ELEVATOR_WALL_TYPE_NORTH)  )
			{
				if(  (! NearbyElevatorExists(x, y + distToNeighbor))  )
				{
					ChangeElevatorWallBlocker(x, y + distToBlocker, 90, open);
				}
			}
			if(  (walls == ELEVATOR_WALL_TYPE_ALL) || (walls == ELEVATOR_WALL_TYPE_SOUTH)  )
			{
				if(  (! NearbyElevatorExists(x, y - distToNeighbor))  )
				{
					ChangeElevatorWallBlocker(x, y - distToBlocker, 90, open);
				}
			}
			if(  (walls == ELEVATOR_WALL_TYPE_ALL) || (walls == ELEVATOR_WALL_TYPE_WEST)  )
			{
				if(  (! NearbyElevatorExists(x - distToNeighbor, y))  )
				{
					ChangeElevatorWallBlocker(x - distToBlocker, y, 0, open);
				}
			}
		}

		//***************************************************************************
		//*
		//*  Neutral Building Utility Functions
		//*
		//***************************************************************************
		//===========================================================================
		public static void WaygateActivateBJ( bool activate , BJUnit waygate )
		{
			// Original JassCode
			WaygateActivate(waygate, activate);
		}

		//===========================================================================
		public static bool WaygateIsActiveBJ( BJUnit waygate )
		{
			// Original JassCode
			return WaygateIsActive(waygate);
		}

		//===========================================================================
		public static void WaygateSetDestinationLocBJ( BJUnit waygate , BJLocation loc )
		{
			// Original JassCode
			WaygateSetDestination(waygate, GetLocationX(loc), GetLocationY(loc));
		}

		//===========================================================================
		public static BJLocation WaygateGetDestinationLocBJ( BJUnit waygate )
		{
			// Original JassCode
			return Location(WaygateGetDestinationX(waygate), WaygateGetDestinationY(waygate));
		}

		//===========================================================================
		public static void UnitSetUsesAltIconBJ( bool flag , BJUnit whichUnit )
		{
			// Original JassCode
			UnitSetUsesAltIcon(whichUnit, flag);
		}

		//***************************************************************************
		//*
		//*  UI Utility Functions
		//*
		//***************************************************************************
		//===========================================================================
		public static void ForceUIKeyBJ( BJPlayer whichPlayer , string key )
		{
			// Original JassCode
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				ForceUIKey(key);
			}
		}

		//===========================================================================
		public static void ForceUICancelBJ( BJPlayer whichPlayer )
		{
			// Original JassCode
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				ForceUICancel();
			}
		}

		//***************************************************************************
		//*
		//*  Group and Force Utility Functions
		//*
		//***************************************************************************
		//===========================================================================
		public static void ForGroupBJ( BJGroup whichGroup , BJCode callback )
		{
			// Original JassCode
			// If the user wants the group destroyed, remember that fact and clear
			// the flag, in case it is used again in the callback.
			bool wantDestroy = wantDestroyGroup;
			wantDestroyGroup = false;
			ForGroup(whichGroup, callback);
			// If the user wants the group destroyed, do so now.
			if(  (wantDestroy)  )
			{
				DestroyGroup(whichGroup);
			}
		}

		//===========================================================================
		public static void GroupAddUnitSimple( BJUnit whichUnit , BJGroup whichGroup )
		{
			// Original JassCode
			GroupAddUnit(whichGroup, whichUnit);
		}

		//===========================================================================
		public static void GroupRemoveUnitSimple( BJUnit whichUnit , BJGroup whichGroup )
		{
			// Original JassCode
			GroupRemoveUnit(whichGroup, whichUnit);
		}

		//===========================================================================
		public static void GroupAddGroupEnum(  )
		{
			// Original JassCode
			GroupAddUnit(groupAddGroupDest, GetEnumUnit());
		}

		//===========================================================================
		public static void GroupAddGroup( BJGroup sourceGroup , BJGroup destGroup )
		{
			// Original JassCode
			// If the user wants the group destroyed, remember that fact and clear
			// the flag, in case it is used again in the callback.
			bool wantDestroy = wantDestroyGroup;
			wantDestroyGroup = false;
			groupAddGroupDest = destGroup;
			ForGroup(sourceGroup,  GroupAddGroupEnum);
			// If the user wants the group destroyed, do so now.
			if(  (wantDestroy)  )
			{
				DestroyGroup(sourceGroup);
			}
		}

		//===========================================================================
		public static void GroupRemoveGroupEnum(  )
		{
			// Original JassCode
			GroupRemoveUnit(groupRemoveGroupDest, GetEnumUnit());
		}

		//===========================================================================
		public static void GroupRemoveGroup( BJGroup sourceGroup , BJGroup destGroup )
		{
			// Original JassCode
			// If the user wants the group destroyed, remember that fact and clear
			// the flag, in case it is used again in the callback.
			bool wantDestroy = wantDestroyGroup;
			wantDestroyGroup = false;
			groupRemoveGroupDest = destGroup;
			ForGroup(sourceGroup,  GroupRemoveGroupEnum);
			// If the user wants the group destroyed, do so now.
			if(  (wantDestroy)  )
			{
				DestroyGroup(sourceGroup);
			}
		}

		//===========================================================================
		public static void ForceAddPlayerSimple( BJPlayer whichPlayer , BJForce whichForce )
		{
			// Original JassCode
			ForceAddPlayer(whichForce, whichPlayer);
		}

		//===========================================================================
		public static void ForceRemovePlayerSimple( BJPlayer whichPlayer , BJForce whichForce )
		{
			// Original JassCode
			ForceRemovePlayer(whichForce, whichPlayer);
		}

		//===========================================================================
		// Consider each unit, one at a time, keeping a "current pick".   Once all units
		// are considered, this "current pick" will be the resulting random unit.
		//
		// The chance of picking a given unit over the "current pick" is 1/N, where N is
		// the number of units considered thusfar (including the current consideration).
		//
		public static void GroupPickRandomUnitEnum(  )
		{
			// Original JassCode
			groupRandomConsidered = groupRandomConsidered + 1;
			if(  (GetRandomInt(1,groupRandomConsidered) == 1)  )
			{
				groupRandomCurrentPick = GetEnumUnit();
			}
		}

		//===========================================================================
		// Picks a random unit from a group.
		//
		public static BJUnit GroupPickRandomUnit( BJGroup whichGroup )
		{
			// Original JassCode
			// If the user wants the group destroyed, remember that fact and clear
			// the flag, in case it is used again in the callback.
			bool wantDestroy = wantDestroyGroup;
			wantDestroyGroup = false;
			groupRandomConsidered = 0;
			groupRandomCurrentPick = null;
			ForGroup(whichGroup,  GroupPickRandomUnitEnum);
			// If the user wants the group destroyed, do so now.
			if(  (wantDestroy)  )
			{
				DestroyGroup(whichGroup);
			}
			return groupRandomCurrentPick;
		}

		//===========================================================================
		// See GroupPickRandomUnitEnum for the details of this algorithm.
		//
		public static void ForcePickRandomPlayerEnum(  )
		{
			// Original JassCode
			forceRandomConsidered = forceRandomConsidered + 1;
			if(  (GetRandomInt(1,forceRandomConsidered) == 1)  )
			{
				forceRandomCurrentPick = GetEnumPlayer();
			}
		}

		//===========================================================================
		// Picks a random player from a force.
		//
		public static BJPlayer ForcePickRandomPlayer( BJForce whichForce )
		{
			// Original JassCode
			forceRandomConsidered = 0;
			forceRandomCurrentPick = null;
			ForForce(whichForce,  ForcePickRandomPlayerEnum);
			return forceRandomCurrentPick;
		}

		//===========================================================================
		public static void EnumUnitsSelected( BJPlayer whichPlayer , BJBoolExpr enumFilter , BJCode enumAction )
		{
			// Original JassCode
			BJGroup g = CreateGroup();
			SyncSelections();
			GroupEnumUnitsSelected(g, whichPlayer, enumFilter);
			DestroyBoolExpr(enumFilter);
			ForGroup(g, enumAction);
			DestroyGroup(g);
		}

		//===========================================================================
		public static BJGroup GetUnitsInRectMatching( BJRect r , BJBoolExpr filter )
		{
			// Original JassCode
			BJGroup g = CreateGroup();
			GroupEnumUnitsInRect(g, r, filter);
			DestroyBoolExpr(filter);
			return g;
		}

		//===========================================================================
		public static BJGroup GetUnitsInRectAll( BJRect r )
		{
			// Original JassCode
			return GetUnitsInRectMatching(r, null);
		}

		//===========================================================================
		public static bool GetUnitsInRectOfPlayerFilter(  )
		{
			// Original JassCode
			return GetOwningPlayer(GetFilterUnit()) == groupEnumOwningPlayer;
		}

		//===========================================================================
		public static BJGroup GetUnitsInRectOfPlayer( BJRect r , BJPlayer whichPlayer )
		{
			// Original JassCode
			BJGroup g = CreateGroup();
			groupEnumOwningPlayer = whichPlayer;
			GroupEnumUnitsInRect(g, r, filterGetUnitsInRectOfPlayer);
			return g;
		}

		//===========================================================================
		public static BJGroup GetUnitsInRangeOfLocMatching( double radius , BJLocation whichLocation , BJBoolExpr filter )
		{
			// Original JassCode
			BJGroup g = CreateGroup();
			GroupEnumUnitsInRangeOfLoc(g, whichLocation, radius, filter);
			DestroyBoolExpr(filter);
			return g;
		}

		//===========================================================================
		public static BJGroup GetUnitsInRangeOfLocAll( double radius , BJLocation whichLocation )
		{
			// Original JassCode
			return GetUnitsInRangeOfLocMatching(radius, whichLocation, null);
		}

		//===========================================================================
		public static bool GetUnitsOfTypeIdAllFilter(  )
		{
			// Original JassCode
			return GetUnitTypeId(GetFilterUnit()) == groupEnumTypeId;
		}

		//===========================================================================
		public static BJGroup GetUnitsOfTypeIdAll( int unitid )
		{
			// Original JassCode
			BJGroup result = CreateGroup();
			BJGroup g = CreateGroup();
			int index;
			index = 0;
			while( true )
			{
				groupEnumTypeId = unitid;
				GroupClear(g);
				GroupEnumUnitsOfPlayer(g, Player(index), filterGetUnitsOfTypeIdAll);
				GroupAddGroup(g, result);
				index = index + 1;
				if(  index == MAX_PLAYER_SLOTS )
					break;
			}
			DestroyGroup(g);
			return result;
		}

		//===========================================================================
		public static BJGroup GetUnitsOfPlayerMatching( BJPlayer whichPlayer , BJBoolExpr filter )
		{
			// Original JassCode
			BJGroup g = CreateGroup();
			GroupEnumUnitsOfPlayer(g, whichPlayer, filter);
			DestroyBoolExpr(filter);
			return g;
		}

		//===========================================================================
		public static BJGroup GetUnitsOfPlayerAll( BJPlayer whichPlayer )
		{
			// Original JassCode
			return GetUnitsOfPlayerMatching(whichPlayer, null);
		}

		//===========================================================================
		public static bool GetUnitsOfPlayerAndTypeIdFilter(  )
		{
			// Original JassCode
			return GetUnitTypeId(GetFilterUnit()) == groupEnumTypeId;
		}

		//===========================================================================
		public static BJGroup GetUnitsOfPlayerAndTypeId( BJPlayer whichPlayer , int unitid )
		{
			// Original JassCode
			BJGroup g = CreateGroup();
			groupEnumTypeId = unitid;
			GroupEnumUnitsOfPlayer(g, whichPlayer, filterGetUnitsOfPlayerAndTypeId);
			return g;
		}

		//===========================================================================
		public static BJGroup GetUnitsSelectedAll( BJPlayer whichPlayer )
		{
			// Original JassCode
			BJGroup g = CreateGroup();
			SyncSelections();
			GroupEnumUnitsSelected(g, whichPlayer, null);
			return g;
		}

		//===========================================================================
		public static BJForce GetForceOfPlayer( BJPlayer whichPlayer )
		{
			// Original JassCode
			BJForce f = CreateForce();
			ForceAddPlayer(f, whichPlayer);
			return f;
		}

		//===========================================================================
		public static BJForce GetPlayersAll(  )
		{
			// Original JassCode
			return FORCE_ALL_PLAYERS;
		}

		//===========================================================================
		public static BJForce GetPlayersByMapControl( BJMapControl whichControl )
		{
			// Original JassCode
			BJForce f = CreateForce();
			int playerIndex;
			BJPlayer indexPlayer;
			playerIndex = 0;
			while( true )
			{
				indexPlayer = Player(playerIndex);
				if(  GetPlayerController(indexPlayer) == whichControl  )
				{
					ForceAddPlayer(f, indexPlayer);
				}
				playerIndex = playerIndex + 1;
				if(  playerIndex == MAX_PLAYER_SLOTS )
					break;
			}
			return f;
		}

		//===========================================================================
		public static BJForce GetPlayersAllies( BJPlayer whichPlayer )
		{
			// Original JassCode
			BJForce f = CreateForce();
			ForceEnumAllies(f, whichPlayer, null);
			return f;
		}

		//===========================================================================
		public static BJForce GetPlayersEnemies( BJPlayer whichPlayer )
		{
			// Original JassCode
			BJForce f = CreateForce();
			ForceEnumEnemies(f, whichPlayer, null);
			return f;
		}

		//===========================================================================
		public static BJForce GetPlayersMatching( BJBoolExpr filter )
		{
			// Original JassCode
			BJForce f = CreateForce();
			ForceEnumPlayers(f, filter);
			DestroyBoolExpr(filter);
			return f;
		}

		//===========================================================================
		public static void CountUnitsInGroupEnum(  )
		{
			// Original JassCode
			groupCountUnits = groupCountUnits + 1;
		}

		//===========================================================================
		public static int CountUnitsInGroup( BJGroup g )
		{
			// Original JassCode
			// If the user wants the group destroyed, remember that fact and clear
			// the flag, in case it is used again in the callback.
			bool wantDestroy = wantDestroyGroup;
			wantDestroyGroup = false;
			groupCountUnits = 0;
			ForGroup(g,  CountUnitsInGroupEnum);
			// If the user wants the group destroyed, do so now.
			if(  (wantDestroy)  )
			{
				DestroyGroup(g);
			}
			return groupCountUnits;
		}

		//===========================================================================
		public static void CountPlayersInForceEnum(  )
		{
			// Original JassCode
			forceCountPlayers = forceCountPlayers + 1;
		}

		//===========================================================================
		public static int CountPlayersInForceBJ( BJForce f )
		{
			// Original JassCode
			forceCountPlayers = 0;
			ForForce(f,  CountPlayersInForceEnum);
			return forceCountPlayers;
		}

		//===========================================================================
		public static void GetRandomSubGroupEnum(  )
		{
			// Original JassCode
			if(  (randomSubGroupWant > 0)  )
			{
				if(  (randomSubGroupWant >= randomSubGroupTotal) || (GetRandomReal(0,1) < randomSubGroupChance)  )
				{
					// We either need every remaining unit, or the unit passed its chance check.
					GroupAddUnit(randomSubGroupGroup, GetEnumUnit());
					randomSubGroupWant = randomSubGroupWant - 1;
				}
			}
			randomSubGroupTotal = randomSubGroupTotal - 1;
		}

		//===========================================================================
		public static BJGroup GetRandomSubGroup( int count , BJGroup sourceGroup )
		{
			// Original JassCode
			BJGroup g = CreateGroup();
			randomSubGroupGroup = g;
			randomSubGroupWant = count;
			randomSubGroupTotal = CountUnitsInGroup(sourceGroup);
			if(  (randomSubGroupWant <= 0 || randomSubGroupTotal <= 0)  )
			{
				return g;
			}
			randomSubGroupChance = I2R(randomSubGroupWant) / I2R(randomSubGroupTotal);
			ForGroup(sourceGroup,  GetRandomSubGroupEnum);
			return g;
		}

		//===========================================================================
		public static bool LivingPlayerUnitsOfTypeIdFilter(  )
		{
			// Original JassCode
			BJUnit filterUnit = GetFilterUnit();
			return IsUnitAliveBJ(filterUnit) && GetUnitTypeId(filterUnit) == livingPlayerUnitsTypeId;
		}

		//===========================================================================
		public static int CountLivingPlayerUnitsOfTypeId( int unitId , BJPlayer whichPlayer )
		{
			// Original JassCode
			BJGroup g;
			int matchedCount;
			g = CreateGroup();
			livingPlayerUnitsTypeId = unitId;
			GroupEnumUnitsOfPlayer(g, whichPlayer, filterLivingPlayerUnitsOfTypeId);
			matchedCount = CountUnitsInGroup(g);
			DestroyGroup(g);
			return matchedCount;
		}

		//***************************************************************************
		//*
		//*  Animation Utility Functions
		//*
		//***************************************************************************
		//===========================================================================
		public static void ResetUnitAnimation( BJUnit whichUnit )
		{
			// Original JassCode
			SetUnitAnimation(whichUnit, "stand");
		}

		//===========================================================================
		public static void SetUnitTimeScalePercent( BJUnit whichUnit , double percentScale )
		{
			// Original JassCode
			SetUnitTimeScale(whichUnit, percentScale * 0.01);
		}

		//===========================================================================
		public static void SetUnitScalePercent( BJUnit whichUnit , double percentScaleX , double percentScaleY , double percentScaleZ )
		{
			// Original JassCode
			SetUnitScale(whichUnit, percentScaleX * 0.01, percentScaleY * 0.01, percentScaleZ * 0.01);
		}

		//===========================================================================
		// This version differs from the common.j interface in that the alpha value
		// is reversed so as to be displayed as transparency, and all four parameters
		// are treated as percentages rather than bytes.
		//
		public static void SetUnitVertexColorBJ( BJUnit whichUnit , double red , double green , double blue , double transparency )
		{
			// Original JassCode
			SetUnitVertexColor(whichUnit, PercentTo255(red), PercentTo255(green), PercentTo255(blue), PercentTo255(100.0-transparency));
		}

		//===========================================================================
		public static void UnitAddIndicatorBJ( BJUnit whichUnit , double red , double green , double blue , double transparency )
		{
			// Original JassCode
			AddIndicator(whichUnit, PercentTo255(red), PercentTo255(green), PercentTo255(blue), PercentTo255(100.0-transparency));
		}

		//===========================================================================
		public static void DestructableAddIndicatorBJ( BJDestructAble whichDestructable , double red , double green , double blue , double transparency )
		{
			// Original JassCode
			AddIndicator(whichDestructable, PercentTo255(red), PercentTo255(green), PercentTo255(blue), PercentTo255(100.0-transparency));
		}

		//===========================================================================
		public static void ItemAddIndicatorBJ( BJItem whichItem , double red , double green , double blue , double transparency )
		{
			// Original JassCode
			AddIndicator(whichItem, PercentTo255(red), PercentTo255(green), PercentTo255(blue), PercentTo255(100.0-transparency));
		}

		//===========================================================================
		// Sets a unit's facing to point directly at a location.
		//
		public static void SetUnitFacingToFaceLocTimed( BJUnit whichUnit , BJLocation target , double duration )
		{
			// Original JassCode
			BJLocation unitLoc = GetUnitLoc(whichUnit);
			SetUnitFacingTimed(whichUnit, AngleBetweenPoints(unitLoc, target), duration);
			RemoveLocation(unitLoc);
		}

		//===========================================================================
		// Sets a unit's facing to point directly at another unit.
		//
		public static void SetUnitFacingToFaceUnitTimed( BJUnit whichUnit , BJUnit target , double duration )
		{
			// Original JassCode
			BJLocation unitLoc = GetUnitLoc(target);
			SetUnitFacingToFaceLocTimed(whichUnit, unitLoc, duration);
			RemoveLocation(unitLoc);
		}

		//===========================================================================
		public static void QueueUnitAnimationBJ( BJUnit whichUnit , string whichAnimation )
		{
			// Original JassCode
			QueueUnitAnimation(whichUnit, whichAnimation);
		}

		//===========================================================================
		public static void SetDestructableAnimationBJ( BJDestructAble d , string whichAnimation )
		{
			// Original JassCode
			SetDestructableAnimation(d, whichAnimation);
		}

		//===========================================================================
		public static void QueueDestructableAnimationBJ( BJDestructAble d , string whichAnimation )
		{
			// Original JassCode
			QueueDestructableAnimation(d, whichAnimation);
		}

		//===========================================================================
		public static void SetDestAnimationSpeedPercent( BJDestructAble d , double percentScale )
		{
			// Original JassCode
			SetDestructableAnimationSpeed(d, percentScale * 0.01);
		}

		//***************************************************************************
		//*
		//*  Dialog Utility Functions
		//*
		//***************************************************************************
		//===========================================================================
		public static void DialogDisplayBJ( bool flag , BJDialog whichDialog , BJPlayer whichPlayer )
		{
			// Original JassCode
			DialogDisplay(whichPlayer, whichDialog, flag);
		}

		//===========================================================================
		public static void DialogSetMessageBJ( BJDialog whichDialog , string message )
		{
			// Original JassCode
			DialogSetMessage(whichDialog, message);
		}

		//===========================================================================
		public static BJButton DialogAddButtonBJ( BJDialog whichDialog , string buttonText )
		{
			// Original JassCode
			lastCreatedButton = DialogAddButton(whichDialog, buttonText,0);
			return lastCreatedButton;
		}

		//===========================================================================
		public static BJButton DialogAddButtonWithHotkeyBJ( BJDialog whichDialog , string buttonText , int hotkey )
		{
			// Original JassCode
			lastCreatedButton = DialogAddButton(whichDialog, buttonText,hotkey);
			return lastCreatedButton;
		}

		//===========================================================================
		public static void DialogClearBJ( BJDialog whichDialog )
		{
			// Original JassCode
			DialogClear(whichDialog);
		}

		//===========================================================================
		public static BJButton GetLastCreatedButtonBJ(  )
		{
			// Original JassCode
			return lastCreatedButton;
		}

		//===========================================================================
		public static BJButton GetClickedButtonBJ(  )
		{
			// Original JassCode
			return GetClickedButton();
		}

		//===========================================================================
		public static BJDialog GetClickedDialogBJ(  )
		{
			// Original JassCode
			return GetClickedDialog();
		}

		//***************************************************************************
		//*
		//*  Alliance Utility Functions
		//*
		//***************************************************************************
		//===========================================================================
		public static void SetPlayerAllianceBJ( BJPlayer sourcePlayer , BJAllianceType whichAllianceSetting , bool value , BJPlayer otherPlayer )
		{
			// Original JassCode
			// Prevent players from attempting to ally with themselves.
			if(  (sourcePlayer == otherPlayer)  )
			{
				return;
			}
			SetPlayerAlliance(sourcePlayer, otherPlayer, whichAllianceSetting, value);
		}

		//===========================================================================
		// Set all flags used by the in-game "Ally" checkbox.
		//
		public static void SetPlayerAllianceStateAllyBJ( BJPlayer sourcePlayer , BJPlayer otherPlayer , bool flag )
		{
			// Original JassCode
			SetPlayerAlliance(sourcePlayer, otherPlayer, ALLIANCE_PASSIVE, flag);
			SetPlayerAlliance(sourcePlayer, otherPlayer, ALLIANCE_HELP_REQUEST, flag);
			SetPlayerAlliance(sourcePlayer, otherPlayer, ALLIANCE_HELP_RESPONSE, flag);
			SetPlayerAlliance(sourcePlayer, otherPlayer, ALLIANCE_SHARED_XP, flag);
			SetPlayerAlliance(sourcePlayer, otherPlayer, ALLIANCE_SHARED_SPELLS, flag);
		}

		//===========================================================================
		// Set all flags used by the in-game "Shared Vision" checkbox.
		//
		public static void SetPlayerAllianceStateVisionBJ( BJPlayer sourcePlayer , BJPlayer otherPlayer , bool flag )
		{
			// Original JassCode
			SetPlayerAlliance(sourcePlayer, otherPlayer, ALLIANCE_SHARED_VISION, flag);
		}

		//===========================================================================
		// Set all flags used by the in-game "Shared Units" checkbox.
		//
		public static void SetPlayerAllianceStateControlBJ( BJPlayer sourcePlayer , BJPlayer otherPlayer , bool flag )
		{
			// Original JassCode
			SetPlayerAlliance(sourcePlayer, otherPlayer, ALLIANCE_SHARED_CONTROL, flag);
		}

		//===========================================================================
		// Set all flags used by the in-game "Shared Units" checkbox with the Full
		// Shared Unit Control feature enabled.
		//
		public static void SetPlayerAllianceStateFullControlBJ( BJPlayer sourcePlayer , BJPlayer otherPlayer , bool flag )
		{
			// Original JassCode
			SetPlayerAlliance(sourcePlayer, otherPlayer, ALLIANCE_SHARED_ADVANCED_CONTROL, flag);
		}

		//===========================================================================
		public static void SetPlayerAllianceStateBJ( BJPlayer sourcePlayer , BJPlayer otherPlayer , int allianceState )
		{
			// Original JassCode
			// Prevent players from attempting to ally with themselves.
			if(  (sourcePlayer == otherPlayer)  )
			{
				return;
			}
			if(  allianceState == ALLIANCE_UNALLIED  )
			{
				SetPlayerAllianceStateAllyBJ( sourcePlayer, otherPlayer, false );
				SetPlayerAllianceStateVisionBJ( sourcePlayer, otherPlayer, false );
				SetPlayerAllianceStateControlBJ( sourcePlayer, otherPlayer, false );
				SetPlayerAllianceStateFullControlBJ( sourcePlayer, otherPlayer, false );
			}
			else if(  allianceState == ALLIANCE_UNALLIED_VISION  )
			{
				SetPlayerAllianceStateAllyBJ( sourcePlayer, otherPlayer, false );
				SetPlayerAllianceStateVisionBJ( sourcePlayer, otherPlayer, true );
				SetPlayerAllianceStateControlBJ( sourcePlayer, otherPlayer, false );
				SetPlayerAllianceStateFullControlBJ( sourcePlayer, otherPlayer, false );
			}
			else if(  allianceState == ALLIANCE_ALLIED  )
			{
				SetPlayerAllianceStateAllyBJ( sourcePlayer, otherPlayer, true );
				SetPlayerAllianceStateVisionBJ( sourcePlayer, otherPlayer, false );
				SetPlayerAllianceStateControlBJ( sourcePlayer, otherPlayer, false );
				SetPlayerAllianceStateFullControlBJ( sourcePlayer, otherPlayer, false );
			}
			else if(  allianceState == ALLIANCE_ALLIED_VISION  )
			{
				SetPlayerAllianceStateAllyBJ( sourcePlayer, otherPlayer, true );
				SetPlayerAllianceStateVisionBJ( sourcePlayer, otherPlayer, true );
				SetPlayerAllianceStateControlBJ( sourcePlayer, otherPlayer, false );
				SetPlayerAllianceStateFullControlBJ( sourcePlayer, otherPlayer, false );
			}
			else if(  allianceState == ALLIANCE_ALLIED_UNITS  )
			{
				SetPlayerAllianceStateAllyBJ( sourcePlayer, otherPlayer, true );
				SetPlayerAllianceStateVisionBJ( sourcePlayer, otherPlayer, true );
				SetPlayerAllianceStateControlBJ( sourcePlayer, otherPlayer, true );
				SetPlayerAllianceStateFullControlBJ( sourcePlayer, otherPlayer, false );
			}
			else if(  allianceState == ALLIANCE_ALLIED_ADVUNITS  )
			{
				SetPlayerAllianceStateAllyBJ( sourcePlayer, otherPlayer, true );
				SetPlayerAllianceStateVisionBJ( sourcePlayer, otherPlayer, true );
				SetPlayerAllianceStateControlBJ( sourcePlayer, otherPlayer, true );
				SetPlayerAllianceStateFullControlBJ( sourcePlayer, otherPlayer, true );
			}
			else if(  allianceState == ALLIANCE_NEUTRAL  )
			{
				SetPlayerAllianceStateAllyBJ( sourcePlayer, otherPlayer, false );
				SetPlayerAllianceStateVisionBJ( sourcePlayer, otherPlayer, false );
				SetPlayerAllianceStateControlBJ( sourcePlayer, otherPlayer, false );
				SetPlayerAllianceStateFullControlBJ( sourcePlayer, otherPlayer, false );
				SetPlayerAlliance( sourcePlayer, otherPlayer, ALLIANCE_PASSIVE, true );
			}
			else if(  allianceState == ALLIANCE_NEUTRAL_VISION  )
			{
				SetPlayerAllianceStateAllyBJ( sourcePlayer, otherPlayer, false );
				SetPlayerAllianceStateVisionBJ( sourcePlayer, otherPlayer, true );
				SetPlayerAllianceStateControlBJ( sourcePlayer, otherPlayer, false );
				SetPlayerAllianceStateFullControlBJ( sourcePlayer, otherPlayer, false );
				SetPlayerAlliance( sourcePlayer, otherPlayer, ALLIANCE_PASSIVE, true );
			}
			else
			{
				// Unrecognized alliance state - ignore the request.
			}
		}

		//===========================================================================
		// Set the alliance states for an entire force towards another force.
		//
		public static void SetForceAllianceStateBJ( BJForce sourceForce , BJForce targetForce , int allianceState )
		{
			// Original JassCode
			int sourceIndex;
			int targetIndex;
			sourceIndex = 0;
			while( true )
			{
				targetIndex = 0;
				while( true )
				{
					SetPlayerAllianceStateBJ(Player(sourceIndex), Player(targetIndex), allianceState);
					targetIndex = targetIndex + 1;
					if(  targetIndex == MAX_PLAYER_SLOTS )
						break;
				}
				sourceIndex = sourceIndex + 1;
				if(  sourceIndex == MAX_PLAYER_SLOTS )
					break;
			}
		}

		//===========================================================================
		// Test to see if two players are co-allied (allied with each other).
		//
		public static bool PlayersAreCoAllied( BJPlayer playerA , BJPlayer playerB )
		{
			// Original JassCode
			// Players are considered to be allied with themselves.
			if(  (playerA == playerB)  )
			{
				return true;
			}
			// Co-allies are both allied with each other.
			if(  GetPlayerAlliance(playerA, playerB, ALLIANCE_PASSIVE)  )
			{
				if(  GetPlayerAlliance(playerB, playerA, ALLIANCE_PASSIVE)  )
				{
					return true;
				}
			}
			return false;
		}

		//===========================================================================
		// Force (whichPlayer) AI player to share vision and advanced unit control 
		// with all AI players of its allies.
		//
		public static void ShareEverythingWithTeamAI( BJPlayer whichPlayer )
		{
			// Original JassCode
			int playerIndex;
			BJPlayer indexPlayer;
			playerIndex = 0;
			while( true )
			{
				indexPlayer = Player(playerIndex);
				if(  (PlayersAreCoAllied(whichPlayer, indexPlayer) && whichPlayer != indexPlayer)  )
				{
					if(  (GetPlayerController(indexPlayer) == MAP_CONTROL_COMPUTER)  )
					{
						SetPlayerAlliance(whichPlayer, indexPlayer, ALLIANCE_SHARED_VISION, true);
						SetPlayerAlliance(whichPlayer, indexPlayer, ALLIANCE_SHARED_CONTROL, true);
						SetPlayerAlliance(whichPlayer, indexPlayer, ALLIANCE_SHARED_ADVANCED_CONTROL, true);
					}
				}
				playerIndex = playerIndex + 1;
				if(  playerIndex == MAX_PLAYERS )
					break;
			}
		}

		//===========================================================================
		// Force (whichPlayer) to share vision and advanced unit control with all of his/her allies.
		//
		public static void ShareEverythingWithTeam( BJPlayer whichPlayer )
		{
			// Original JassCode
			int playerIndex;
			BJPlayer indexPlayer;
			playerIndex = 0;
			while( true )
			{
				indexPlayer = Player(playerIndex);
				if(  (PlayersAreCoAllied(whichPlayer, indexPlayer) && whichPlayer != indexPlayer)  )
				{
					SetPlayerAlliance(whichPlayer, indexPlayer, ALLIANCE_SHARED_VISION, true);
					SetPlayerAlliance(whichPlayer, indexPlayer, ALLIANCE_SHARED_CONTROL, true);
					SetPlayerAlliance(indexPlayer, whichPlayer, ALLIANCE_SHARED_CONTROL, true);
					SetPlayerAlliance(whichPlayer, indexPlayer, ALLIANCE_SHARED_ADVANCED_CONTROL, true);
				}
				playerIndex = playerIndex + 1;
				if(  playerIndex == MAX_PLAYERS )
					break;
			}
		}

		//===========================================================================
		// Creates a 'Neutral Victim' player slot.  This slot is passive towards all
		// other players, but all other players are aggressive towards him/her.
		// 
		public static void ConfigureNeutralVictim(  )
		{
			// Original JassCode
			int index;
			BJPlayer indexPlayer;
			BJPlayer neutralVictim = Player(PLAYER_NEUTRAL_VICTIM);
			index = 0;
			while( true )
			{
				indexPlayer = Player(index);
				SetPlayerAlliance(neutralVictim, indexPlayer, ALLIANCE_PASSIVE, true);
				SetPlayerAlliance(indexPlayer, neutralVictim, ALLIANCE_PASSIVE, false);
				index = index + 1;
				if(  index == MAX_PLAYERS )
					break;
			}
			// Neutral Victim and Neutral Aggressive should not fight each other.
			indexPlayer = Player(PLAYER_NEUTRAL_AGGRESSIVE);
			SetPlayerAlliance(neutralVictim, indexPlayer, ALLIANCE_PASSIVE, true);
			SetPlayerAlliance(indexPlayer, neutralVictim, ALLIANCE_PASSIVE, true);
			// Neutral Victim does not give bounties.
			SetPlayerState(neutralVictim, PLAYER_STATE_GIVES_BOUNTY, 0);
		}

		//===========================================================================
		public static void MakeUnitsPassiveForPlayerEnum(  )
		{
			// Original JassCode
			SetUnitOwner(GetEnumUnit(), Player(PLAYER_NEUTRAL_VICTIM), false);
		}

		//===========================================================================
		// Change ownership for every unit of (whichPlayer)'s team to neutral passive.
		//
		public static void MakeUnitsPassiveForPlayer( BJPlayer whichPlayer )
		{
			// Original JassCode
			BJGroup playerUnits = CreateGroup();
			CachePlayerHeroData(whichPlayer);
			GroupEnumUnitsOfPlayer(playerUnits, whichPlayer, null);
			ForGroup(playerUnits,  MakeUnitsPassiveForPlayerEnum);
			DestroyGroup(playerUnits);
		}

		//===========================================================================
		// Change ownership for every unit of (whichPlayer)'s team to neutral passive.
		//
		public static void MakeUnitsPassiveForTeam( BJPlayer whichPlayer )
		{
			// Original JassCode
			int playerIndex;
			BJPlayer indexPlayer;
			playerIndex = 0;
			while( true )
			{
				indexPlayer = Player(playerIndex);
				if(  PlayersAreCoAllied(whichPlayer, indexPlayer)  )
				{
					MakeUnitsPassiveForPlayer(indexPlayer);
				}
				playerIndex = playerIndex + 1;
				if(  playerIndex == MAX_PLAYERS )
					break;
			}
		}

		//===========================================================================
		// Determine whether or not victory/defeat is disabled via cheat codes.
		//
		public static bool AllowVictoryDefeat( BJPlayerGameResult gameResult )
		{
			// Original JassCode
			if(  (gameResult == PLAYER_GAME_RESULT_VICTORY)  )
			{
				return ! IsNoVictoryCheat();
			}
			if(  (gameResult == PLAYER_GAME_RESULT_DEFEAT)  )
			{
				return ! IsNoDefeatCheat();
			}
			if(  (gameResult == PLAYER_GAME_RESULT_NEUTRAL)  )
			{
				return (! IsNoVictoryCheat()) && (! IsNoDefeatCheat());
			}
			return true;
		}

		//===========================================================================
		public static void EndGameBJ(  )
		{
			// Original JassCode
			EndGame( true );
		}

		//===========================================================================
		public static void MeleeVictoryDialogBJ( BJPlayer whichPlayer , bool leftGame )
		{
			// Original JassCode
			BJTrigger t = CreateTrigger();
			BJDialog d = DialogCreate();
			string formatString;
			// Display "player was victorious" or "player has left the game" message
			if(  (leftGame)  )
			{
				formatString = GetLocalizedString( "PLAYER_LEFT_GAME" );
			}
			else
			{
				formatString = GetLocalizedString( "PLAYER_VICTORIOUS" );
			}
			DisplayTimedTextFromPlayer(whichPlayer, 0, 0, 60, formatString);
			DialogSetMessage( d, GetLocalizedString( "GAMEOVER_VICTORY_MSG" ) );
			DialogAddButton( d, GetLocalizedString( "GAMEOVER_CONTINUE_GAME" ), GetLocalizedHotkey("GAMEOVER_CONTINUE_GAME") );
			t = CreateTrigger();
			TriggerRegisterDialogButtonEvent( t, DialogAddQuitButton( d, true, GetLocalizedString( "GAMEOVER_QUIT_GAME" ), GetLocalizedHotkey("GAMEOVER_QUIT_GAME") ) );
			DialogDisplay( whichPlayer, d, true );
			StartSoundForPlayerBJ( whichPlayer, victoryDialogSound );
		}

		//===========================================================================
		public static void MeleeDefeatDialogBJ( BJPlayer whichPlayer , bool leftGame )
		{
			// Original JassCode
			BJTrigger t = CreateTrigger();
			BJDialog d = DialogCreate();
			string formatString;
			// Display "player was defeated" or "player has left the game" message
			if(  (leftGame)  )
			{
				formatString = GetLocalizedString( "PLAYER_LEFT_GAME" );
			}
			else
			{
				formatString = GetLocalizedString( "PLAYER_DEFEATED" );
			}
			DisplayTimedTextFromPlayer(whichPlayer, 0, 0, 60, formatString);
			DialogSetMessage( d, GetLocalizedString( "GAMEOVER_DEFEAT_MSG" ) );
			// Only show the continue button if the game is not over and observers on death are allowed
			if(  (! meleeGameOver && IsMapFlagSet(MAP_OBSERVERS_ON_DEATH))  )
			{
				DialogAddButton( d, GetLocalizedString( "GAMEOVER_CONTINUE_OBSERVING" ), GetLocalizedHotkey("GAMEOVER_CONTINUE_OBSERVING") );
			}
			t = CreateTrigger();
			TriggerRegisterDialogButtonEvent( t, DialogAddQuitButton( d, true, GetLocalizedString( "GAMEOVER_QUIT_GAME" ), GetLocalizedHotkey("GAMEOVER_QUIT_GAME") ) );
			DialogDisplay( whichPlayer, d, true );
			StartSoundForPlayerBJ( whichPlayer, defeatDialogSound );
		}

		//===========================================================================
		public static void GameOverDialogBJ( BJPlayer whichPlayer , bool leftGame )
		{
			// Original JassCode
			BJTrigger t = CreateTrigger();
			BJDialog d = DialogCreate();
			string s;
			// Display "player left the game" message
			DisplayTimedTextFromPlayer(whichPlayer, 0, 0, 60, GetLocalizedString( "PLAYER_LEFT_GAME" ));
			if(  (GetIntegerGameState(GAME_STATE_DISCONNECTED) != 0)  )
			{
				s = GetLocalizedString( "GAMEOVER_DISCONNECTED" );
			}
			else
			{
				s = GetLocalizedString( "GAMEOVER_GAME_OVER" );
			}
			DialogSetMessage( d, s );
			t = CreateTrigger();
			TriggerRegisterDialogButtonEvent( t, DialogAddQuitButton( d, true, GetLocalizedString( "GAMEOVER_OK" ), GetLocalizedHotkey("GAMEOVER_OK") ) );
			DialogDisplay( whichPlayer, d, true );
			StartSoundForPlayerBJ( whichPlayer, defeatDialogSound );
		}

		//===========================================================================
		public static void RemovePlayerPreserveUnitsBJ( BJPlayer whichPlayer , BJPlayerGameResult gameResult , bool leftGame )
		{
			// Original JassCode
			if(  AllowVictoryDefeat(gameResult)  )
			{
				RemovePlayer(whichPlayer, gameResult);
				if( gameResult == PLAYER_GAME_RESULT_VICTORY ) 
				{
					MeleeVictoryDialogBJ( whichPlayer, leftGame );
					return;
				}
				else if( gameResult == PLAYER_GAME_RESULT_DEFEAT ) 
				{
					MeleeDefeatDialogBJ( whichPlayer, leftGame );
				}
				else
				{
					GameOverDialogBJ( whichPlayer, leftGame );
				}
			}
		}

		//===========================================================================
		public static void CustomVictoryOkBJ(  )
		{
			// Original JassCode
			if(  isSinglePlayer  )
			{
				PauseGame( false );
				// Bump the difficulty back up to the default.
				SetGameDifficulty(GetDefaultDifficulty());
			}
			if(  (changeLevelMapName == null)  )
			{
				EndGame( changeLevelShowScores );
			}
			else
			{
				ChangeLevel( changeLevelMapName, changeLevelShowScores );
			}
		}

		//===========================================================================
		public static void CustomVictoryQuitBJ(  )
		{
			// Original JassCode
			if(  isSinglePlayer  )
			{
				PauseGame( false );
				// Bump the difficulty back up to the default.
				SetGameDifficulty(GetDefaultDifficulty());
			}
			EndGame( changeLevelShowScores );
		}

		//===========================================================================
		public static void CustomVictoryDialogBJ( BJPlayer whichPlayer )
		{
			// Original JassCode
			BJTrigger t = CreateTrigger();
			BJDialog d = DialogCreate();
			DialogSetMessage( d, GetLocalizedString( "GAMEOVER_VICTORY_MSG" ) );
			t = CreateTrigger();
			TriggerRegisterDialogButtonEvent( t, DialogAddButton( d, GetLocalizedString( "GAMEOVER_CONTINUE" ), GetLocalizedHotkey("GAMEOVER_CONTINUE") ) );
			TriggerAddAction( t,  CustomVictoryOkBJ );
			t = CreateTrigger();
			TriggerRegisterDialogButtonEvent( t, DialogAddButton( d, GetLocalizedString( "GAMEOVER_QUIT_MISSION" ), GetLocalizedHotkey("GAMEOVER_QUIT_MISSION") ) );
			TriggerAddAction( t,  CustomVictoryQuitBJ );
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				EnableUserControl( true );
				if(  isSinglePlayer  )
				{
					PauseGame( true );
				}
			}
			EnableUserUI(false);
			DialogDisplay( whichPlayer, d, true );
			VolumeGroupSetVolumeForPlayerBJ( whichPlayer, SOUND_VOLUMEGROUP_UI, 1.0 );
			StartSoundForPlayerBJ( whichPlayer, victoryDialogSound );
		}

		//===========================================================================
		public static void CustomVictorySkipBJ( BJPlayer whichPlayer )
		{
			// Original JassCode
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				if(  isSinglePlayer  )
				{
					// Bump the difficulty back up to the default.
					SetGameDifficulty(GetDefaultDifficulty());
				}
				if(  (changeLevelMapName == null)  )
				{
					EndGame( changeLevelShowScores );
				}
				else
				{
					ChangeLevel( changeLevelMapName, changeLevelShowScores );
				}
			}
		}

		//===========================================================================
		public static void CustomVictoryBJ( BJPlayer whichPlayer , bool showDialog , bool showScores )
		{
			// Original JassCode
			if(  AllowVictoryDefeat( PLAYER_GAME_RESULT_VICTORY )  )
			{
				RemovePlayer( whichPlayer, PLAYER_GAME_RESULT_VICTORY );
				if(  ! isSinglePlayer  )
				{
					DisplayTimedTextFromPlayer(whichPlayer, 0, 0, 60, GetLocalizedString( "PLAYER_VICTORIOUS" ) );
				}
				// UI only needs to be displayed to users.
				if(  (GetPlayerController(whichPlayer) == MAP_CONTROL_USER)  )
				{
					changeLevelShowScores = showScores;
					if(  showDialog  )
					{
						CustomVictoryDialogBJ( whichPlayer );
					}
					else
					{
						CustomVictorySkipBJ( whichPlayer );
					}
				}
			}
		}

		//===========================================================================
		public static void CustomDefeatRestartBJ(  )
		{
			// Original JassCode
			PauseGame( false );
			RestartGame( true );
		}

		//===========================================================================
		public static void CustomDefeatReduceDifficultyBJ(  )
		{
			// Original JassCode
			BJGameDifficulty diff = GetGameDifficulty();
			PauseGame( false );
			// Knock the difficulty down, if possible.
			if(  (diff == MAP_DIFFICULTY_EASY)  )
			{
				// Sorry, but it doesn't get any easier than this.
			}
			else if(  (diff == MAP_DIFFICULTY_NORMAL)  )
			{
				SetGameDifficulty(MAP_DIFFICULTY_EASY);
			}
			else if(  (diff == MAP_DIFFICULTY_HARD)  )
			{
				SetGameDifficulty(MAP_DIFFICULTY_NORMAL);
			}
			else
			{
				// Unrecognized difficulty
			}
			RestartGame( true );
		}

		//===========================================================================
		public static void CustomDefeatLoadBJ(  )
		{
			// Original JassCode
			PauseGame( false );
			DisplayLoadDialog();
		}

		//===========================================================================
		public static void CustomDefeatQuitBJ(  )
		{
			// Original JassCode
			if(  isSinglePlayer  )
			{
				PauseGame( false );
			}
			// Bump the difficulty back up to the default.
			SetGameDifficulty(GetDefaultDifficulty());
			EndGame( true );
		}

		//===========================================================================
		public static void CustomDefeatDialogBJ( BJPlayer whichPlayer , string message )
		{
			// Original JassCode
			BJTrigger t = CreateTrigger();
			BJDialog d = DialogCreate();
			DialogSetMessage( d, message );
			if(  isSinglePlayer  )
			{
				t = CreateTrigger();
				TriggerRegisterDialogButtonEvent( t, DialogAddButton( d, GetLocalizedString( "GAMEOVER_RESTART" ), GetLocalizedHotkey("GAMEOVER_RESTART") ) );
				TriggerAddAction( t,  CustomDefeatRestartBJ );
				if(  (GetGameDifficulty() != MAP_DIFFICULTY_EASY)  )
				{
					t = CreateTrigger();
					TriggerRegisterDialogButtonEvent( t, DialogAddButton( d, GetLocalizedString( "GAMEOVER_REDUCE_DIFFICULTY" ), GetLocalizedHotkey("GAMEOVER_REDUCE_DIFFICULTY") ) );
					TriggerAddAction( t,  CustomDefeatReduceDifficultyBJ );
				}
				t = CreateTrigger();
				TriggerRegisterDialogButtonEvent( t, DialogAddButton( d, GetLocalizedString( "GAMEOVER_LOAD" ), GetLocalizedHotkey("GAMEOVER_LOAD") ) );
				TriggerAddAction( t,  CustomDefeatLoadBJ );
			}
			t = CreateTrigger();
			TriggerRegisterDialogButtonEvent( t, DialogAddButton( d, GetLocalizedString( "GAMEOVER_QUIT_MISSION" ), GetLocalizedHotkey("GAMEOVER_QUIT_MISSION") ) );
			TriggerAddAction( t,  CustomDefeatQuitBJ );
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				EnableUserControl( true );
				if(  isSinglePlayer  )
				{
					PauseGame( true );
				}
			}
			EnableUserUI(false);
			DialogDisplay( whichPlayer, d, true );
			VolumeGroupSetVolumeForPlayerBJ( whichPlayer, SOUND_VOLUMEGROUP_UI, 1.0 );
			StartSoundForPlayerBJ( whichPlayer, defeatDialogSound );
		}

		//===========================================================================
		public static void CustomDefeatBJ( BJPlayer whichPlayer , string message )
		{
			// Original JassCode
			if(  AllowVictoryDefeat( PLAYER_GAME_RESULT_DEFEAT )  )
			{
				RemovePlayer( whichPlayer, PLAYER_GAME_RESULT_DEFEAT );
				if(  ! isSinglePlayer  )
				{
					DisplayTimedTextFromPlayer(whichPlayer, 0, 0, 60, GetLocalizedString( "PLAYER_DEFEATED" ) );
				}
				// UI only needs to be displayed to users.
				if(  (GetPlayerController(whichPlayer) == MAP_CONTROL_USER)  )
				{
					CustomDefeatDialogBJ( whichPlayer, message );
				}
			}
		}

		//===========================================================================
		public static void SetNextLevelBJ( string nextLevel )
		{
			// Original JassCode
			if(  (nextLevel == "")  )
			{
				changeLevelMapName = null;
			}
			else
			{
				changeLevelMapName = nextLevel;
			}
		}

		//===========================================================================
		public static void SetPlayerOnScoreScreenBJ( bool flag , BJPlayer whichPlayer )
		{
			// Original JassCode
			SetPlayerOnScoreScreen(whichPlayer, flag);
		}

		//***************************************************************************
		//*
		//*  Quest Utility Functions
		//*
		//***************************************************************************
		//===========================================================================
		public static BJQuest CreateQuestBJ( int questType , string title , string description , string iconPath )
		{
			// Original JassCode
			bool required = (questType == QUESTTYPE_REQ_DISCOVERED) || (questType == QUESTTYPE_REQ_UNDISCOVERED);
			bool discovered = (questType == QUESTTYPE_REQ_DISCOVERED) || (questType == QUESTTYPE_OPT_DISCOVERED);
			lastCreatedQuest = CreateQuest();
			QuestSetTitle(lastCreatedQuest, title);
			QuestSetDescription(lastCreatedQuest, description);
			QuestSetIconPath(lastCreatedQuest, iconPath);
			QuestSetRequired(lastCreatedQuest, required);
			QuestSetDiscovered(lastCreatedQuest, discovered);
			QuestSetCompleted(lastCreatedQuest, false);
			return lastCreatedQuest;
		}

		//===========================================================================
		public static void DestroyQuestBJ( BJQuest whichQuest )
		{
			// Original JassCode
			DestroyQuest(whichQuest);
		}

		//===========================================================================
		public static void QuestSetEnabledBJ( bool enabled , BJQuest whichQuest )
		{
			// Original JassCode
			QuestSetEnabled(whichQuest, enabled);
		}

		//===========================================================================
		public static void QuestSetTitleBJ( BJQuest whichQuest , string title )
		{
			// Original JassCode
			QuestSetTitle(whichQuest, title);
		}

		//===========================================================================
		public static void QuestSetDescriptionBJ( BJQuest whichQuest , string description )
		{
			// Original JassCode
			QuestSetDescription(whichQuest, description);
		}

		//===========================================================================
		public static void QuestSetCompletedBJ( BJQuest whichQuest , bool completed )
		{
			// Original JassCode
			QuestSetCompleted(whichQuest, completed);
		}

		//===========================================================================
		public static void QuestSetFailedBJ( BJQuest whichQuest , bool failed )
		{
			// Original JassCode
			QuestSetFailed(whichQuest, failed);
		}

		//===========================================================================
		public static void QuestSetDiscoveredBJ( BJQuest whichQuest , bool discovered )
		{
			// Original JassCode
			QuestSetDiscovered(whichQuest, discovered);
		}

		//===========================================================================
		public static BJQuest GetLastCreatedQuestBJ(  )
		{
			// Original JassCode
			return lastCreatedQuest;
		}

		//===========================================================================
		public static BJQuestItem CreateQuestItemBJ( BJQuest whichQuest , string description )
		{
			// Original JassCode
			lastCreatedQuestItem = QuestCreateItem(whichQuest);
			QuestItemSetDescription(lastCreatedQuestItem, description);
			QuestItemSetCompleted(lastCreatedQuestItem, false);
			return lastCreatedQuestItem;
		}

		//===========================================================================
		public static void QuestItemSetDescriptionBJ( BJQuestItem whichQuestItem , string description )
		{
			// Original JassCode
			QuestItemSetDescription(whichQuestItem, description);
		}

		//===========================================================================
		public static void QuestItemSetCompletedBJ( BJQuestItem whichQuestItem , bool completed )
		{
			// Original JassCode
			QuestItemSetCompleted(whichQuestItem, completed);
		}

		//===========================================================================
		public static BJQuestItem GetLastCreatedQuestItemBJ(  )
		{
			// Original JassCode
			return lastCreatedQuestItem;
		}

		//===========================================================================
		public static BJDefeatCondition CreateDefeatConditionBJ( string description )
		{
			// Original JassCode
			lastCreatedDefeatCondition = CreateDefeatCondition();
			DefeatConditionSetDescription(lastCreatedDefeatCondition, description);
			return lastCreatedDefeatCondition;
		}

		//===========================================================================
		public static void DestroyDefeatConditionBJ( BJDefeatCondition whichCondition )
		{
			// Original JassCode
			DestroyDefeatCondition(whichCondition);
		}

		//===========================================================================
		public static void DefeatConditionSetDescriptionBJ( BJDefeatCondition whichCondition , string description )
		{
			// Original JassCode
			DefeatConditionSetDescription(whichCondition, description);
		}

		//===========================================================================
		public static BJDefeatCondition GetLastCreatedDefeatConditionBJ(  )
		{
			// Original JassCode
			return lastCreatedDefeatCondition;
		}

		//===========================================================================
		public static void FlashQuestDialogButtonBJ(  )
		{
			// Original JassCode
			FlashQuestDialogButton();
		}

		//===========================================================================
		public static void QuestMessageBJ( BJForce f , int messageType , string message )
		{
			// Original JassCode
			if(  (IsPlayerInForce(GetLocalPlayer(), f))  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				if(  (messageType == QUESTMESSAGE_DISCOVERED)  )
				{
					DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, TEXT_DELAY_QUEST, " ");
					DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, TEXT_DELAY_QUEST, message);
					StartSound(questDiscoveredSound);
					FlashQuestDialogButton();
				}
				else if(  (messageType == QUESTMESSAGE_UPDATED)  )
				{
					DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, TEXT_DELAY_QUESTUPDATE, " ");
					DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, TEXT_DELAY_QUESTUPDATE, message);
					StartSound(questUpdatedSound);
					FlashQuestDialogButton();
				}
				else if(  (messageType == QUESTMESSAGE_COMPLETED)  )
				{
					DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, TEXT_DELAY_QUESTDONE, " ");
					DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, TEXT_DELAY_QUESTDONE, message);
					StartSound(questCompletedSound);
					FlashQuestDialogButton();
				}
				else if(  (messageType == QUESTMESSAGE_FAILED)  )
				{
					DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, TEXT_DELAY_QUESTFAILED, " ");
					DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, TEXT_DELAY_QUESTFAILED, message);
					StartSound(questFailedSound);
					FlashQuestDialogButton();
				}
				else if(  (messageType == QUESTMESSAGE_REQUIREMENT)  )
				{
					DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, TEXT_DELAY_QUESTREQUIREMENT, message);
				}
				else if(  (messageType == QUESTMESSAGE_MISSIONFAILED)  )
				{
					DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, TEXT_DELAY_MISSIONFAILED, " ");
					DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, TEXT_DELAY_MISSIONFAILED, message);
					StartSound(questFailedSound);
				}
				else if(  (messageType == QUESTMESSAGE_HINT)  )
				{
					DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, TEXT_DELAY_HINT, " ");
					DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, TEXT_DELAY_HINT, message);
					StartSound(questHintSound);
				}
				else if(  (messageType == QUESTMESSAGE_ALWAYSHINT)  )
				{
					DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, TEXT_DELAY_ALWAYSHINT, " ");
					DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, TEXT_DELAY_ALWAYSHINT, message);
					StartSound(questHintSound);
				}
				else if(  (messageType == QUESTMESSAGE_SECRET)  )
				{
					DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, TEXT_DELAY_SECRET, " ");
					DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, TEXT_DELAY_SECRET, message);
					StartSound(questSecretSound);
				}
				else if(  (messageType == QUESTMESSAGE_UNITACQUIRED)  )
				{
					DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, TEXT_DELAY_UNITACQUIRED, " ");
					DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, TEXT_DELAY_UNITACQUIRED, message);
					StartSound(questHintSound);
				}
				else if(  (messageType == QUESTMESSAGE_UNITAVAILABLE)  )
				{
					DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, TEXT_DELAY_UNITAVAILABLE, " ");
					DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, TEXT_DELAY_UNITAVAILABLE, message);
					StartSound(questHintSound);
				}
				else if(  (messageType == QUESTMESSAGE_ITEMACQUIRED)  )
				{
					DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, TEXT_DELAY_ITEMACQUIRED, " ");
					DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, TEXT_DELAY_ITEMACQUIRED, message);
					StartSound(questItemAcquiredSound);
				}
				else if(  (messageType == QUESTMESSAGE_WARNING)  )
				{
					DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, TEXT_DELAY_WARNING, " ");
					DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, TEXT_DELAY_WARNING, message);
					StartSound(questWarningSound);
				}
				else
				{
					// Unrecognized message type - ignore the request.
				}
			}
		}

		//***************************************************************************
		//*
		//*  Timer Utility Functions
		//*
		//***************************************************************************
		//===========================================================================
		public static BJTimer StartTimerBJ( BJTimer t , bool periodic , double timeout )
		{
			// Original JassCode
			lastStartedTimer = t;
			TimerStart(t, timeout, periodic, null);
			return lastStartedTimer;
		}

		//===========================================================================
		public static BJTimer CreateTimerBJ( bool periodic , double timeout )
		{
			// Original JassCode
			lastStartedTimer = CreateTimer();
			TimerStart(lastStartedTimer, timeout, periodic, null);
			return lastStartedTimer;
		}

		//===========================================================================
		public static void DestroyTimerBJ( BJTimer whichTimer )
		{
			// Original JassCode
			DestroyTimer(whichTimer);
		}

		//===========================================================================
		public static void PauseTimerBJ( bool pause , BJTimer whichTimer )
		{
			// Original JassCode
			if(  pause  )
			{
				PauseTimer(whichTimer);
			}
			else
			{
				ResumeTimer(whichTimer);
			}
		}

		//===========================================================================
		public static BJTimer GetLastCreatedTimerBJ(  )
		{
			// Original JassCode
			return lastStartedTimer;
		}

		//===========================================================================
		public static BJTimerDialog CreateTimerDialogBJ( BJTimer t , string title )
		{
			// Original JassCode
			lastCreatedTimerDialog = CreateTimerDialog(t);
			TimerDialogSetTitle(lastCreatedTimerDialog, title);
			TimerDialogDisplay(lastCreatedTimerDialog, true);
			return lastCreatedTimerDialog;
		}

		//===========================================================================
		public static void DestroyTimerDialogBJ( BJTimerDialog td )
		{
			// Original JassCode
			DestroyTimerDialog(td);
		}

		//===========================================================================
		public static void TimerDialogSetTitleBJ( BJTimerDialog td , string title )
		{
			// Original JassCode
			TimerDialogSetTitle(td, title);
		}

		//===========================================================================
		public static void TimerDialogSetTitleColorBJ( BJTimerDialog td , double red , double green , double blue , double transparency )
		{
			// Original JassCode
			TimerDialogSetTitleColor(td, PercentTo255(red), PercentTo255(green), PercentTo255(blue), PercentTo255(100.0-transparency));
		}

		//===========================================================================
		public static void TimerDialogSetTimeColorBJ( BJTimerDialog td , double red , double green , double blue , double transparency )
		{
			// Original JassCode
			TimerDialogSetTimeColor(td, PercentTo255(red), PercentTo255(green), PercentTo255(blue), PercentTo255(100.0-transparency));
		}

		//===========================================================================
		public static void TimerDialogSetSpeedBJ( BJTimerDialog td , double speedMultFactor )
		{
			// Original JassCode
			TimerDialogSetSpeed(td, speedMultFactor);
		}

		//===========================================================================
		public static void TimerDialogDisplayForPlayerBJ( bool show , BJTimerDialog td , BJPlayer whichPlayer )
		{
			// Original JassCode
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				TimerDialogDisplay(td, show);
			}
		}

		//===========================================================================
		public static void TimerDialogDisplayBJ( bool show , BJTimerDialog td )
		{
			// Original JassCode
			TimerDialogDisplay(td, show);
		}

		//===========================================================================
		public static BJTimerDialog GetLastCreatedTimerDialogBJ(  )
		{
			// Original JassCode
			return lastCreatedTimerDialog;
		}

		//***************************************************************************
		//*
		//*  Leaderboard Utility Functions
		//*
		//***************************************************************************
		//===========================================================================
		public static void LeaderboardResizeBJ( BJLeaderBoard lb )
		{
			// Original JassCode
			int size = LeaderboardGetItemCount(lb);
			if(  (LeaderboardGetLabelText(lb) == "")  )
			{
				size = size - 1;
			}
			LeaderboardSetSizeByItemCount(lb, size);
		}

		//===========================================================================
		public static void LeaderboardSetPlayerItemValueBJ( BJPlayer whichPlayer , BJLeaderBoard lb , int val )
		{
			// Original JassCode
			LeaderboardSetItemValue(lb, LeaderboardGetPlayerIndex(lb, whichPlayer), val);
		}

		//===========================================================================
		public static void LeaderboardSetPlayerItemLabelBJ( BJPlayer whichPlayer , BJLeaderBoard lb , string val )
		{
			// Original JassCode
			LeaderboardSetItemLabel(lb, LeaderboardGetPlayerIndex(lb, whichPlayer), val);
		}

		//===========================================================================
		public static void LeaderboardSetPlayerItemStyleBJ( BJPlayer whichPlayer , BJLeaderBoard lb , bool showLabel , bool showValue , bool showIcon )
		{
			// Original JassCode
			LeaderboardSetItemStyle(lb, LeaderboardGetPlayerIndex(lb, whichPlayer), showLabel, showValue, showIcon);
		}

		//===========================================================================
		public static void LeaderboardSetPlayerItemLabelColorBJ( BJPlayer whichPlayer , BJLeaderBoard lb , double red , double green , double blue , double transparency )
		{
			// Original JassCode
			LeaderboardSetItemLabelColor(lb, LeaderboardGetPlayerIndex(lb, whichPlayer), PercentTo255(red), PercentTo255(green), PercentTo255(blue), PercentTo255(100.0-transparency));
		}

		//===========================================================================
		public static void LeaderboardSetPlayerItemValueColorBJ( BJPlayer whichPlayer , BJLeaderBoard lb , double red , double green , double blue , double transparency )
		{
			// Original JassCode
			LeaderboardSetItemValueColor(lb, LeaderboardGetPlayerIndex(lb, whichPlayer), PercentTo255(red), PercentTo255(green), PercentTo255(blue), PercentTo255(100.0-transparency));
		}

		//===========================================================================
		public static void LeaderboardSetLabelColorBJ( BJLeaderBoard lb , double red , double green , double blue , double transparency )
		{
			// Original JassCode
			LeaderboardSetLabelColor(lb, PercentTo255(red), PercentTo255(green), PercentTo255(blue), PercentTo255(100.0-transparency));
		}

		//===========================================================================
		public static void LeaderboardSetValueColorBJ( BJLeaderBoard lb , double red , double green , double blue , double transparency )
		{
			// Original JassCode
			LeaderboardSetValueColor(lb, PercentTo255(red), PercentTo255(green), PercentTo255(blue), PercentTo255(100.0-transparency));
		}

		//===========================================================================
		public static void LeaderboardSetLabelBJ( BJLeaderBoard lb , string label )
		{
			// Original JassCode
			LeaderboardSetLabel(lb, label);
			LeaderboardResizeBJ(lb);
		}

		//===========================================================================
		public static void LeaderboardSetStyleBJ( BJLeaderBoard lb , bool showLabel , bool showNames , bool showValues , bool showIcons )
		{
			// Original JassCode
			LeaderboardSetStyle(lb, showLabel, showNames, showValues, showIcons);
		}

		//===========================================================================
		public static int LeaderboardGetItemCountBJ( BJLeaderBoard lb )
		{
			// Original JassCode
			return LeaderboardGetItemCount(lb);
		}

		//===========================================================================
		public static bool LeaderboardHasPlayerItemBJ( BJLeaderBoard lb , BJPlayer whichPlayer )
		{
			// Original JassCode
			return LeaderboardHasPlayerItem(lb, whichPlayer);
		}

		//===========================================================================
		public static void ForceSetLeaderboardBJ( BJLeaderBoard lb , BJForce toForce )
		{
			// Original JassCode
			int index;
			BJPlayer indexPlayer;
			index = 0;
			while( true )
			{
				indexPlayer = Player(index);
				if(  IsPlayerInForce(indexPlayer, toForce)  )
				{
					PlayerSetLeaderboard(indexPlayer, lb);
				}
				index = index + 1;
				if(  index == MAX_PLAYERS )
					break;
			}
		}

		//===========================================================================
		public static BJLeaderBoard CreateLeaderboardBJ( BJForce toForce , string label )
		{
			// Original JassCode
			lastCreatedLeaderboard = CreateLeaderboard();
			LeaderboardSetLabel(lastCreatedLeaderboard, label);
			ForceSetLeaderboardBJ(lastCreatedLeaderboard, toForce);
			LeaderboardDisplay(lastCreatedLeaderboard, true);
			return lastCreatedLeaderboard;
		}

		//===========================================================================
		public static void DestroyLeaderboardBJ( BJLeaderBoard lb )
		{
			// Original JassCode
			DestroyLeaderboard(lb);
		}

		//===========================================================================
		public static void LeaderboardDisplayBJ( bool show , BJLeaderBoard lb )
		{
			// Original JassCode
			LeaderboardDisplay(lb, show);
		}

		//===========================================================================
		public static void LeaderboardAddItemBJ( BJPlayer whichPlayer , BJLeaderBoard lb , string label , int value )
		{
			// Original JassCode
			if(  (LeaderboardHasPlayerItem(lb, whichPlayer))  )
			{
				LeaderboardRemovePlayerItem(lb, whichPlayer);
			}
			LeaderboardAddItem(lb, label, value, whichPlayer);
			LeaderboardResizeBJ(lb);
			//call LeaderboardSetSizeByItemCount(lb, LeaderboardGetItemCount(lb))
		}

		//===========================================================================
		public static void LeaderboardRemovePlayerItemBJ( BJPlayer whichPlayer , BJLeaderBoard lb )
		{
			// Original JassCode
			LeaderboardRemovePlayerItem(lb, whichPlayer);
			LeaderboardResizeBJ(lb);
		}

		//===========================================================================
		public static void LeaderboardSortItemsBJ( BJLeaderBoard lb , int sortType , bool ascending )
		{
			// Original JassCode
			if(  (sortType == SORTTYPE_SORTBYVALUE)  )
			{
				LeaderboardSortItemsByValue(lb, ascending);
			}
			else if(  (sortType == SORTTYPE_SORTBYPLAYER)  )
			{
				LeaderboardSortItemsByPlayer(lb, ascending);
			}
			else if(  (sortType == SORTTYPE_SORTBYLABEL)  )
			{
				LeaderboardSortItemsByLabel(lb, ascending);
			}
			else
			{
				// Unrecognized sort type - ignore the request.
			}
		}

		//===========================================================================
		public static void LeaderboardSortItemsByPlayerBJ( BJLeaderBoard lb , bool ascending )
		{
			// Original JassCode
			LeaderboardSortItemsByPlayer(lb, ascending);
		}

		//===========================================================================
		public static void LeaderboardSortItemsByLabelBJ( BJLeaderBoard lb , bool ascending )
		{
			// Original JassCode
			LeaderboardSortItemsByLabel(lb, ascending);
		}

		//===========================================================================
		public static int LeaderboardGetPlayerIndexBJ( BJPlayer whichPlayer , BJLeaderBoard lb )
		{
			// Original JassCode
			return LeaderboardGetPlayerIndex(lb, whichPlayer) + 1;
		}

		//===========================================================================
		// Returns the player who is occupying a specified position in a leaderboard.
		// The position parameter is expected in the range of 1..16.
		//
		public static BJPlayer LeaderboardGetIndexedPlayerBJ( int position , BJLeaderBoard lb )
		{
			// Original JassCode
			int index;
			BJPlayer indexPlayer;
			index = 0;
			while( true )
			{
				indexPlayer = Player(index);
				if(  (LeaderboardGetPlayerIndex(lb, indexPlayer) == position - 1)  )
				{
					return indexPlayer;
				}
				index = index + 1;
				if(  index == MAX_PLAYERS )
					break;
			}
			return Player(PLAYER_NEUTRAL_PASSIVE);
		}

		//===========================================================================
		public static BJLeaderBoard PlayerGetLeaderboardBJ( BJPlayer whichPlayer )
		{
			// Original JassCode
			return PlayerGetLeaderboard(whichPlayer);
		}

		//===========================================================================
		public static BJLeaderBoard GetLastCreatedLeaderboard(  )
		{
			// Original JassCode
			return lastCreatedLeaderboard;
		}

		//===========================================================================
		public static void MultiboardAllowDisplayBJ( bool flag )
		{
			// Original JassCode
			MultiboardSuppressDisplay(! flag);
		}

		//***************************************************************************
		//*
		//*  Text Tag Utility Functions
		//*
		//***************************************************************************
		//===========================================================================
		// Scale the font size linearly such that size 10 equates to height 0.023.
		// Screen-relative font heights are harder to grasp and than font sizes.
		//
		public static double TextTagSize2Height( double size )
		{
			// Original JassCode
			return size * 0.023 / 10;
		}

		//===========================================================================
		// Scale the speed linearly such that speed 128 equates to 0.071.
		// Screen-relative speeds are hard to grasp.
		//
		public static double TextTagSpeed2Velocity( double speed )
		{
			// Original JassCode
			return speed * 0.071 / 128;
		}

		//===========================================================================
		public static void SetTextTagColorBJ( BJTextTag tt , double red , double green , double blue , double transparency )
		{
			// Original JassCode
			SetTextTagColor(tt, PercentTo255(red), PercentTo255(green), PercentTo255(blue), PercentTo255(100.0-transparency));
		}

		//===========================================================================
		public static BJTextTag CreateTextTagLocBJ( string s , BJLocation loc , double zOffset , double size , double red , double green , double blue , double transparency )
		{
			// Original JassCode
			double textHeight = TextTagSize2Height(size);
			lastCreatedTextTag = CreateTextTag();
			SetTextTagText(lastCreatedTextTag, s, textHeight);
			SetTextTagPos(lastCreatedTextTag, GetLocationX(loc), GetLocationY(loc), zOffset);
			SetTextTagColorBJ(lastCreatedTextTag, red, green, blue, transparency);
			return lastCreatedTextTag;
		}

		//===========================================================================
		public static BJTextTag CreateTextTagUnitBJ( string s , BJUnit whichUnit , double zOffset , double size , double red , double green , double blue , double transparency )
		{
			// Original JassCode
			double textHeight = TextTagSize2Height(size);
			lastCreatedTextTag = CreateTextTag();
			SetTextTagText(lastCreatedTextTag, s, textHeight);
			SetTextTagPosUnit(lastCreatedTextTag, whichUnit, zOffset);
			SetTextTagColorBJ(lastCreatedTextTag, red, green, blue, transparency);
			return lastCreatedTextTag;
		}

		//===========================================================================
		public static void DestroyTextTagBJ( BJTextTag tt )
		{
			// Original JassCode
			DestroyTextTag(tt);
		}

		//===========================================================================
		public static void SetTextTagVelocityBJ( BJTextTag tt , double speed , double angle )
		{
			// Original JassCode
			double vel = TextTagSpeed2Velocity(speed);
			double xvel = vel * Cos(angle * DEGTORAD);
			double yvel = vel * Sin(angle * DEGTORAD);
			SetTextTagVelocity(tt, xvel, yvel);
		}

		//===========================================================================
		public static void ShowTextTagForceBJ( bool show , BJTextTag tt , BJForce whichForce )
		{
			// Original JassCode
			if(  (IsPlayerInForce(GetLocalPlayer(), whichForce))  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				SetTextTagVisibility(tt, show);
			}
		}

		//===========================================================================
		public static BJTextTag GetLastCreatedTextTag(  )
		{
			// Original JassCode
			return lastCreatedTextTag;
		}

		//***************************************************************************
		//*
		//*  Cinematic Utility Functions
		//*
		//***************************************************************************
		//===========================================================================
		public static void PauseGameOn(  )
		{
			// Original JassCode
			PauseGame(true);
		}

		//===========================================================================
		public static void PauseGameOff(  )
		{
			// Original JassCode
			PauseGame(false);
		}

		//===========================================================================
		public static void SetUserControlForceOn( BJForce whichForce )
		{
			// Original JassCode
			if(  (IsPlayerInForce(GetLocalPlayer(), whichForce))  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				EnableUserControl(true);
			}
		}

		//===========================================================================
		public static void SetUserControlForceOff( BJForce whichForce )
		{
			// Original JassCode
			if(  (IsPlayerInForce(GetLocalPlayer(), whichForce))  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				EnableUserControl(false);
			}
		}

		//===========================================================================
		public static void ShowInterfaceForceOn( BJForce whichForce , double fadeDuration )
		{
			// Original JassCode
			if(  (IsPlayerInForce(GetLocalPlayer(), whichForce))  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				ShowInterface(true, fadeDuration);
			}
		}

		//===========================================================================
		public static void ShowInterfaceForceOff( BJForce whichForce , double fadeDuration )
		{
			// Original JassCode
			if(  (IsPlayerInForce(GetLocalPlayer(), whichForce))  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				ShowInterface(false, fadeDuration);
			}
		}

		//===========================================================================
		public static void PingMinimapForForce( BJForce whichForce , double x , double y , double duration )
		{
			// Original JassCode
			if(  (IsPlayerInForce(GetLocalPlayer(), whichForce))  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				PingMinimap(x, y, duration);
				//call StartSound(pingMinimapSound)
			}
		}

		//===========================================================================
		public static void PingMinimapLocForForce( BJForce whichForce , BJLocation loc , double duration )
		{
			// Original JassCode
			PingMinimapForForce(whichForce, GetLocationX(loc), GetLocationY(loc), duration);
		}

		//===========================================================================
		public static void PingMinimapForPlayer( BJPlayer whichPlayer , double x , double y , double duration )
		{
			// Original JassCode
			if(  (GetLocalPlayer() == whichPlayer)  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				PingMinimap(x, y, duration);
				//call StartSound(pingMinimapSound)
			}
		}

		//===========================================================================
		public static void PingMinimapLocForPlayer( BJPlayer whichPlayer , BJLocation loc , double duration )
		{
			// Original JassCode
			PingMinimapForPlayer(whichPlayer, GetLocationX(loc), GetLocationY(loc), duration);
		}

		//===========================================================================
		public static void PingMinimapForForceEx( BJForce whichForce , double x , double y , double duration , int style , double red , double green , double blue )
		{
			// Original JassCode
			int red255 = PercentTo255(red);
			int green255 = PercentTo255(green);
			int blue255 = PercentTo255(blue);
			if(  (IsPlayerInForce(GetLocalPlayer(), whichForce))  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				// Prevent 100% red simple and flashy pings, as they become "attack" pings.
				if(  (red255 == 255) && (green255 == 0) && (blue255 == 0)  )
				{
					red255 = 254;
				}
				if(  (style == MINIMAPPINGSTYLE_SIMPLE)  )
				{
					PingMinimapEx(x, y, duration, red255, green255, blue255, false);
				}
				else if(  (style == MINIMAPPINGSTYLE_FLASHY)  )
				{
					PingMinimapEx(x, y, duration, red255, green255, blue255, true);
				}
				else if(  (style == MINIMAPPINGSTYLE_ATTACK)  )
				{
					PingMinimapEx(x, y, duration, 255, 0, 0, false);
				}
				else
				{
					// Unrecognized ping style - ignore the request.
				}
				//call StartSound(pingMinimapSound)
			}
		}

		//===========================================================================
		public static void PingMinimapLocForForceEx( BJForce whichForce , BJLocation loc , double duration , int style , double red , double green , double blue )
		{
			// Original JassCode
			PingMinimapForForceEx(whichForce, GetLocationX(loc), GetLocationY(loc), duration, style, red, green, blue);
		}

		//===========================================================================
		public static void EnableWorldFogBoundaryBJ( bool enable , BJForce f )
		{
			// Original JassCode
			if(  (IsPlayerInForce(GetLocalPlayer(), f))  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				EnableWorldFogBoundary(enable);
			}
		}

		//===========================================================================
		public static void EnableOcclusionBJ( bool enable , BJForce f )
		{
			// Original JassCode
			if(  (IsPlayerInForce(GetLocalPlayer(), f))  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				EnableOcclusion(enable);
			}
		}

		//***************************************************************************
		//*
		//*  Cinematic Transmission Utility Functions
		//*
		//***************************************************************************
		//===========================================================================
		// If cancelled, stop the sound and end the cinematic scene.
		//
		public static void CancelCineSceneBJ(  )
		{
			// Original JassCode
			StopSoundBJ(cineSceneLastSound, true);
			EndCinematicScene();
		}

		//===========================================================================
		// Init a trigger to listen for END_CINEMATIC events and respond to them if
		// a cinematic scene is in progress.  For performance reasons, this should
		// only be called once a cinematic scene has been started, so that maps
		// lacking such scenes do not bother to register for these events.
		//
		public static void TryInitCinematicBehaviorBJ(  )
		{
			// Original JassCode
			int index;
			if(  (cineSceneBeingSkipped == null)  )
			{
				cineSceneBeingSkipped = CreateTrigger();
				index = 0;
				while( true )
				{
					TriggerRegisterPlayerEvent(cineSceneBeingSkipped, Player(index), EVENT_PLAYER_END_CINEMATIC);
					index = index + 1;
					if(  index == MAX_PLAYERS )
						break;
				}
				TriggerAddAction(cineSceneBeingSkipped,  CancelCineSceneBJ);
			}
		}

		//===========================================================================
		public static void SetCinematicSceneBJ( BJSound soundHandle , int portraitUnitId , BJPlayerColor color , string speakerTitle , string text , double sceneDuration , double voiceoverDuration )
		{
			// Original JassCode
			cineSceneLastSound = soundHandle;
			PlaySoundBJ(soundHandle);
			SetCinematicScene(portraitUnitId, color, speakerTitle, text, sceneDuration, voiceoverDuration);
		}

		//===========================================================================
		public static double GetTransmissionDuration( BJSound soundHandle , int timeType , double timeVal )
		{
			// Original JassCode
			double duration;
			if(  (timeType == TIMETYPE_ADD)  )
			{
				duration = GetSoundDurationBJ(soundHandle) + timeVal;
			}
			else if(  (timeType == TIMETYPE_SET)  )
			{
				duration = timeVal;
			}
			else if(  (timeType == TIMETYPE_SUB)  )
			{
				duration = GetSoundDurationBJ(soundHandle) - timeVal;
			}
			else
			{
				// Unrecognized timeType - ignore timeVal.
				duration = GetSoundDurationBJ(soundHandle);
			}
			// Make sure we have a non-negative duration.
			if(  (duration < 0)  )
			{
				duration = 0;
			}
			return duration;
		}

		//===========================================================================
		public static void WaitTransmissionDuration( BJSound soundHandle , int timeType , double timeVal )
		{
			// Original JassCode
			if(  (timeType == TIMETYPE_SET)  )
			{
				// If we have a static duration wait, just perform the wait.
				TriggerSleepAction(timeVal);
			}
			else if(  (soundHandle == null)  )
			{
				// If the sound does not exist, perform a default length wait.
				TriggerSleepAction(NOTHING_SOUND_DURATION);
			}
			else if(  (timeType == TIMETYPE_SUB)  )
			{
				// If the transmission is cutting off the sound, wait for the sound
				// to be mostly finished.
				WaitForSoundBJ(soundHandle, timeVal);
			}
			else if(  (timeType == TIMETYPE_ADD)  )
			{
				// If the transmission is extending beyond the sound's length, wait
				// for it to finish, and then wait the additional time.
				WaitForSoundBJ(soundHandle, 0);
				TriggerSleepAction(timeVal);
			}
			else
			{
				// Unrecognized timeType - ignore.
			}
		}

		//===========================================================================
		public static void DoTransmissionBasicsXYBJ( int unitId , BJPlayerColor color , double x , double y , BJSound soundHandle , string unitName , string message , double duration )
		{
			// Original JassCode
			SetCinematicSceneBJ(soundHandle, unitId, color, unitName, message, duration + TRANSMISSION_PORT_HANGTIME, duration);
			if(  (unitId != 0)  )
			{
				PingMinimap(x, y, TRANSMISSION_PING_TIME);
				//call SetCameraQuickPosition(x, y)
			}
		}

		//===========================================================================
		// Display a text message to a Player Group with an accompanying sound,
		// portrait, speech indicator, and all that good stuff.
		//   - Query duration of sound
		//   - Play sound
		//   - Display text message for duration
		//   - Display animating portrait for duration
		//   - Display a speech indicator for the unit
		//   - Ping the minimap
		//
		public static void TransmissionFromUnitWithNameBJ( BJForce toForce , BJUnit whichUnit , string unitName , BJSound soundHandle , string message , int timeType , double timeVal , bool wait )
		{
			// Original JassCode
			TryInitCinematicBehaviorBJ();
			// Ensure that the time value is non-negative.
			timeVal = RMaxBJ(timeVal, 0);
			lastTransmissionDuration = GetTransmissionDuration(soundHandle, timeType, timeVal);
			lastPlayedSound = soundHandle;
			if(  (IsPlayerInForce(GetLocalPlayer(), toForce))  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				if(  (whichUnit == null)  )
				{
					// If the unit reference is invalid, send the transmission from the center of the map with no portrait.
					DoTransmissionBasicsXYBJ(0, PLAYER_COLOR_RED, 0, 0, soundHandle, unitName, message, lastTransmissionDuration);
				}
				else
				{
					DoTransmissionBasicsXYBJ(GetUnitTypeId(whichUnit), GetPlayerColor(GetOwningPlayer(whichUnit)), GetUnitX(whichUnit), GetUnitY(whichUnit), soundHandle, unitName, message, lastTransmissionDuration);
					if(  (! IsUnitHidden(whichUnit))  )
					{
						UnitAddIndicator(whichUnit, TRANSMISSION_IND_RED, TRANSMISSION_IND_BLUE, TRANSMISSION_IND_GREEN, TRANSMISSION_IND_ALPHA);
					}
				}
			}
			if(  wait && (lastTransmissionDuration > 0)  )
			{
				// call TriggerSleepAction(lastTransmissionDuration)
				WaitTransmissionDuration(soundHandle, timeType, timeVal);
			}
		}

		//===========================================================================
		// This operates like TransmissionFromUnitWithNameBJ, but for a unit type
		// rather than a unit instance.  As such, no speech indicator is employed.
		//
		public static void TransmissionFromUnitTypeWithNameBJ( BJForce toForce , BJPlayer fromPlayer , int unitId , string unitName , BJLocation loc , BJSound soundHandle , string message , int timeType , double timeVal , bool wait )
		{
			// Original JassCode
			TryInitCinematicBehaviorBJ();
			// Ensure that the time value is non-negative.
			timeVal = RMaxBJ(timeVal, 0);
			lastTransmissionDuration = GetTransmissionDuration(soundHandle, timeType, timeVal);
			lastPlayedSound = soundHandle;
			if(  (IsPlayerInForce(GetLocalPlayer(), toForce))  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				DoTransmissionBasicsXYBJ(unitId, GetPlayerColor(fromPlayer), GetLocationX(loc), GetLocationY(loc), soundHandle, unitName, message, lastTransmissionDuration);
			}
			if(  wait && (lastTransmissionDuration > 0)  )
			{
				// call TriggerSleepAction(lastTransmissionDuration)
				WaitTransmissionDuration(soundHandle, timeType, timeVal);
			}
		}

		//===========================================================================
		public static double GetLastTransmissionDurationBJ(  )
		{
			// Original JassCode
			return lastTransmissionDuration;
		}

		//===========================================================================
		public static void ForceCinematicSubtitlesBJ( bool flag )
		{
			// Original JassCode
			ForceCinematicSubtitles(flag);
		}

		//***************************************************************************
		//*
		//*  Cinematic Mode Utility Functions
		//*
		//***************************************************************************
		//===========================================================================
		// Makes many common UI settings changes at once, for use when beginning and
		// ending cinematic sequences.  Note that some affects apply to all players,
		// such as game speed.  This is unavoidable.
		//   - Clear the screen of text messages
		//   - Hide interface UI (letterbox mode)
		//   - Hide game messages (ally under attack, etc.)
		//   - Disable user control
		//   - Disable occlusion
		//   - Set game speed (for all players)
		//   - Lock game speed (for all players)
		//   - Disable black mask (for all players)
		//   - Disable fog of war (for all players)
		//   - Disable world boundary fog (for all players)
		//   - Dim non-speech sound channels
		//   - End any outstanding music themes
		//   - Fix the random seed to a set value
		//   - Reset the camera smoothing factor
		//
		public static void CinematicModeExBJ( bool cineMode , BJForce forForce , double interfaceFadeTime )
		{
			// Original JassCode
			// If the game hasn't started yet, perform interface fades immediately
			if(  (! gameStarted)  )
			{
				interfaceFadeTime = 0;
			}
			if(  (cineMode)  )
			{
				// Save the UI state so that we can restore it later.
				if(  (! cineModeAlreadyIn)  )
				{
					cineModeAlreadyIn = true;
					cineModePriorSpeed = GetGameSpeed();
					cineModePriorFogSetting = IsFogEnabled();
					cineModePriorMaskSetting = IsFogMaskEnabled();
					cineModePriorDawnDusk = IsDawnDuskEnabled();
					cineModeSavedSeed = GetRandomInt(0, 1000000);
				}
				// Perform local changes
				if(  (IsPlayerInForce(GetLocalPlayer(), forForce))  )
				{
					// Use only local code (no net traffic) within this block to avoid desyncs.
					ClearTextMessages();
					ShowInterface(false, interfaceFadeTime);
					EnableUserControl(false);
					EnableOcclusion(false);
					SetCineModeVolumeGroupsBJ();
				}
				// Perform global changes
				SetGameSpeed(CINEMODE_GAMESPEED);
				SetMapFlag(MAP_LOCK_SPEED, true);
				FogMaskEnable(false);
				FogEnable(false);
				EnableWorldFogBoundary(false);
				EnableDawnDusk(false);
				// Use a fixed random seed, so that cinematics play consistently.
				SetRandomSeed(0);
			}
			else
			{
				cineModeAlreadyIn = false;
				// Perform local changes
				if(  (IsPlayerInForce(GetLocalPlayer(), forForce))  )
				{
					// Use only local code (no net traffic) within this block to avoid desyncs.
					ShowInterface(true, interfaceFadeTime);
					EnableUserControl(true);
					EnableOcclusion(true);
					VolumeGroupReset();
					EndThematicMusic();
					CameraResetSmoothingFactorBJ();
				}
				// Perform global changes
				SetMapFlag(MAP_LOCK_SPEED, false);
				SetGameSpeed(cineModePriorSpeed);
				FogMaskEnable(cineModePriorMaskSetting);
				FogEnable(cineModePriorFogSetting);
				EnableWorldFogBoundary(true);
				EnableDawnDusk(cineModePriorDawnDusk);
				SetRandomSeed(cineModeSavedSeed);
			}
		}

		//===========================================================================
		public static void CinematicModeBJ( bool cineMode , BJForce forForce )
		{
			// Original JassCode
			CinematicModeExBJ(cineMode, forForce, CINEMODE_INTERFACEFADE);
		}

		//***************************************************************************
		//*
		//*  Cinematic Filter Utility Functions
		//*
		//***************************************************************************
		//===========================================================================
		public static void DisplayCineFilterBJ( bool flag )
		{
			// Original JassCode
			DisplayCineFilter(flag);
		}

		//===========================================================================
		public static void CinematicFadeCommonBJ( double red , double green , double blue , double duration , string tex , double startTrans , double endTrans )
		{
			// Original JassCode
			if(  (duration == 0)  )
			{
				// If the fade is instant, use the same starting and ending values,
				// so that we effectively do a set rather than a fade.
				startTrans = endTrans;
			}
			EnableUserUI(false);
			SetCineFilterTexture(tex);
			SetCineFilterBlendMode(BLEND_MODE_BLEND);
			SetCineFilterTexMapFlags(TEXMAP_FLAG_NONE);
			SetCineFilterStartUV(0, 0, 1, 1);
			SetCineFilterEndUV(0, 0, 1, 1);
			SetCineFilterStartColor(PercentTo255(red), PercentTo255(green), PercentTo255(blue), PercentTo255(100-startTrans));
			SetCineFilterEndColor(PercentTo255(red), PercentTo255(green), PercentTo255(blue), PercentTo255(100-endTrans));
			SetCineFilterDuration(duration);
			DisplayCineFilter(true);
		}

		//===========================================================================
		public static void FinishCinematicFadeBJ(  )
		{
			// Original JassCode
			DestroyTimer(cineFadeFinishTimer);
			cineFadeFinishTimer = null;
			DisplayCineFilter(false);
			EnableUserUI(true);
		}

		//===========================================================================
		public static void FinishCinematicFadeAfterBJ( double duration )
		{
			// Original JassCode
			// Create a timer to end the cinematic fade.
			cineFadeFinishTimer = CreateTimer();
			TimerStart(cineFadeFinishTimer, duration, false,  FinishCinematicFadeBJ);
		}

		//===========================================================================
		public static void ContinueCinematicFadeBJ(  )
		{
			// Original JassCode
			DestroyTimer(cineFadeContinueTimer);
			cineFadeContinueTimer = null;
			CinematicFadeCommonBJ(cineFadeContinueRed, cineFadeContinueGreen, cineFadeContinueBlue, cineFadeContinueDuration, cineFadeContinueTex, cineFadeContinueTrans, 100);
		}

		//===========================================================================
		public static void ContinueCinematicFadeAfterBJ( double duration , double red , double green , double blue , double trans , string tex )
		{
			// Original JassCode
			cineFadeContinueRed = red;
			cineFadeContinueGreen = green;
			cineFadeContinueBlue = blue;
			cineFadeContinueTrans = trans;
			cineFadeContinueDuration = duration;
			cineFadeContinueTex = tex;
			// Create a timer to continue the cinematic fade.
			cineFadeContinueTimer = CreateTimer();
			TimerStart(cineFadeContinueTimer, duration, false,  ContinueCinematicFadeBJ);
		}

		//===========================================================================
		public static void AbortCinematicFadeBJ(  )
		{
			// Original JassCode
			if(  (cineFadeContinueTimer != null)  )
			{
				DestroyTimer(cineFadeContinueTimer);
			}
			if(  (cineFadeFinishTimer != null)  )
			{
				DestroyTimer(cineFadeFinishTimer);
			}
		}

		//===========================================================================
		public static void CinematicFadeBJ( int fadetype , double duration , string tex , double red , double green , double blue , double trans )
		{
			// Original JassCode
			if(  (fadetype == CINEFADETYPE_FADEOUT)  )
			{
				// Fade out to the requested color.
				AbortCinematicFadeBJ();
				CinematicFadeCommonBJ(red, green, blue, duration, tex, 100, trans);
			}
			else if(  (fadetype == CINEFADETYPE_FADEIN)  )
			{
				// Fade in from the requested color.
				AbortCinematicFadeBJ();
				CinematicFadeCommonBJ(red, green, blue, duration, tex, trans, 100);
				FinishCinematicFadeAfterBJ(duration);
			}
			else if(  (fadetype == CINEFADETYPE_FADEOUTIN)  )
			{
				// Fade out to the requested color, and then fade back in from it.
				if(  (duration > 0)  )
				{
					AbortCinematicFadeBJ();
					CinematicFadeCommonBJ(red, green, blue, duration * 0.5, tex, 100, trans);
					ContinueCinematicFadeAfterBJ(duration * 0.5, red, green, blue, trans, tex);
					FinishCinematicFadeAfterBJ(duration);
				}
			}
			else
			{
				// Unrecognized fadetype - ignore the request.
			}
		}

		//===========================================================================
		public static void CinematicFilterGenericBJ( double duration , BJBlendMode bmode , string tex , double red0 , double green0 , double blue0 , double trans0 , double red1 , double green1 , double blue1 , double trans1 )
		{
			// Original JassCode
			AbortCinematicFadeBJ();
			SetCineFilterTexture(tex);
			SetCineFilterBlendMode(bmode);
			SetCineFilterTexMapFlags(TEXMAP_FLAG_NONE);
			SetCineFilterStartUV(0, 0, 1, 1);
			SetCineFilterEndUV(0, 0, 1, 1);
			SetCineFilterStartColor(PercentTo255(red0), PercentTo255(green0), PercentTo255(blue0), PercentTo255(100-trans0));
			SetCineFilterEndColor(PercentTo255(red1), PercentTo255(green1), PercentTo255(blue1), PercentTo255(100-trans1));
			SetCineFilterDuration(duration);
			DisplayCineFilter(true);
		}

		//***************************************************************************
		//*
		//*  Rescuable Unit Utility Functions
		//*
		//***************************************************************************
		//===========================================================================
		// Rescues a unit for a player.  This performs the default rescue behavior,
		// including a rescue sound, flashing selection circle, ownership change,
		// and optionally a unit color change.
		//
		public static void RescueUnitBJ( BJUnit whichUnit , BJPlayer rescuer , bool changeColor )
		{
			// Original JassCode
			if(  IsUnitDeadBJ(whichUnit) || (GetOwningPlayer(whichUnit) == rescuer)  )
			{
				return;
			}
			StartSound(rescueSound);
			SetUnitOwner(whichUnit, rescuer, changeColor);
			UnitAddIndicator(whichUnit, 0, 255, 0, 255);
			PingMinimapForPlayer(rescuer, GetUnitX(whichUnit), GetUnitY(whichUnit), RESCUE_PING_TIME);
		}

		//===========================================================================
		public static void TriggerActionUnitRescuedBJ(  )
		{
			// Original JassCode
			BJUnit theUnit = GetTriggerUnit();
			if(  IsUnitType(theUnit, UNIT_TYPE_STRUCTURE)  )
			{
				RescueUnitBJ(theUnit, GetOwningPlayer(GetRescuer()), rescueChangeColorBldg);
			}
			else
			{
				RescueUnitBJ(theUnit, GetOwningPlayer(GetRescuer()), rescueChangeColorUnit);
			}
		}

		//===========================================================================
		// Attempt to init triggers for default rescue behavior.  For performance
		// reasons, this should only be attempted if a player is set to Rescuable,
		// or if a specific unit is thus flagged.
		//
		public static void TryInitRescuableTriggersBJ(  )
		{
			// Original JassCode
			int index;
			if(  (rescueUnitBehavior == null)  )
			{
				rescueUnitBehavior = CreateTrigger();
				index = 0;
				while( true )
				{
					TriggerRegisterPlayerUnitEvent(rescueUnitBehavior, Player(index), EVENT_PLAYER_UNIT_RESCUED, null);
					index = index + 1;
					if(  index == MAX_PLAYER_SLOTS )
						break;
				}
				TriggerAddAction(rescueUnitBehavior,  TriggerActionUnitRescuedBJ);
			}
		}

		//===========================================================================
		// Determines whether or not rescued units automatically change color upon
		// being rescued.
		//
		public static void SetRescueUnitColorChangeBJ( bool changeColor )
		{
			// Original JassCode
			rescueChangeColorUnit = changeColor;
		}

		//===========================================================================
		// Determines whether or not rescued buildings automatically change color
		// upon being rescued.
		//
		public static void SetRescueBuildingColorChangeBJ( bool changeColor )
		{
			// Original JassCode
			rescueChangeColorBldg = changeColor;
		}

		//===========================================================================
		public static void MakeUnitRescuableToForceBJEnum(  )
		{
			// Original JassCode
			TryInitRescuableTriggersBJ();
			SetUnitRescuable(makeUnitRescuableUnit, GetEnumPlayer(), makeUnitRescuableFlag);
		}

		//===========================================================================
		public static void MakeUnitRescuableToForceBJ( BJUnit whichUnit , bool isRescuable , BJForce whichForce )
		{
			// Original JassCode
			// Flag the unit as rescuable/unrescuable for the appropriate players.
			makeUnitRescuableUnit = whichUnit;
			makeUnitRescuableFlag = isRescuable;
			ForForce(whichForce,  MakeUnitRescuableToForceBJEnum);
		}

		//===========================================================================
		public static void InitRescuableBehaviorBJ(  )
		{
			// Original JassCode
			int index;
			index = 0;
			while( true )
			{
				// If at least one player slot is "Rescuable"-controlled, init the
				// rescue behavior triggers.
				if(  (GetPlayerController(Player(index)) == MAP_CONTROL_RESCUABLE)  )
				{
					TryInitRescuableTriggersBJ();
					return;
				}
				index = index + 1;
				if(  index == MAX_PLAYERS )
					break;
			}
		}

		//***************************************************************************
		//*
		//*  Research and Upgrade Utility Functions
		//*
		//***************************************************************************
		//===========================================================================
		public static void SetPlayerTechResearchedSwap( int techid , int levels , BJPlayer whichPlayer )
		{
			// Original JassCode
			SetPlayerTechResearched(whichPlayer, techid, levels);
		}

		//===========================================================================
		public static void SetPlayerTechMaxAllowedSwap( int techid , int maximum , BJPlayer whichPlayer )
		{
			// Original JassCode
			SetPlayerTechMaxAllowed(whichPlayer, techid, maximum);
		}

		//===========================================================================
		public static void SetPlayerMaxHeroesAllowed( int maximum , BJPlayer whichPlayer )
		{
			// Original JassCode
			SetPlayerTechMaxAllowed(whichPlayer, UnitId( "HERO" ), maximum);
		}

		//===========================================================================
		public static int GetPlayerTechCountSimple( int techid , BJPlayer whichPlayer )
		{
			// Original JassCode
			return GetPlayerTechCount(whichPlayer, techid, true);
		}

		//===========================================================================
		public static int GetPlayerTechMaxAllowedSwap( int techid , BJPlayer whichPlayer )
		{
			// Original JassCode
			return GetPlayerTechMaxAllowed(whichPlayer, techid);
		}

		//===========================================================================
		public static void SetPlayerAbilityAvailableBJ( bool avail , int abilid , BJPlayer whichPlayer )
		{
			// Original JassCode
			SetPlayerAbilityAvailable(whichPlayer, abilid, avail);
		}

		//***************************************************************************
		//*
		//*  Campaign Utility Functions
		//*
		//***************************************************************************
		public static void SetCampaignMenuRaceBJ( int campaignNumber )
		{
			// Original JassCode
			if(  (campaignNumber == CAMPAIGN_INDEX_T)  )
			{
				SetCampaignMenuRace(RACE_OTHER);
			}
			else if(  (campaignNumber == CAMPAIGN_INDEX_H)  )
			{
				SetCampaignMenuRace(RACE_HUMAN);
			}
			else if(  (campaignNumber == CAMPAIGN_INDEX_U)  )
			{
				SetCampaignMenuRace(RACE_UNDEAD);
			}
			else if(  (campaignNumber == CAMPAIGN_INDEX_O)  )
			{
				SetCampaignMenuRace(RACE_ORC);
			}
			else if(  (campaignNumber == CAMPAIGN_INDEX_N)  )
			{
				SetCampaignMenuRace(RACE_NIGHTELF);
			}
			else if(  (campaignNumber == CAMPAIGN_INDEX_XN)  )
			{
				SetCampaignMenuRaceEx(CAMPAIGN_OFFSET_XN);
			}
			else if(  (campaignNumber == CAMPAIGN_INDEX_XH)  )
			{
				SetCampaignMenuRaceEx(CAMPAIGN_OFFSET_XH);
			}
			else if(  (campaignNumber == CAMPAIGN_INDEX_XU)  )
			{
				SetCampaignMenuRaceEx(CAMPAIGN_OFFSET_XU);
			}
			else if(  (campaignNumber == CAMPAIGN_INDEX_XO)  )
			{
				SetCampaignMenuRaceEx(CAMPAIGN_OFFSET_XO);
			}
			else
			{
				// Unrecognized campaign - ignore the request
			}
		}

		//===========================================================================
		// Converts a single campaign mission designation into campaign and mission
		// numbers.  The 1000's digit is considered the campaign index, and the 1's
		// digit is considered the mission index within that campaign.  This is done
		// so that the trigger for this can use a single drop-down to list all of
		// the campaign missions.
		//
		public static void SetMissionAvailableBJ( bool available , int missionIndex )
		{
			// Original JassCode
			int campaignNumber = missionIndex / 1000;
			int missionNumber = missionIndex - campaignNumber * 1000;
			SetMissionAvailable(campaignNumber, missionNumber, available);
		}

		//===========================================================================
		public static void SetCampaignAvailableBJ( bool available , int campaignNumber )
		{
			// Original JassCode
			int campaignOffset;
			if(  (campaignNumber == CAMPAIGN_INDEX_H)  )
			{
				SetTutorialCleared(true);
			}
			if(  (campaignNumber == CAMPAIGN_INDEX_XN)  )
			{
				campaignOffset = CAMPAIGN_OFFSET_XN;
			}
			else if(  (campaignNumber == CAMPAIGN_INDEX_XH)  )
			{
				campaignOffset = CAMPAIGN_OFFSET_XH;
			}
			else if(  (campaignNumber == CAMPAIGN_INDEX_XU)  )
			{
				campaignOffset = CAMPAIGN_OFFSET_XU;
			}
			else if(  (campaignNumber == CAMPAIGN_INDEX_XO)  )
			{
				campaignOffset = CAMPAIGN_OFFSET_XO;
			}
			else
			{
				campaignOffset = campaignNumber;
			}
			SetCampaignAvailable(campaignOffset, available);
			SetCampaignMenuRaceBJ(campaignNumber);
			ForceCampaignSelectScreen();
		}

		//===========================================================================
		public static void SetCinematicAvailableBJ( bool available , int cinematicIndex )
		{
			// Original JassCode
			if(  ( cinematicIndex == CINEMATICINDEX_TOP )  )
			{
				SetOpCinematicAvailable( CAMPAIGN_INDEX_T, available );
				PlayCinematic( "TutorialOp" );
			}
			else if(  (cinematicIndex == CINEMATICINDEX_HOP)  )
			{
				SetOpCinematicAvailable( CAMPAIGN_INDEX_H, available );
				PlayCinematic( "HumanOp" );
			}
			else if(  (cinematicIndex == CINEMATICINDEX_HED)  )
			{
				SetEdCinematicAvailable( CAMPAIGN_INDEX_H, available );
				PlayCinematic( "HumanEd" );
			}
			else if(  (cinematicIndex == CINEMATICINDEX_OOP)  )
			{
				SetOpCinematicAvailable( CAMPAIGN_INDEX_O, available );
				PlayCinematic( "OrcOp" );
			}
			else if(  (cinematicIndex == CINEMATICINDEX_OED)  )
			{
				SetEdCinematicAvailable( CAMPAIGN_INDEX_O, available );
				PlayCinematic( "OrcEd" );
			}
			else if(  (cinematicIndex == CINEMATICINDEX_UOP)  )
			{
				SetEdCinematicAvailable( CAMPAIGN_INDEX_U, available );
				PlayCinematic( "UndeadOp" );
			}
			else if(  (cinematicIndex == CINEMATICINDEX_UED)  )
			{
				SetEdCinematicAvailable( CAMPAIGN_INDEX_U, available );
				PlayCinematic( "UndeadEd" );
			}
			else if(  (cinematicIndex == CINEMATICINDEX_NOP)  )
			{
				SetEdCinematicAvailable( CAMPAIGN_INDEX_N, available );
				PlayCinematic( "NightElfOp" );
			}
			else if(  (cinematicIndex == CINEMATICINDEX_NED)  )
			{
				SetEdCinematicAvailable( CAMPAIGN_INDEX_N, available );
				PlayCinematic( "NightElfEd" );
			}
			else if(  (cinematicIndex == CINEMATICINDEX_XOP)  )
			{
				SetOpCinematicAvailable( CAMPAIGN_OFFSET_XN, available );
				PlayCinematic( "IntroX" );
			}
			else if(  (cinematicIndex == CINEMATICINDEX_XED)  )
			{
				SetEdCinematicAvailable( CAMPAIGN_OFFSET_XU, available );
				PlayCinematic( "OutroX" );
			}
			else
			{
				// Unrecognized cinematic - ignore the request.
			}
		}

		//===========================================================================
		public static BJGameCache InitGameCacheBJ( string campaignFile )
		{
			// Original JassCode
			lastCreatedGameCache = InitGameCache(campaignFile);
			return lastCreatedGameCache;
		}

		//===========================================================================
		public static bool SaveGameCacheBJ( BJGameCache cache )
		{
			// Original JassCode
			return SaveGameCache(cache);
		}

		//===========================================================================
		public static BJGameCache GetLastCreatedGameCacheBJ(  )
		{
			// Original JassCode
			return lastCreatedGameCache;
		}

		//===========================================================================
		public static void StoreRealBJ( double value , string key , string missionKey , BJGameCache cache )
		{
			// Original JassCode
			StoreReal(cache, missionKey, key, value);
		}

		//===========================================================================
		public static void StoreIntegerBJ( int value , string key , string missionKey , BJGameCache cache )
		{
			// Original JassCode
			StoreInteger(cache, missionKey, key, value);
		}

		//===========================================================================
		public static void StoreBooleanBJ( bool value , string key , string missionKey , BJGameCache cache )
		{
			// Original JassCode
			StoreBoolean(cache, missionKey, key, value);
		}

		//===========================================================================
		public static bool StoreStringBJ( string value , string key , string missionKey , BJGameCache cache )
		{
			// Original JassCode
			return StoreString(cache, missionKey, key, value);
		}

		//===========================================================================
		public static bool StoreUnitBJ( BJUnit whichUnit , string key , string missionKey , BJGameCache cache )
		{
			// Original JassCode
			return StoreUnit(cache, missionKey, key, whichUnit);
		}

		//===========================================================================
		public static double GetStoredRealBJ( string key , string missionKey , BJGameCache cache )
		{
			// Original JassCode
			//call SyncStoredReal(cache, missionKey, key)
			return GetStoredReal(cache, missionKey, key);
		}

		//===========================================================================
		public static int GetStoredIntegerBJ( string key , string missionKey , BJGameCache cache )
		{
			// Original JassCode
			//call SyncStoredInteger(cache, missionKey, key)
			return GetStoredInteger(cache, missionKey, key);
		}

		//===========================================================================
		public static bool GetStoredBooleanBJ( string key , string missionKey , BJGameCache cache )
		{
			// Original JassCode
			//call SyncStoredBoolean(cache, missionKey, key)
			return GetStoredBoolean(cache, missionKey, key);
		}

		//===========================================================================
		public static string GetStoredStringBJ( string key , string missionKey , BJGameCache cache )
		{
			// Original JassCode
			string s;
			//call SyncStoredString(cache, missionKey, key)
			s = GetStoredString(cache, missionKey, key);
			if(  (s == null)  )
			{
				return "";
			}
			else
			{
				return s;
			}
		}

		//===========================================================================
		public static BJUnit RestoreUnitLocFacingAngleBJ( string key , string missionKey , BJGameCache cache , BJPlayer forWhichPlayer , BJLocation loc , double facing )
		{
			// Original JassCode
			//call SyncStoredUnit(cache, missionKey, key)
			lastLoadedUnit = RestoreUnit(cache, missionKey, key, forWhichPlayer, GetLocationX(loc), GetLocationY(loc), facing);
			return lastLoadedUnit;
		}

		//===========================================================================
		public static BJUnit RestoreUnitLocFacingPointBJ( string key , string missionKey , BJGameCache cache , BJPlayer forWhichPlayer , BJLocation loc , BJLocation lookAt )
		{
			// Original JassCode
			//call SyncStoredUnit(cache, missionKey, key)
			return RestoreUnitLocFacingAngleBJ(key, missionKey, cache, forWhichPlayer, loc, AngleBetweenPoints(loc, lookAt));
		}

		//===========================================================================
		public static BJUnit GetLastRestoredUnitBJ(  )
		{
			// Original JassCode
			return lastLoadedUnit;
		}

		//===========================================================================
		public static void FlushGameCacheBJ( BJGameCache cache )
		{
			// Original JassCode
			FlushGameCache(cache);
		}

		//===========================================================================
		public static void FlushStoredMissionBJ( string missionKey , BJGameCache cache )
		{
			// Original JassCode
			FlushStoredMission(cache, missionKey);
		}

		//===========================================================================
		public static bool HaveStoredValue( string key , int valueType , string missionKey , BJGameCache cache )
		{
			// Original JassCode
			if(  (valueType == GAMECACHE_BOOLEAN)  )
			{
				return HaveStoredBoolean(cache, missionKey, key);
			}
			else if(  (valueType == GAMECACHE_INTEGER)  )
			{
				return HaveStoredInteger(cache, missionKey, key);
			}
			else if(  (valueType == GAMECACHE_REAL)  )
			{
				return HaveStoredReal(cache, missionKey, key);
			}
			else if(  (valueType == GAMECACHE_UNIT)  )
			{
				return HaveStoredUnit(cache, missionKey, key);
			}
			else if(  (valueType == GAMECACHE_STRING)  )
			{
				return HaveStoredString(cache, missionKey, key);
			}
			else
			{
				// Unrecognized value type - ignore the request.
				return false;
			}
		}

		//===========================================================================
		public static void ShowCustomCampaignButton( bool show , int whichButton )
		{
			// Original JassCode
			SetCustomCampaignButtonVisible(whichButton - 1, show);
		}

		//===========================================================================
		public static bool IsCustomCampaignButtonVisibile( int whichButton )
		{
			// Original JassCode
			return GetCustomCampaignButtonVisible(whichButton - 1);
		}

		//===========================================================================
		public static void LoadGameBJ( string loadFileName , bool doScoreScreen )
		{
			// Original JassCode
			LoadGame(loadFileName, doScoreScreen);
		}

		//===========================================================================
		public static void SaveAndChangeLevelBJ( string saveFileName , string newLevel , bool doScoreScreen )
		{
			// Original JassCode
			SaveGame(saveFileName);
			ChangeLevel(newLevel, doScoreScreen);
		}

		//===========================================================================
		public static void SaveAndLoadGameBJ( string saveFileName , string loadFileName , bool doScoreScreen )
		{
			// Original JassCode
			SaveGame(saveFileName);
			LoadGame(loadFileName, doScoreScreen);
		}

		//===========================================================================
		public static bool RenameSaveDirectoryBJ( string sourceDirName , string destDirName )
		{
			// Original JassCode
			return RenameSaveDirectory(sourceDirName, destDirName);
		}

		//===========================================================================
		public static bool RemoveSaveDirectoryBJ( string sourceDirName )
		{
			// Original JassCode
			return RemoveSaveDirectory(sourceDirName);
		}

		//===========================================================================
		public static bool CopySaveGameBJ( string sourceSaveName , string destSaveName )
		{
			// Original JassCode
			return CopySaveGame(sourceSaveName, destSaveName);
		}

		//***************************************************************************
		//*
		//*  Miscellaneous Utility Functions
		//*
		//***************************************************************************
		//===========================================================================
		public static double GetPlayerStartLocationX( BJPlayer whichPlayer )
		{
			// Original JassCode
			return GetStartLocationX(GetPlayerStartLocation(whichPlayer));
		}

		//===========================================================================
		public static double GetPlayerStartLocationY( BJPlayer whichPlayer )
		{
			// Original JassCode
			return GetStartLocationY(GetPlayerStartLocation(whichPlayer));
		}

		//===========================================================================
		public static BJLocation GetPlayerStartLocationLoc( BJPlayer whichPlayer )
		{
			// Original JassCode
			return GetStartLocationLoc(GetPlayerStartLocation(whichPlayer));
		}

		//===========================================================================
		public static BJLocation GetRectCenter( BJRect whichRect )
		{
			// Original JassCode
			return Location(GetRectCenterX(whichRect), GetRectCenterY(whichRect));
		}

		//===========================================================================
		public static bool IsPlayerSlotState( BJPlayer whichPlayer , BJPlayerSlotState whichState )
		{
			// Original JassCode
			return GetPlayerSlotState(whichPlayer) == whichState;
		}

		//===========================================================================
		public static int GetFadeFromSeconds( double seconds )
		{
			// Original JassCode
			if(  (seconds != 0)  )
			{
				return (int)( 128 / seconds );
			}
			else
			{
				return 10000;
			}
		}

		//===========================================================================
		public static void AdjustPlayerStateSimpleBJ( BJPlayer whichPlayer , BJPlayerState whichPlayerState , int delta )
		{
			// Original JassCode
			SetPlayerState(whichPlayer, whichPlayerState, GetPlayerState(whichPlayer, whichPlayerState) + delta);
		}

		//===========================================================================
		public static void AdjustPlayerStateBJ( int delta , BJPlayer whichPlayer , BJPlayerState whichPlayerState )
		{
			// Original JassCode
			// If the change was positive, apply the difference to the player's
			// gathered resources property as well.
			if(  (delta > 0)  )
			{
				if(  (whichPlayerState == PLAYER_STATE_RESOURCE_GOLD)  )
				{
					AdjustPlayerStateSimpleBJ(whichPlayer, PLAYER_STATE_GOLD_GATHERED, delta);
				}
				else if(  (whichPlayerState == PLAYER_STATE_RESOURCE_LUMBER)  )
				{
					AdjustPlayerStateSimpleBJ(whichPlayer, PLAYER_STATE_LUMBER_GATHERED, delta);
				}
			}
			AdjustPlayerStateSimpleBJ(whichPlayer, whichPlayerState, delta);
		}

		//===========================================================================
		public static void SetPlayerStateBJ( BJPlayer whichPlayer , BJPlayerState whichPlayerState , int value )
		{
			// Original JassCode
			int oldValue = GetPlayerState(whichPlayer, whichPlayerState);
			AdjustPlayerStateBJ(value - oldValue, whichPlayer, whichPlayerState);
		}

		//===========================================================================
		public static void SetPlayerFlagBJ( BJPlayerState whichPlayerFlag , bool flag , BJPlayer whichPlayer )
		{
			// Original JassCode
			SetPlayerState(whichPlayer, whichPlayerFlag, IntegerTertiaryOp(flag, 1, 0));
		}

		//===========================================================================
		public static bool IsPlayerFlagSetBJ( BJPlayerState whichPlayerFlag , BJPlayer whichPlayer )
		{
			// Original JassCode
			return GetPlayerState(whichPlayer, whichPlayerFlag) == 1;
		}

		//===========================================================================
		public static void AddResourceAmountBJ( int delta , BJUnit whichUnit )
		{
			// Original JassCode
			AddResourceAmount(whichUnit, delta);
		}

		//===========================================================================
		public static int GetConvertedPlayerId( BJPlayer whichPlayer )
		{
			// Original JassCode
			return GetPlayerId(whichPlayer) + 1;
		}

		//===========================================================================
		public static BJPlayer ConvertedPlayer( int convertedPlayerId )
		{
			// Original JassCode
			return Player(convertedPlayerId - 1);
		}

		//===========================================================================
		public static double GetRectWidthBJ( BJRect r )
		{
			// Original JassCode
			return GetRectMaxX(r) - GetRectMinX(r);
		}

		//===========================================================================
		public static double GetRectHeightBJ( BJRect r )
		{
			// Original JassCode
			return GetRectMaxY(r) - GetRectMinY(r);
		}

		//===========================================================================
		// Replaces a gold mine with a blighted gold mine for the given player.
		//
		public static BJUnit BlightGoldMineForPlayerBJ( BJUnit goldMine , BJPlayer whichPlayer )
		{
			// Original JassCode
			double mineX;
			double mineY;
			int mineGold;
			BJUnit newMine;
			// Make sure we're replacing a Gold Mine and not some other type of unit.
			if(  GetUnitTypeId(goldMine) != UnitId( "ngol" )  )
			{
				return null;
			}
			// Save the Gold Mine's properties and remove it.
			mineX = GetUnitX(goldMine);
			mineY = GetUnitY(goldMine);
			mineGold = GetResourceAmount(goldMine);
			RemoveUnit(goldMine);
			// Create a Haunted Gold Mine to replace the Gold Mine.
			newMine = CreateBlightedGoldmine(whichPlayer, mineX, mineY, UNIT_FACING);
			SetResourceAmount(newMine, mineGold);
			return newMine;
		}

		//===========================================================================
		public static BJUnit BlightGoldMineForPlayer( BJUnit goldMine , BJPlayer whichPlayer )
		{
			// Original JassCode
			lastHauntedGoldMine = BlightGoldMineForPlayerBJ(goldMine, whichPlayer);
			return lastHauntedGoldMine;
		}

		//===========================================================================
		public static BJUnit GetLastHauntedGoldMine(  )
		{
			// Original JassCode
			return lastHauntedGoldMine;
		}

		//===========================================================================
		public static void SetPlayerColorBJEnum(  )
		{
			// Original JassCode
			SetUnitColor(GetEnumUnit(), setPlayerTargetColor);
		}

		//===========================================================================
		public static void SetPlayerColorBJ( BJPlayer whichPlayer , BJPlayerColor color , bool changeExisting )
		{
			// Original JassCode
			BJGroup g;
			SetPlayerColor(whichPlayer, color);
			if(  changeExisting  )
			{
				setPlayerTargetColor = color;
				g = CreateGroup();
				GroupEnumUnitsOfPlayer(g, whichPlayer, null);
				ForGroup(g,  SetPlayerColorBJEnum);
				DestroyGroup(g);
			}
		}

		//===========================================================================
		public static void SetPlayerUnitAvailableBJ( int unitId , bool allowed , BJPlayer whichPlayer )
		{
			// Original JassCode
			if(  allowed  )
			{
				SetPlayerTechMaxAllowed(whichPlayer, unitId, -1);
			}
			else
			{
				SetPlayerTechMaxAllowed(whichPlayer, unitId, 0);
			}
		}

		//===========================================================================
		public static void LockGameSpeedBJ(  )
		{
			// Original JassCode
			SetMapFlag(MAP_LOCK_SPEED, true);
		}

		//===========================================================================
		public static void UnlockGameSpeedBJ(  )
		{
			// Original JassCode
			SetMapFlag(MAP_LOCK_SPEED, false);
		}

		//===========================================================================
		public static bool IssueTargetOrderBJ( BJUnit whichUnit , string order , BJWidget targetWidget )
		{
			// Original JassCode
			return IssueTargetOrder( whichUnit, order, targetWidget );
		}

		//===========================================================================
		public static bool IssuePointOrderLocBJ( BJUnit whichUnit , string order , BJLocation whichLocation )
		{
			// Original JassCode
			return IssuePointOrderLoc( whichUnit, order, whichLocation );
		}

		//===========================================================================
		// Two distinct trigger actions can't share the same function name, so this
		// dummy function simply mimics the behavior of an existing call.
		//
		public static bool IssueTargetDestructableOrder( BJUnit whichUnit , string order , BJWidget targetWidget )
		{
			// Original JassCode
			return IssueTargetOrder( whichUnit, order, targetWidget );
		}

		//===========================================================================
		public static bool IssueImmediateOrderBJ( BJUnit whichUnit , string order )
		{
			// Original JassCode
			return IssueImmediateOrder( whichUnit, order );
		}

		//===========================================================================
		public static bool GroupTargetOrderBJ( BJGroup whichGroup , string order , BJWidget targetWidget )
		{
			// Original JassCode
			return GroupTargetOrder( whichGroup, order, targetWidget );
		}

		//===========================================================================
		public static bool GroupPointOrderLocBJ( BJGroup whichGroup , string order , BJLocation whichLocation )
		{
			// Original JassCode
			return GroupPointOrderLoc( whichGroup, order, whichLocation );
		}

		//===========================================================================
		public static bool GroupImmediateOrderBJ( BJGroup whichGroup , string order )
		{
			// Original JassCode
			return GroupImmediateOrder( whichGroup, order );
		}

		//===========================================================================
		// Two distinct trigger actions can't share the same function name, so this
		// dummy function simply mimics the behavior of an existing call.
		//
		public static bool GroupTargetDestructableOrder( BJGroup whichGroup , string order , BJWidget targetWidget )
		{
			// Original JassCode
			return GroupTargetOrder( whichGroup, order, targetWidget );
		}

		//===========================================================================
		public static BJDestructAble GetDyingDestructable(  )
		{
			// Original JassCode
			return (BJDestructAble)GetTriggerWidget();
		}

		//===========================================================================
		// Utility function for use by editor-generated item drop table triggers.
		// This function is added as an action to all destructable drop triggers,
		// so that a widget drop may be differentiated from a unit drop.
		//
		public static void SaveDyingWidget(  )
		{
			// Original JassCode
			lastDyingWidget = GetTriggerWidget();
		}

		//===========================================================================
		public static void SetBlightRectBJ( bool addBlight , BJPlayer whichPlayer , BJRect r )
		{
			// Original JassCode
			SetBlightRect(whichPlayer, r, addBlight);
		}

		//===========================================================================
		public static void SetBlightRadiusLocBJ( bool addBlight , BJPlayer whichPlayer , BJLocation loc , double radius )
		{
			// Original JassCode
			SetBlightLoc(whichPlayer, loc, radius, addBlight);
		}

		//***************************************************************************
		//*
		//*  Melee Template Visibility Settings
		//*
		//***************************************************************************
		//===========================================================================
		public static void MeleeStartingVisibility(  )
		{
			// Original JassCode
			// Start by setting the ToD.
			SetFloatGameState(GAME_STATE_TIME_OF_DAY, MELEE_STARTING_TOD);
			// call FogMaskEnable(true)
			// call FogEnable(true)
		}

		//***************************************************************************
		//*
		//*  Melee Template Starting Resources
		//*
		//***************************************************************************
		//===========================================================================
		public static void MeleeStartingResources(  )
		{
			// Original JassCode
			int index;
			BJPlayer indexPlayer;
			BJVersion v;
			int startingGold;
			int startingLumber;
			v = VersionGet();
			if(  (v == VERSION_REIGN_OF_CHAOS)  )
			{
				startingGold = MELEE_STARTING_GOLD_V0;
				startingLumber = MELEE_STARTING_LUMBER_V0;
			}
			else
			{
				startingGold = MELEE_STARTING_GOLD_V1;
				startingLumber = MELEE_STARTING_LUMBER_V1;
			}
			// Set each player's starting resources.
			index = 0;
			while( true )
			{
				indexPlayer = Player(index);
				if(  (GetPlayerSlotState(indexPlayer) == PLAYER_SLOT_STATE_PLAYING)  )
				{
					SetPlayerState(indexPlayer, PLAYER_STATE_RESOURCE_GOLD, startingGold);
					SetPlayerState(indexPlayer, PLAYER_STATE_RESOURCE_LUMBER, startingLumber);
				}
				index = index + 1;
				if(  index == MAX_PLAYERS )
					break;
			}
		}

		//***************************************************************************
		//*
		//*  Melee Template Hero Limit
		//*
		//***************************************************************************
		//===========================================================================
		public static void ReducePlayerTechMaxAllowed( BJPlayer whichPlayer , int techId , int limit )
		{
			// Original JassCode
			int oldMax = GetPlayerTechMaxAllowed(whichPlayer, techId);
			// A value of -1 is used to indicate no limit, so check for that as well.
			if(  (oldMax < 0 || oldMax > limit)  )
			{
				SetPlayerTechMaxAllowed(whichPlayer, techId, limit);
			}
		}

		//===========================================================================
		public static void MeleeStartingHeroLimit(  )
		{
			// Original JassCode
			int index;
			index = 0;
			while( true )
			{
				// max heroes per player
				SetPlayerMaxHeroesAllowed(MELEE_HERO_LIMIT, Player(index));
				// each player is restricted to a limit per hero type as well
				ReducePlayerTechMaxAllowed(Player(index), UnitId( "Hamg" ), MELEE_HERO_TYPE_LIMIT);
				ReducePlayerTechMaxAllowed(Player(index), UnitId( "Hmkg" ), MELEE_HERO_TYPE_LIMIT);
				ReducePlayerTechMaxAllowed(Player(index), UnitId( "Hpal" ), MELEE_HERO_TYPE_LIMIT);
				ReducePlayerTechMaxAllowed(Player(index), UnitId( "Hblm" ), MELEE_HERO_TYPE_LIMIT);
				ReducePlayerTechMaxAllowed(Player(index), UnitId( "Obla" ), MELEE_HERO_TYPE_LIMIT);
				ReducePlayerTechMaxAllowed(Player(index), UnitId( "Ofar" ), MELEE_HERO_TYPE_LIMIT);
				ReducePlayerTechMaxAllowed(Player(index), UnitId( "Otch" ), MELEE_HERO_TYPE_LIMIT);
				ReducePlayerTechMaxAllowed(Player(index), UnitId( "Oshd" ), MELEE_HERO_TYPE_LIMIT);
				ReducePlayerTechMaxAllowed(Player(index), UnitId( "Edem" ), MELEE_HERO_TYPE_LIMIT);
				ReducePlayerTechMaxAllowed(Player(index), UnitId( "Ekee" ), MELEE_HERO_TYPE_LIMIT);
				ReducePlayerTechMaxAllowed(Player(index), UnitId( "Emoo" ), MELEE_HERO_TYPE_LIMIT);
				ReducePlayerTechMaxAllowed(Player(index), UnitId( "Ewar" ), MELEE_HERO_TYPE_LIMIT);
				ReducePlayerTechMaxAllowed(Player(index), UnitId( "Udea" ), MELEE_HERO_TYPE_LIMIT);
				ReducePlayerTechMaxAllowed(Player(index), UnitId( "Udre" ), MELEE_HERO_TYPE_LIMIT);
				ReducePlayerTechMaxAllowed(Player(index), UnitId( "Ulic" ), MELEE_HERO_TYPE_LIMIT);
				ReducePlayerTechMaxAllowed(Player(index), UnitId( "Ucrl" ), MELEE_HERO_TYPE_LIMIT);
				ReducePlayerTechMaxAllowed(Player(index), UnitId( "Npbm" ), MELEE_HERO_TYPE_LIMIT);
				ReducePlayerTechMaxAllowed(Player(index), UnitId( "Nbrn" ), MELEE_HERO_TYPE_LIMIT);
				ReducePlayerTechMaxAllowed(Player(index), UnitId( "Nngs" ), MELEE_HERO_TYPE_LIMIT);
				ReducePlayerTechMaxAllowed(Player(index), UnitId( "Nplh" ), MELEE_HERO_TYPE_LIMIT);
				ReducePlayerTechMaxAllowed(Player(index), UnitId( "Nbst" ), MELEE_HERO_TYPE_LIMIT);
				index = index + 1;
				if(  index == MAX_PLAYERS )
					break;
			}
		}

		//***************************************************************************
		//*
		//*  Melee Template Granted Hero Items
		//*
		//***************************************************************************
		//===========================================================================
		public static bool MeleeTrainedUnitIsHeroBJFilter(  )
		{
			// Original JassCode
			return IsUnitType(GetFilterUnit(), UNIT_TYPE_HERO);
		}

		//===========================================================================
		// The first N heroes trained or hired for each player start off with a
		// standard set of items.  This is currently:
		//   - 1x Scroll of Town Portal
		//
		public static void MeleeGrantItemsToHero( BJUnit whichUnit )
		{
			// Original JassCode
			int owner = GetPlayerId(GetOwningPlayer(whichUnit));
			// If we haven't twinked N heroes for this player yet, twink away.
			if(  (meleeTwinkedHeroes[owner] < MELEE_MAX_TWINKED_HEROES)  )
			{
				UnitAddItemById(whichUnit, UnitId( "stwp" ));
				meleeTwinkedHeroes[owner] = meleeTwinkedHeroes[owner] + 1;
			}
		}

		//===========================================================================
		public static void MeleeGrantItemsToTrainedHero(  )
		{
			// Original JassCode
			MeleeGrantItemsToHero(GetTrainedUnit());
		}

		//===========================================================================
		public static void MeleeGrantItemsToHiredHero(  )
		{
			// Original JassCode
			MeleeGrantItemsToHero(GetSoldUnit());
		}

		//===========================================================================
		public static void MeleeGrantHeroItems(  )
		{
			// Original JassCode
			int index;
			BJTrigger trig;
			// Initialize the twinked hero counts.
			index = 0;
			while( true )
			{
				meleeTwinkedHeroes[index] = 0;
				index = index + 1;
				if(  index == MAX_PLAYER_SLOTS )
					break;
			}
			// Register for an event whenever a hero is trained, so that we can give
			// him/her their starting items.
			index = 0;
			while( true )
			{
				trig = CreateTrigger();
				TriggerRegisterPlayerUnitEvent(trig, Player(index), EVENT_PLAYER_UNIT_TRAIN_FINISH, filterMeleeTrainedUnitIsHeroBJ);
				TriggerAddAction(trig,  MeleeGrantItemsToTrainedHero);
				index = index + 1;
				if(  index == MAX_PLAYERS )
					break;
			}
			// Register for an event whenever a neutral hero is hired, so that we
			// can give him/her their starting items.
			trig = CreateTrigger();
			TriggerRegisterPlayerUnitEvent(trig, Player(PLAYER_NEUTRAL_PASSIVE), EVENT_PLAYER_UNIT_SELL, filterMeleeTrainedUnitIsHeroBJ);
			TriggerAddAction(trig,  MeleeGrantItemsToHiredHero);
			// Flag that we are giving starting items to heroes, so that the melee
			// starting units code can create them as necessary.
			meleeGrantHeroItems = true;
		}

		//***************************************************************************
		//*
		//*  Melee Template Clear Start Locations
		//*
		//***************************************************************************
		//===========================================================================
		public static void MeleeClearExcessUnit(  )
		{
			// Original JassCode
			BJUnit theUnit = GetEnumUnit();
			int owner = GetPlayerId(GetOwningPlayer(theUnit));
			if(  (owner == PLAYER_NEUTRAL_AGGRESSIVE)  )
			{
				// Remove any Neutral Hostile units from the area.
				RemoveUnit(GetEnumUnit());
			}
			else if(  (owner == PLAYER_NEUTRAL_PASSIVE)  )
			{
				// Remove non-structure Neutral Passive units from the area.
				if(  ! IsUnitType(theUnit, UNIT_TYPE_STRUCTURE)  )
				{
					RemoveUnit(GetEnumUnit());
				}
			}
		}

		//===========================================================================
		public static void MeleeClearNearbyUnits( double x , double y , double range )
		{
			// Original JassCode
			BJGroup nearbyUnits;
			nearbyUnits = CreateGroup();
			GroupEnumUnitsInRange(nearbyUnits, x, y, range, null);
			ForGroup(nearbyUnits,  MeleeClearExcessUnit);
			DestroyGroup(nearbyUnits);
		}

		//===========================================================================
		public static void MeleeClearExcessUnits(  )
		{
			// Original JassCode
			int index;
			double locX;
			double locY;
			BJPlayer indexPlayer;
			index = 0;
			while( true )
			{
				indexPlayer = Player(index);
				// If the player slot is being used, clear any nearby creeps.
				if(  (GetPlayerSlotState(indexPlayer) == PLAYER_SLOT_STATE_PLAYING)  )
				{
					locX = GetStartLocationX(GetPlayerStartLocation(indexPlayer));
					locY = GetStartLocationY(GetPlayerStartLocation(indexPlayer));
					MeleeClearNearbyUnits(locX, locY, MELEE_CLEAR_UNITS_RADIUS);
				}
				index = index + 1;
				if(  index == MAX_PLAYERS )
					break;
			}
		}

		//***************************************************************************
		//*
		//*  Melee Template Starting Units
		//*
		//***************************************************************************
		//===========================================================================
		public static void MeleeEnumFindNearestMine(  )
		{
			// Original JassCode
			BJUnit enumUnit = GetEnumUnit();
			double dist;
			BJLocation unitLoc;
			if(  (GetUnitTypeId(enumUnit) == UnitId( "ngol" ))  )
			{
				unitLoc = GetUnitLoc(enumUnit);
				dist = DistanceBetweenPoints(unitLoc, meleeNearestMineToLoc);
				RemoveLocation(unitLoc);
				// If this is our first mine, or the closest thusfar, use it instead.
				if(  (meleeNearestMineDist < 0) || (dist < meleeNearestMineDist)  )
				{
					meleeNearestMine = enumUnit;
					meleeNearestMineDist = dist;
				}
			}
		}

		//===========================================================================
		public static BJUnit MeleeFindNearestMine( BJLocation src , double range )
		{
			// Original JassCode
			BJGroup nearbyMines;
			meleeNearestMine = null;
			meleeNearestMineDist = -1;
			meleeNearestMineToLoc = src;
			nearbyMines = CreateGroup();
			GroupEnumUnitsInRangeOfLoc(nearbyMines, src, range, null);
			ForGroup(nearbyMines,  MeleeEnumFindNearestMine);
			DestroyGroup(nearbyMines);
			return meleeNearestMine;
		}

		//===========================================================================
		public static BJUnit MeleeRandomHeroLoc( BJPlayer p , int id1 , int id2 , int id3 , int id4 , BJLocation loc )
		{
			// Original JassCode
			BJUnit hero = null;
			int roll;
			int pick;
			BJVersion v;
			// The selection of heroes is dependant on the game version.
			v = VersionGet();
			if(  (v == VERSION_REIGN_OF_CHAOS)  )
			{
				roll = GetRandomInt(1,3);
			}
			else
			{
				roll = GetRandomInt(1,4);
			}
			// Translate the roll into a unitid.
			if(  roll == 1  )
			{
				pick = id1;
			}
			else if(  roll == 2  )
			{
				pick = id2;
			}
			else if(  roll == 3  )
			{
				pick = id3;
			}
			else if(  roll == 4  )
			{
				pick = id4;
			}
			else
			{
				// Unrecognized id index - pick the first hero in the list.
				pick = id1;
			}
			// Create the hero.
			hero = CreateUnitAtLoc(p, pick, loc, UNIT_FACING);
			if(  meleeGrantHeroItems  )
			{
				MeleeGrantItemsToHero(hero);
			}
			return hero;
		}

		//===========================================================================
		// Returns a location which is (distance) away from (src) in the direction of (targ).
		//
		public static BJLocation MeleeGetProjectedLoc( BJLocation src , BJLocation targ , double distance , double deltaAngle )
		{
			// Original JassCode
			double srcX = GetLocationX(src);
			double srcY = GetLocationY(src);
			double direction = Atan2(GetLocationY(targ) - srcY, GetLocationX(targ) - srcX) + deltaAngle;
			return Location(srcX + distance * Cos(direction), srcY + distance * Sin(direction));
		}

		//===========================================================================
		public static double MeleeGetNearestValueWithin( double val , double minVal , double maxVal )
		{
			// Original JassCode
			if(  (val < minVal)  )
			{
				return minVal;
			}
			else if(  (val > maxVal)  )
			{
				return maxVal;
			}
			else
			{
				return val;
			}
		}

		//===========================================================================
		public static BJLocation MeleeGetLocWithinRect( BJLocation src , BJRect r )
		{
			// Original JassCode
			double withinX = MeleeGetNearestValueWithin(GetLocationX(src), GetRectMinX(r), GetRectMaxX(r));
			double withinY = MeleeGetNearestValueWithin(GetLocationY(src), GetRectMinY(r), GetRectMaxY(r));
			return Location(withinX, withinY);
		}

		//===========================================================================
		// Starting Units for Human Players
		//   - 1 Town Hall, placed at start location
		//   - 5 Peasants, placed between start location and nearest gold mine
		//
		public static void MeleeStartingUnitsHuman( BJPlayer whichPlayer , BJLocation startLoc , bool doHeroes , bool doCamera , bool doPreload )
		{
			// Original JassCode
			bool useRandomHero = IsMapFlagSet(MAP_RANDOM_HERO);
			double unitSpacing = 64.00;
			BJUnit nearestMine;
			BJLocation nearMineLoc;
			BJLocation heroLoc;
			double peonX;
			double peonY;
			if(  (doPreload)  )
			{
				Preloader( "scripts\\HumanMelee.pld" );
			}
			nearestMine = MeleeFindNearestMine(startLoc, MELEE_MINE_SEARCH_RADIUS);
			if(  (nearestMine != null)  )
			{
				// Spawn Town Hall at the start location.
				CreateUnitAtLoc(whichPlayer, UnitId( "htow" ), startLoc, UNIT_FACING);
				// Spawn Peasants near the mine.
				nearMineLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine), startLoc, 320, 0);
				peonX = GetLocationX(nearMineLoc);
				peonY = GetLocationY(nearMineLoc);
				CreateUnit(whichPlayer, UnitId( "hpea" ), peonX + 0.00 * unitSpacing, peonY + 1.00 * unitSpacing, UNIT_FACING);
				CreateUnit(whichPlayer, UnitId( "hpea" ), peonX + 1.00 * unitSpacing, peonY + 0.15 * unitSpacing, UNIT_FACING);
				CreateUnit(whichPlayer, UnitId( "hpea" ), peonX - 1.00 * unitSpacing, peonY + 0.15 * unitSpacing, UNIT_FACING);
				CreateUnit(whichPlayer, UnitId( "hpea" ), peonX + 0.60 * unitSpacing, peonY - 1.00 * unitSpacing, UNIT_FACING);
				CreateUnit(whichPlayer, UnitId( "hpea" ), peonX - 0.60 * unitSpacing, peonY - 1.00 * unitSpacing, UNIT_FACING);
				// Set random hero spawn point to be off to the side of the start location.
				heroLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine), startLoc, 384, 45);
			}
			else
			{
				// Spawn Town Hall at the start location.
				CreateUnitAtLoc(whichPlayer, UnitId( "htow" ), startLoc, UNIT_FACING);
				// Spawn Peasants directly south of the town hall.
				peonX = GetLocationX(startLoc);
				peonY = GetLocationY(startLoc) - 224.00;
				CreateUnit(whichPlayer, UnitId( "hpea" ), peonX + 2.00 * unitSpacing, peonY + 0.00 * unitSpacing, UNIT_FACING);
				CreateUnit(whichPlayer, UnitId( "hpea" ), peonX + 1.00 * unitSpacing, peonY + 0.00 * unitSpacing, UNIT_FACING);
				CreateUnit(whichPlayer, UnitId( "hpea" ), peonX + 0.00 * unitSpacing, peonY + 0.00 * unitSpacing, UNIT_FACING);
				CreateUnit(whichPlayer, UnitId( "hpea" ), peonX - 1.00 * unitSpacing, peonY + 0.00 * unitSpacing, UNIT_FACING);
				CreateUnit(whichPlayer, UnitId( "hpea" ), peonX - 2.00 * unitSpacing, peonY + 0.00 * unitSpacing, UNIT_FACING);
				// Set random hero spawn point to be just south of the start location.
				heroLoc = Location(peonX, peonY - 2.00 * unitSpacing);
			}
			if(  (doHeroes)  )
			{
				// If the "Random Hero" option is set, start the player with a random hero.
				// Otherwise, give them a "free hero" token.
				if(  useRandomHero  )
				{
					MeleeRandomHeroLoc(whichPlayer, UnitId( "Hamg" ), UnitId( "Hmkg" ), UnitId( "Hpal" ), UnitId( "Hblm" ), heroLoc);
				}
				else
				{
					SetPlayerState(whichPlayer, PLAYER_STATE_RESOURCE_HERO_TOKENS, MELEE_STARTING_HERO_TOKENS);
				}
			}
			if(  (doCamera)  )
			{
				// Center the camera on the initial Peasants.
				SetCameraPositionForPlayer(whichPlayer, peonX, peonY);
				SetCameraQuickPositionForPlayer(whichPlayer, peonX, peonY);
			}
		}

		//===========================================================================
		// Starting Units for Orc Players
		//   - 1 Great Hall, placed at start location
		//   - 5 Peons, placed between start location and nearest gold mine
		//
		public static void MeleeStartingUnitsOrc( BJPlayer whichPlayer , BJLocation startLoc , bool doHeroes , bool doCamera , bool doPreload )
		{
			// Original JassCode
			bool useRandomHero = IsMapFlagSet(MAP_RANDOM_HERO);
			double unitSpacing = 64.00;
			BJUnit nearestMine;
			BJLocation nearMineLoc;
			BJLocation heroLoc;
			double peonX;
			double peonY;
			if(  (doPreload)  )
			{
				Preloader( "scripts\\OrcMelee.pld" );
			}
			nearestMine = MeleeFindNearestMine(startLoc, MELEE_MINE_SEARCH_RADIUS);
			if(  (nearestMine != null)  )
			{
				// Spawn Great Hall at the start location.
				CreateUnitAtLoc(whichPlayer, UnitId( "ogre" ), startLoc, UNIT_FACING);
				// Spawn Peons near the mine.
				nearMineLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine), startLoc, 320, 0);
				peonX = GetLocationX(nearMineLoc);
				peonY = GetLocationY(nearMineLoc);
				CreateUnit(whichPlayer, UnitId( "opeo" ), peonX + 0.00 * unitSpacing, peonY + 1.00 * unitSpacing, UNIT_FACING);
				CreateUnit(whichPlayer, UnitId( "opeo" ), peonX + 1.00 * unitSpacing, peonY + 0.15 * unitSpacing, UNIT_FACING);
				CreateUnit(whichPlayer, UnitId( "opeo" ), peonX - 1.00 * unitSpacing, peonY + 0.15 * unitSpacing, UNIT_FACING);
				CreateUnit(whichPlayer, UnitId( "opeo" ), peonX + 0.60 * unitSpacing, peonY - 1.00 * unitSpacing, UNIT_FACING);
				CreateUnit(whichPlayer, UnitId( "opeo" ), peonX - 0.60 * unitSpacing, peonY - 1.00 * unitSpacing, UNIT_FACING);
				// Set random hero spawn point to be off to the side of the start location.
				heroLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine), startLoc, 384, 45);
			}
			else
			{
				// Spawn Great Hall at the start location.
				CreateUnitAtLoc(whichPlayer, UnitId( "ogre" ), startLoc, UNIT_FACING);
				// Spawn Peons directly south of the town hall.
				peonX = GetLocationX(startLoc);
				peonY = GetLocationY(startLoc) - 224.00;
				CreateUnit(whichPlayer, UnitId( "opeo" ), peonX + 2.00 * unitSpacing, peonY + 0.00 * unitSpacing, UNIT_FACING);
				CreateUnit(whichPlayer, UnitId( "opeo" ), peonX + 1.00 * unitSpacing, peonY + 0.00 * unitSpacing, UNIT_FACING);
				CreateUnit(whichPlayer, UnitId( "opeo" ), peonX + 0.00 * unitSpacing, peonY + 0.00 * unitSpacing, UNIT_FACING);
				CreateUnit(whichPlayer, UnitId( "opeo" ), peonX - 1.00 * unitSpacing, peonY + 0.00 * unitSpacing, UNIT_FACING);
				CreateUnit(whichPlayer, UnitId( "opeo" ), peonX - 2.00 * unitSpacing, peonY + 0.00 * unitSpacing, UNIT_FACING);
				// Set random hero spawn point to be just south of the start location.
				heroLoc = Location(peonX, peonY - 2.00 * unitSpacing);
			}
			if(  (doHeroes)  )
			{
				// If the "Random Hero" option is set, start the player with a random hero.
				// Otherwise, give them a "free hero" token.
				if(  useRandomHero  )
				{
					MeleeRandomHeroLoc(whichPlayer, UnitId( "Obla" ), UnitId( "Ofar" ), UnitId( "Otch" ), UnitId( "Oshd" ), heroLoc);
				}
				else
				{
					SetPlayerState(whichPlayer, PLAYER_STATE_RESOURCE_HERO_TOKENS, MELEE_STARTING_HERO_TOKENS);
				}
			}
			if(  (doCamera)  )
			{
				// Center the camera on the initial Peons.
				SetCameraPositionForPlayer(whichPlayer, peonX, peonY);
				SetCameraQuickPositionForPlayer(whichPlayer, peonX, peonY);
			}
		}

		//===========================================================================
		// Starting Units for Undead Players
		//   - 1 Necropolis, placed at start location
		//   - 1 Haunted Gold Mine, placed on nearest gold mine
		//   - 3 Acolytes, placed between start location and nearest gold mine
		//   - 1 Ghoul, placed between start location and nearest gold mine
		//   - Blight, centered on nearest gold mine, spread across a "large area"
		//
		public static void MeleeStartingUnitsUndead( BJPlayer whichPlayer , BJLocation startLoc , bool doHeroes , bool doCamera , bool doPreload )
		{
			// Original JassCode
			bool useRandomHero = IsMapFlagSet(MAP_RANDOM_HERO);
			double unitSpacing = 64.00;
			BJUnit nearestMine;
			BJLocation nearMineLoc;
			BJLocation nearTownLoc;
			BJLocation heroLoc;
			double peonX;
			double peonY;
			double ghoulX;
			double ghoulY;
			if(  (doPreload)  )
			{
				Preloader( "scripts\\UndeadMelee.pld" );
			}
			nearestMine = MeleeFindNearestMine(startLoc, MELEE_MINE_SEARCH_RADIUS);
			if(  (nearestMine != null)  )
			{
				// Spawn Necropolis at the start location.
				CreateUnitAtLoc(whichPlayer, UnitId( "unpl" ), startLoc, UNIT_FACING);
				// Replace the nearest gold mine with a blighted version.
				nearestMine = BlightGoldMineForPlayerBJ(nearestMine, whichPlayer);
				// Spawn Ghoul near the Necropolis.
				nearTownLoc = MeleeGetProjectedLoc(startLoc, GetUnitLoc(nearestMine), 288, 0);
				ghoulX = GetLocationX(nearTownLoc);
				ghoulY = GetLocationY(nearTownLoc);
				ghoul[GetPlayerId(whichPlayer)] = CreateUnit(whichPlayer, UnitId( "ugho" ), ghoulX + 0.00 * unitSpacing, ghoulY + 0.00 * unitSpacing, UNIT_FACING);
				// Spawn Acolytes near the mine.
				nearMineLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine), startLoc, 320, 0);
				peonX = GetLocationX(nearMineLoc);
				peonY = GetLocationY(nearMineLoc);
				CreateUnit(whichPlayer, UnitId( "uaco" ), peonX + 0.00 * unitSpacing, peonY + 0.50 * unitSpacing, UNIT_FACING);
				CreateUnit(whichPlayer, UnitId( "uaco" ), peonX + 0.65 * unitSpacing, peonY - 0.50 * unitSpacing, UNIT_FACING);
				CreateUnit(whichPlayer, UnitId( "uaco" ), peonX - 0.65 * unitSpacing, peonY - 0.50 * unitSpacing, UNIT_FACING);
				// Create a patch of blight around the gold mine.
				SetBlightLoc(whichPlayer,nearMineLoc, 768, true);
				// Set random hero spawn point to be off to the side of the start location.
				heroLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine), startLoc, 384, 45);
			}
			else
			{
				// Spawn Necropolis at the start location.
				CreateUnitAtLoc(whichPlayer, UnitId( "unpl" ), startLoc, UNIT_FACING);
				// Spawn Acolytes and Ghoul directly south of the Necropolis.
				peonX = GetLocationX(startLoc);
				peonY = GetLocationY(startLoc) - 224.00;
				CreateUnit(whichPlayer, UnitId( "uaco" ), peonX - 1.50 * unitSpacing, peonY + 0.00 * unitSpacing, UNIT_FACING);
				CreateUnit(whichPlayer, UnitId( "uaco" ), peonX - 0.50 * unitSpacing, peonY + 0.00 * unitSpacing, UNIT_FACING);
				CreateUnit(whichPlayer, UnitId( "uaco" ), peonX + 0.50 * unitSpacing, peonY + 0.00 * unitSpacing, UNIT_FACING);
				CreateUnit(whichPlayer, UnitId( "ugho" ), peonX + 1.50 * unitSpacing, peonY + 0.00 * unitSpacing, UNIT_FACING);
				// Create a patch of blight around the start location.
				SetBlightLoc(whichPlayer,startLoc, 768, true);
				// Set random hero spawn point to be just south of the start location.
				heroLoc = Location(peonX, peonY - 2.00 * unitSpacing);
			}
			if(  (doHeroes)  )
			{
				// If the "Random Hero" option is set, start the player with a random hero.
				// Otherwise, give them a "free hero" token.
				if(  useRandomHero  )
				{
					MeleeRandomHeroLoc(whichPlayer, UnitId( "Udea" ), UnitId( "Udre" ), UnitId( "Ulic" ), UnitId( "Ucrl" ), heroLoc);
				}
				else
				{
					SetPlayerState(whichPlayer, PLAYER_STATE_RESOURCE_HERO_TOKENS, MELEE_STARTING_HERO_TOKENS);
				}
			}
			if(  (doCamera)  )
			{
				// Center the camera on the initial Acolytes.
				SetCameraPositionForPlayer(whichPlayer, peonX, peonY);
				SetCameraQuickPositionForPlayer(whichPlayer, peonX, peonY);
			}
		}

		//===========================================================================
		// Starting Units for Night Elf Players
		//   - 1 Tree of Life, placed by nearest gold mine, already entangled
		//   - 5 Wisps, placed between Tree of Life and nearest gold mine
		//
		public static void MeleeStartingUnitsNightElf( BJPlayer whichPlayer , BJLocation startLoc , bool doHeroes , bool doCamera , bool doPreload )
		{
			// Original JassCode
			bool useRandomHero = IsMapFlagSet(MAP_RANDOM_HERO);
			double unitSpacing = 64.00;
			double minTreeDist = 3.50 * CELLWIDTH;
			double minWispDist = 1.75 * CELLWIDTH;
			BJUnit nearestMine;
			BJLocation nearMineLoc;
			BJLocation wispLoc;
			BJLocation heroLoc;
			double peonX;
			double peonY;
			BJUnit tree;
			if(  (doPreload)  )
			{
				Preloader( "scripts\\NightElfMelee.pld" );
			}
			nearestMine = MeleeFindNearestMine(startLoc, MELEE_MINE_SEARCH_RADIUS);
			if(  (nearestMine != null)  )
			{
				// Spawn Tree of Life near the mine and have it entangle the mine.
				// Project the Tree's coordinates from the gold mine, and then snap
				// the X and Y values to within minTreeDist of the Gold Mine.
				nearMineLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine), startLoc, 650, 0);
				nearMineLoc = MeleeGetLocWithinRect(nearMineLoc, GetRectFromCircleBJ(GetUnitLoc(nearestMine), minTreeDist));
				tree = CreateUnitAtLoc(whichPlayer, UnitId( "etol" ), nearMineLoc, UNIT_FACING);
				IssueTargetOrder(tree, "entangleinstant", nearestMine);
				// Spawn Wisps at the start location.
				wispLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine), startLoc, 320, 0);
				wispLoc = MeleeGetLocWithinRect(wispLoc, GetRectFromCircleBJ(GetUnitLoc(nearestMine), minWispDist));
				peonX = GetLocationX(wispLoc);
				peonY = GetLocationY(wispLoc);
				CreateUnit(whichPlayer, UnitId( "ewsp" ), peonX + 0.00 * unitSpacing, peonY + 1.00 * unitSpacing, UNIT_FACING);
				CreateUnit(whichPlayer, UnitId( "ewsp" ), peonX + 1.00 * unitSpacing, peonY + 0.15 * unitSpacing, UNIT_FACING);
				CreateUnit(whichPlayer, UnitId( "ewsp" ), peonX - 1.00 * unitSpacing, peonY + 0.15 * unitSpacing, UNIT_FACING);
				CreateUnit(whichPlayer, UnitId( "ewsp" ), peonX + 0.58 * unitSpacing, peonY - 1.00 * unitSpacing, UNIT_FACING);
				CreateUnit(whichPlayer, UnitId( "ewsp" ), peonX - 0.58 * unitSpacing, peonY - 1.00 * unitSpacing, UNIT_FACING);
				// Set random hero spawn point to be off to the side of the start location.
				heroLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine), startLoc, 384, 45);
			}
			else
			{
				// Spawn Tree of Life at the start location.
				CreateUnitAtLoc(whichPlayer, UnitId( "etol" ), startLoc, UNIT_FACING);
				// Spawn Wisps directly south of the town hall.
				peonX = GetLocationX(startLoc);
				peonY = GetLocationY(startLoc) - 224.00;
				CreateUnit(whichPlayer, UnitId( "ewsp" ), peonX - 2.00 * unitSpacing, peonY + 0.00 * unitSpacing, UNIT_FACING);
				CreateUnit(whichPlayer, UnitId( "ewsp" ), peonX - 1.00 * unitSpacing, peonY + 0.00 * unitSpacing, UNIT_FACING);
				CreateUnit(whichPlayer, UnitId( "ewsp" ), peonX + 0.00 * unitSpacing, peonY + 0.00 * unitSpacing, UNIT_FACING);
				CreateUnit(whichPlayer, UnitId( "ewsp" ), peonX + 1.00 * unitSpacing, peonY + 0.00 * unitSpacing, UNIT_FACING);
				CreateUnit(whichPlayer, UnitId( "ewsp" ), peonX + 2.00 * unitSpacing, peonY + 0.00 * unitSpacing, UNIT_FACING);
				// Set random hero spawn point to be just south of the start location.
				heroLoc = Location(peonX, peonY - 2.00 * unitSpacing);
			}
			if(  (doHeroes)  )
			{
				// If the "Random Hero" option is set, start the player with a random hero.
				// Otherwise, give them a "free hero" token.
				if(  useRandomHero  )
				{
					MeleeRandomHeroLoc(whichPlayer, UnitId( "Edem" ), UnitId( "Ekee" ), UnitId( "Emoo" ), UnitId( "Ewar" ), heroLoc);
				}
				else
				{
					SetPlayerState(whichPlayer, PLAYER_STATE_RESOURCE_HERO_TOKENS, MELEE_STARTING_HERO_TOKENS);
				}
			}
			if(  (doCamera)  )
			{
				// Center the camera on the initial Wisps.
				SetCameraPositionForPlayer(whichPlayer, peonX, peonY);
				SetCameraQuickPositionForPlayer(whichPlayer, peonX, peonY);
			}
		}

		//===========================================================================
		// Starting Units for Players Whose Race is Unknown
		//   - 12 Sheep, placed randomly around the start location
		//
		public static void MeleeStartingUnitsUnknownRace( BJPlayer whichPlayer , BJLocation startLoc , bool doHeroes , bool doCamera , bool doPreload )
		{
			// Original JassCode
			int index;
			if(  (doPreload)  )
			{
			}
			index = 0;
			while( true )
			{
				CreateUnit(whichPlayer, UnitId( "nshe" ), GetLocationX(startLoc) + GetRandomReal(-256, 256), GetLocationY(startLoc) + GetRandomReal(-256, 256), GetRandomReal(0, 360));
				index = index + 1;
				if(  index == 12 )
					break;
			}
			if(  (doHeroes)  )
			{
				// Give them a "free hero" token, out of pity.
				SetPlayerState(whichPlayer, PLAYER_STATE_RESOURCE_HERO_TOKENS, MELEE_STARTING_HERO_TOKENS);
			}
			if(  (doCamera)  )
			{
				// Center the camera on the initial sheep.
				SetCameraPositionLocForPlayer(whichPlayer, startLoc);
				SetCameraQuickPositionLocForPlayer(whichPlayer, startLoc);
			}
		}

		//===========================================================================
		public static void MeleeStartingUnits(  )
		{
			// Original JassCode
			int index;
			BJPlayer indexPlayer;
			BJLocation indexStartLoc;
			BJRace indexRace;
			Preloader( "scripts\\SharedMelee.pld" );
			index = 0;
			while( true )
			{
				indexPlayer = Player(index);
				if(  (GetPlayerSlotState(indexPlayer) == PLAYER_SLOT_STATE_PLAYING)  )
				{
					indexStartLoc = GetStartLocationLoc(GetPlayerStartLocation(indexPlayer));
					indexRace = GetPlayerRace(indexPlayer);
					// Create initial race-specific starting units
					if(  (indexRace == RACE_HUMAN)  )
					{
						MeleeStartingUnitsHuman(indexPlayer, indexStartLoc, true, true, true);
					}
					else if(  (indexRace == RACE_ORC)  )
					{
						MeleeStartingUnitsOrc(indexPlayer, indexStartLoc, true, true, true);
					}
					else if(  (indexRace == RACE_UNDEAD)  )
					{
						MeleeStartingUnitsUndead(indexPlayer, indexStartLoc, true, true, true);
					}
					else if(  (indexRace == RACE_NIGHTELF)  )
					{
						MeleeStartingUnitsNightElf(indexPlayer, indexStartLoc, true, true, true);
					}
					else
					{
						MeleeStartingUnitsUnknownRace(indexPlayer, indexStartLoc, true, true, true);
					}
				}
				index = index + 1;
				if(  index == MAX_PLAYERS )
					break;
			}
		}

		//===========================================================================
		public static void MeleeStartingUnitsForPlayer( BJRace whichRace , BJPlayer whichPlayer , BJLocation loc , bool doHeroes )
		{
			// Original JassCode
			// Create initial race-specific starting units
			if(  (whichRace == RACE_HUMAN)  )
			{
				MeleeStartingUnitsHuman(whichPlayer, loc, doHeroes, false, false);
			}
			else if(  (whichRace == RACE_ORC)  )
			{
				MeleeStartingUnitsOrc(whichPlayer, loc, doHeroes, false, false);
			}
			else if(  (whichRace == RACE_UNDEAD)  )
			{
				MeleeStartingUnitsUndead(whichPlayer, loc, doHeroes, false, false);
			}
			else if(  (whichRace == RACE_NIGHTELF)  )
			{
				MeleeStartingUnitsNightElf(whichPlayer, loc, doHeroes, false, false);
			}
			else
			{
				// Unrecognized race - ignore the request.
			}
		}

		//***************************************************************************
		//*
		//*  Melee Template Starting AI Scripts
		//*
		//***************************************************************************
		//===========================================================================
		public static void PickMeleeAI( BJPlayer num , string s1 , string s2 , string s3 )
		{
			// Original JassCode
			int pick;
			// easy difficulty never uses any custom AI scripts
			// that are designed to be a bit more challenging
			//
			if(  GetAIDifficulty(num) == AI_DIFFICULTY_NEWBIE  )
			{
				StartMeleeAI(num,s1);
				return;
			}
			if(  s2 == null  )
			{
				pick = 1;
			}
			else if(  s3 == null  )
			{
				pick = GetRandomInt(1,2);
			}
			else
			{
				pick = GetRandomInt(1,3);
			}
			if(  pick == 1  )
			{
				StartMeleeAI(num,s1);
			}
			else if(  pick == 2  )
			{
				StartMeleeAI(num,s2);
			}
			else
			{
				StartMeleeAI(num,s3);
			}
		}

		//===========================================================================
		public static void MeleeStartingAI(  )
		{
			// Original JassCode
			int index;
			BJPlayer indexPlayer;
			BJRace indexRace;
			index = 0;
			while( true )
			{
				indexPlayer = Player(index);
				if(  (GetPlayerSlotState(indexPlayer) == PLAYER_SLOT_STATE_PLAYING)  )
				{
					indexRace = GetPlayerRace(indexPlayer);
					if(  (GetPlayerController(indexPlayer) == MAP_CONTROL_COMPUTER)  )
					{
						// Run a race-specific melee AI script.
						if(  (indexRace == RACE_HUMAN)  )
						{
							PickMeleeAI(indexPlayer, "human.ai", null, null);
						}
						else if(  (indexRace == RACE_ORC)  )
						{
							PickMeleeAI(indexPlayer, "orc.ai", null, null);
						}
						else if(  (indexRace == RACE_UNDEAD)  )
						{
							PickMeleeAI(indexPlayer, "undead.ai", null, null);
							RecycleGuardPosition(ghoul[index]);
						}
						else if(  (indexRace == RACE_NIGHTELF)  )
						{
							PickMeleeAI(indexPlayer, "elf.ai", null, null);
						}
						else
						{
							// Unrecognized race.
						}
						ShareEverythingWithTeamAI(indexPlayer);
					}
				}
				index = index + 1;
				if(  index == MAX_PLAYERS )
					break;
			}
		}

		public static void LockGuardPosition( BJUnit targ )
		{
			// Original JassCode
			SetUnitCreepGuard(targ,true);
		}

		//***************************************************************************
		//*
		//*  Melee Template Victory / Defeat Conditions
		//*
		//***************************************************************************
		//===========================================================================
		public static bool MeleePlayerIsOpponent( int playerIndex , int opponentIndex )
		{
			// Original JassCode
			BJPlayer thePlayer = Player(playerIndex);
			BJPlayer theOpponent = Player(opponentIndex);
			// The player himself is not an opponent.
			if(  (playerIndex == opponentIndex)  )
			{
				return false;
			}
			// Unused player slots are not opponents.
			if(  (GetPlayerSlotState(theOpponent) != PLAYER_SLOT_STATE_PLAYING)  )
			{
				return false;
			}
			// Players who are already defeated are not opponents.
			if(  (meleeDefeated[opponentIndex])  )
			{
				return false;
			}
			// Allied players with allied victory set are not opponents.
			if(  GetPlayerAlliance(thePlayer, theOpponent, ALLIANCE_PASSIVE)  )
			{
				if(  GetPlayerAlliance(theOpponent, thePlayer, ALLIANCE_PASSIVE)  )
				{
					if(  (GetPlayerState(thePlayer, PLAYER_STATE_ALLIED_VICTORY) == 1)  )
					{
						if(  (GetPlayerState(theOpponent, PLAYER_STATE_ALLIED_VICTORY) == 1)  )
						{
							return false;
						}
					}
				}
			}
			return true;
		}

		//===========================================================================
		// Count buildings currently owned by all allies, including the player themself.
		//
		public static int MeleeGetAllyStructureCount( BJPlayer whichPlayer )
		{
			// Original JassCode
			int playerIndex;
			int buildingCount;
			BJPlayer indexPlayer;
			// Count the number of buildings controlled by all not-yet-defeated co-allies.
			buildingCount = 0;
			playerIndex = 0;
			while( true )
			{
				indexPlayer = Player(playerIndex);
				// uncomment to cause defeat even if you have control of ally structures, but yours have been nixed
				//if (PlayersAreCoAllied(whichPlayer, indexPlayer) and not meleeDefeated[playerIndex]) then
				if(  (PlayersAreCoAllied(whichPlayer, indexPlayer))  )
				{
					buildingCount = buildingCount + GetPlayerStructureCount(indexPlayer, true);
				}
				playerIndex = playerIndex + 1;
				if(  playerIndex == MAX_PLAYERS )
					break;
			}
			return buildingCount;
		}

		//===========================================================================
		// Count allies, excluding dead players and the player themself.
		//
		public static int MeleeGetAllyCount( BJPlayer whichPlayer )
		{
			// Original JassCode
			int playerIndex;
			int playerCount;
			BJPlayer indexPlayer;
			// Count the number of not-yet-defeated co-allies.
			playerCount = 0;
			playerIndex = 0;
			while( true )
			{
				indexPlayer = Player(playerIndex);
				if(  PlayersAreCoAllied(whichPlayer, indexPlayer) && ! meleeDefeated[playerIndex] && (whichPlayer != indexPlayer)  )
				{
					playerCount = playerCount + 1;
				}
				playerIndex = playerIndex + 1;
				if(  playerIndex == MAX_PLAYERS )
					break;
			}
			return playerCount;
		}

		//===========================================================================
		// Counts key structures owned by a player and his or her allies, including
		// structures currently upgrading or under construction.
		//
		// Key structures: Town Hall, Great Hall, Tree of Life, Necropolis
		//
		public static int MeleeGetAllyKeyStructureCount( BJPlayer whichPlayer )
		{
			// Original JassCode
			int playerIndex;
			BJPlayer indexPlayer;
			int keyStructs;
			// Count the number of buildings controlled by all not-yet-defeated co-allies.
			keyStructs = 0;
			playerIndex = 0;
			while( true )
			{
				indexPlayer = Player(playerIndex);
				if(  (PlayersAreCoAllied(whichPlayer, indexPlayer))  )
				{
					keyStructs = keyStructs + GetPlayerTypedUnitCount(indexPlayer, "townhall", true, true);
					keyStructs = keyStructs + GetPlayerTypedUnitCount(indexPlayer, "greathall", true, true);
					keyStructs = keyStructs + GetPlayerTypedUnitCount(indexPlayer, "treeoflife", true, true);
					keyStructs = keyStructs + GetPlayerTypedUnitCount(indexPlayer, "necropolis", true, true);
				}
				playerIndex = playerIndex + 1;
				if(  playerIndex == MAX_PLAYERS )
					break;
			}
			return keyStructs;
		}

		//===========================================================================
		// Enum: Draw out a specific player.
		//
		public static void MeleeDoDrawEnum(  )
		{
			// Original JassCode
			BJPlayer thePlayer = GetEnumPlayer();
			CachePlayerHeroData(thePlayer);
			RemovePlayerPreserveUnitsBJ(thePlayer, PLAYER_GAME_RESULT_TIE, false);
		}

		//===========================================================================
		// Enum: Victory out a specific player.
		//
		public static void MeleeDoVictoryEnum(  )
		{
			// Original JassCode
			BJPlayer thePlayer = GetEnumPlayer();
			int playerIndex = GetPlayerId(thePlayer);
			if(  (! meleeVictoried[playerIndex])  )
			{
				meleeVictoried[playerIndex] = true;
				CachePlayerHeroData(thePlayer);
				RemovePlayerPreserveUnitsBJ(thePlayer, PLAYER_GAME_RESULT_VICTORY, false);
			}
		}

		//===========================================================================
		// Defeat out a specific player.
		//
		public static void MeleeDoDefeat( BJPlayer whichPlayer )
		{
			// Original JassCode
			meleeDefeated[GetPlayerId(whichPlayer)] = true;
			RemovePlayerPreserveUnitsBJ(whichPlayer, PLAYER_GAME_RESULT_DEFEAT, false);
		}

		//===========================================================================
		// Enum: Defeat out a specific player.
		//
		public static void MeleeDoDefeatEnum(  )
		{
			// Original JassCode
			BJPlayer thePlayer = GetEnumPlayer();
			// needs to happen before ownership change
			CachePlayerHeroData(thePlayer);
			MakeUnitsPassiveForTeam(thePlayer);
			MeleeDoDefeat(thePlayer);
		}

		//===========================================================================
		// A specific player left the 
		//
		public static void MeleeDoLeave( BJPlayer whichPlayer )
		{
			// Original JassCode
			if(  (GetIntegerGameState(GAME_STATE_DISCONNECTED) != 0)  )
			{
				GameOverDialogBJ( whichPlayer, true );
			}
			else
			{
				meleeDefeated[GetPlayerId(whichPlayer)] = true;
				RemovePlayerPreserveUnitsBJ(whichPlayer, PLAYER_GAME_RESULT_DEFEAT, true);
			}
		}

		//===========================================================================
		// Remove all observers
		// 
		public static void MeleeRemoveObservers(  )
		{
			// Original JassCode
			int playerIndex;
			BJPlayer indexPlayer;
			// Give all observers the game over dialog
			playerIndex = 0;
			while( true )
			{
				indexPlayer = Player(playerIndex);
				if(  (IsPlayerObserver(indexPlayer))  )
				{
					RemovePlayerPreserveUnitsBJ(indexPlayer, PLAYER_GAME_RESULT_NEUTRAL, false);
				}
				playerIndex = playerIndex + 1;
				if(  playerIndex == MAX_PLAYERS )
					break;
			}
		}

		//===========================================================================
		// Test all players to determine if a team has won.  For a team to win, all
		// remaining (read: undefeated) players need to be co-allied with all other
		// remaining players.  If even one player is not allied towards another,
		// everyone must be denied victory.
		//
		public static BJForce MeleeCheckForVictors(  )
		{
			// Original JassCode
			int playerIndex;
			int opponentIndex;
			BJForce opponentlessPlayers = CreateForce();
			bool gameOver = false;
			// Check to see if any players have opponents remaining.
			playerIndex = 0;
			while( true )
			{
				if(  (! meleeDefeated[playerIndex])  )
				{
					// Determine whether or not this player has any remaining opponents.
					opponentIndex = 0;
					while( true )
					{
						// If anyone has an opponent, noone can be victorious yet.
						if(  MeleePlayerIsOpponent(playerIndex, opponentIndex)  )
						{
							return CreateForce();
						}
						opponentIndex = opponentIndex + 1;
						if(  opponentIndex == MAX_PLAYERS )
							break;
					}
					// Keep track of each opponentless player so that we can give
					// them a victory later.
					ForceAddPlayer(opponentlessPlayers, Player(playerIndex));
					gameOver = true;
				}
				playerIndex = playerIndex + 1;
				if(  playerIndex == MAX_PLAYERS )
					break;
			}
			// Set the game over global flag
			meleeGameOver = gameOver;
			return opponentlessPlayers;
		}

		//===========================================================================
		// Test each player to determine if anyone has been defeated.
		//
		public static void MeleeCheckForLosersAndVictors(  )
		{
			// Original JassCode
			int playerIndex;
			BJPlayer indexPlayer;
			BJForce defeatedPlayers = CreateForce();
			BJForce victoriousPlayers;
			bool gameOver = false;
			// If the game is already over, do nothing
			if(  (meleeGameOver)  )
			{
				return;
			}
			// If the game was disconnected then it is over, in this case we
			// don't want to report results for anyone as they will most likely
			// conflict with the actual game results
			if(  (GetIntegerGameState(GAME_STATE_DISCONNECTED) != 0)  )
			{
				meleeGameOver = true;
				return;
			}
			// Check each player to see if he or she has been defeated yet.
			playerIndex = 0;
			while( true )
			{
				indexPlayer = Player(playerIndex);
				if(  (! meleeDefeated[playerIndex] && ! meleeVictoried[playerIndex])  )
				{
					//call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, 60, "Player"+I2S(playerIndex)+" has "+I2S(MeleeGetAllyStructureCount(indexPlayer))+" ally buildings.")
					if(  (MeleeGetAllyStructureCount(indexPlayer) <= 0)  )
					{
						// Keep track of each defeated player so that we can give
						// them a defeat later.
						ForceAddPlayer(defeatedPlayers, Player(playerIndex));
						// Set their defeated flag now so MeleeCheckForVictors
						// can detect victors.
						meleeDefeated[playerIndex] = true;
					}
				}
				playerIndex = playerIndex + 1;
				if(  playerIndex == MAX_PLAYERS )
					break;
			}
			// Now that the defeated flags are set, check if there are any victors
			victoriousPlayers = MeleeCheckForVictors();
			// Defeat all defeated players
			ForForce(defeatedPlayers,  MeleeDoDefeatEnum);
			// Give victory to all victorious players
			ForForce(victoriousPlayers,  MeleeDoVictoryEnum);
			// If the game is over we should remove all observers
			if(  (meleeGameOver)  )
			{
				MeleeRemoveObservers();
			}
		}

		//===========================================================================
		// Returns a race-specific "build X or be revealed" message.
		//
		public static string MeleeGetCrippledWarningMessage( BJPlayer whichPlayer )
		{
			// Original JassCode
			BJRace r = GetPlayerRace(whichPlayer);
			if(  (r == RACE_HUMAN)  )
			{
				return GetLocalizedString("CRIPPLE_WARNING_HUMAN");
			}
			else if(  (r == RACE_ORC)  )
			{
				return GetLocalizedString("CRIPPLE_WARNING_ORC");
			}
			else if(  (r == RACE_NIGHTELF)  )
			{
				return GetLocalizedString("CRIPPLE_WARNING_NIGHTELF");
			}
			else if(  (r == RACE_UNDEAD)  )
			{
				return GetLocalizedString("CRIPPLE_WARNING_UNDEAD");
			}
			else
			{
				// Unrecognized Race
				return "";
			}
		}

		//===========================================================================
		// Returns a race-specific "build X" label for cripple timers.
		//
		public static string MeleeGetCrippledTimerMessage( BJPlayer whichPlayer )
		{
			// Original JassCode
			BJRace r = GetPlayerRace(whichPlayer);
			if(  (r == RACE_HUMAN)  )
			{
				return GetLocalizedString("CRIPPLE_TIMER_HUMAN");
			}
			else if(  (r == RACE_ORC)  )
			{
				return GetLocalizedString("CRIPPLE_TIMER_ORC");
			}
			else if(  (r == RACE_NIGHTELF)  )
			{
				return GetLocalizedString("CRIPPLE_TIMER_NIGHTELF");
			}
			else if(  (r == RACE_UNDEAD)  )
			{
				return GetLocalizedString("CRIPPLE_TIMER_UNDEAD");
			}
			else
			{
				// Unrecognized Race
				return "";
			}
		}

		//===========================================================================
		// Returns a race-specific "build X" label for cripple timers.
		//
		public static string MeleeGetCrippledRevealedMessage( BJPlayer whichPlayer )
		{
			// Original JassCode
			return GetLocalizedString("CRIPPLE_REVEALING_PREFIX") + GetPlayerName(whichPlayer) + GetLocalizedString("CRIPPLE_REVEALING_POSTFIX");
		}

		//===========================================================================
		public static void MeleeExposePlayer( BJPlayer whichPlayer , bool expose )
		{
			// Original JassCode
			int playerIndex;
			BJPlayer indexPlayer;
			BJForce toExposeTo = CreateForce();
			CripplePlayer( whichPlayer, toExposeTo, false );
			playerIsExposed[GetPlayerId(whichPlayer)] = expose;
			playerIndex = 0;
			while( true )
			{
				indexPlayer = Player(playerIndex);
				if(  (! PlayersAreCoAllied(whichPlayer, indexPlayer))  )
				{
					ForceAddPlayer( toExposeTo, indexPlayer );
				}
				playerIndex = playerIndex + 1;
				if(  playerIndex == MAX_PLAYERS )
					break;
			}
			CripplePlayer( whichPlayer, toExposeTo, expose );
			DestroyForce(toExposeTo);
		}

		//===========================================================================
		public static void MeleeExposeAllPlayers(  )
		{
			// Original JassCode
			int playerIndex;
			BJPlayer indexPlayer;
			int playerIndex2;
			BJPlayer indexPlayer2;
			BJForce toExposeTo = CreateForce();
			playerIndex = 0;
			while( true )
			{
				indexPlayer = Player(playerIndex);
				ForceClear( toExposeTo );
				CripplePlayer( indexPlayer, toExposeTo, false );
				playerIndex2 = 0;
				while( true )
				{
					indexPlayer2 = Player(playerIndex2);
					if(  playerIndex != playerIndex2  )
					{
						if(  (! PlayersAreCoAllied(indexPlayer, indexPlayer2))  )
						{
							ForceAddPlayer( toExposeTo, indexPlayer2 );
						}
					}
					playerIndex2 = playerIndex2 + 1;
					if(  playerIndex2 == MAX_PLAYERS )
						break;
				}
				CripplePlayer( indexPlayer, toExposeTo, true );
				playerIndex = playerIndex + 1;
				if(  playerIndex == MAX_PLAYERS )
					break;
			}
			DestroyForce( toExposeTo );
		}

		//===========================================================================
		public static void MeleeCrippledPlayerTimeout(  )
		{
			// Original JassCode
			BJTimer expiredTimer = GetExpiredTimer();
			int playerIndex;
			BJPlayer exposedPlayer;
			// Determine which player's timer expired.
			playerIndex = 0;
			while( true )
			{
				if(  (crippledTimer[playerIndex] == expiredTimer)  )
				{
					if(  true )
						break;
				}
				playerIndex = playerIndex + 1;
				if(  playerIndex == MAX_PLAYERS )
					break;
			}
			if(  (playerIndex == MAX_PLAYERS)  )
			{
				return;
			}
			exposedPlayer = Player(playerIndex);
			if(  (GetLocalPlayer() == exposedPlayer)  )
			{
				// Use only local code (no net traffic) within this block to avoid desyncs.
				// Hide the timer window for this player.
				TimerDialogDisplay(crippledTimerWindows[playerIndex], false);
			}
			// Display a text message to all players, explaining the exposure.
			DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, MELEE_CRIPPLE_MSG_DURATION, MeleeGetCrippledRevealedMessage(exposedPlayer));
			// Expose the player.
			MeleeExposePlayer(exposedPlayer, true);
		}

		//===========================================================================
		public static bool MeleePlayerIsCrippled( BJPlayer whichPlayer )
		{
			// Original JassCode
			int allyStructures = MeleeGetAllyStructureCount(whichPlayer);
			int allyKeyStructures = MeleeGetAllyKeyStructureCount(whichPlayer);
			// Dead teams are not considered to be crippled.
			return (allyStructures > 0) && (allyKeyStructures <= 0);
		}

		//===========================================================================
		// Test each player to determine if anyone has become crippled.
		//
		public static void MeleeCheckForCrippledPlayers(  )
		{
			// Original JassCode
			int playerIndex;
			BJPlayer indexPlayer;
			BJForce crippledPlayers = CreateForce();
			bool isNowCrippled;
			BJRace indexRace;
			// The "finish soon" exposure of all players overrides any "crippled" exposure
			if(  finishSoonAllExposed  )
			{
				return;
			}
			// Check each player to see if he or she has been crippled or uncrippled.
			playerIndex = 0;
			while( true )
			{
				indexPlayer = Player(playerIndex);
				isNowCrippled = MeleePlayerIsCrippled(indexPlayer);
				if(  (! playerIsCrippled[playerIndex] && isNowCrippled)  )
				{
					// Player became crippled; start their cripple timer.
					playerIsCrippled[playerIndex] = true;
					TimerStart(crippledTimer[playerIndex], MELEE_CRIPPLE_TIMEOUT, false,  MeleeCrippledPlayerTimeout);
					if(  (GetLocalPlayer() == indexPlayer)  )
					{
						// Use only local code (no net traffic) within this block to avoid desyncs.
						// Show the timer window.
						TimerDialogDisplay(crippledTimerWindows[playerIndex], true);
						// Display a warning message.
						DisplayTimedTextToPlayer(indexPlayer, 0, 0, MELEE_CRIPPLE_MSG_DURATION, MeleeGetCrippledWarningMessage(indexPlayer));
					}
				}
				else if(  (playerIsCrippled[playerIndex] && ! isNowCrippled)  )
				{
					// Player became uncrippled; stop their cripple timer.
					playerIsCrippled[playerIndex] = false;
					PauseTimer(crippledTimer[playerIndex]);
					if(  (GetLocalPlayer() == indexPlayer)  )
					{
						// Use only local code (no net traffic) within this block to avoid desyncs.
						// Hide the timer window for this player.
						TimerDialogDisplay(crippledTimerWindows[playerIndex], false);
						// Display a confirmation message if the player's team is still alive.
						if(  (MeleeGetAllyStructureCount(indexPlayer) > 0)  )
						{
							if(  (playerIsExposed[playerIndex])  )
							{
								DisplayTimedTextToPlayer(indexPlayer, 0, 0, MELEE_CRIPPLE_MSG_DURATION, GetLocalizedString("CRIPPLE_UNREVEALED"));
							}
							else
							{
								DisplayTimedTextToPlayer(indexPlayer, 0, 0, MELEE_CRIPPLE_MSG_DURATION, GetLocalizedString("CRIPPLE_UNCRIPPLED"));
							}
						}
					}
					// If the player granted shared vision, deny that vision now.
					MeleeExposePlayer(indexPlayer, false);
				}
				playerIndex = playerIndex + 1;
				if(  playerIndex == MAX_PLAYERS )
					break;
			}
		}

		//===========================================================================
		// Determine if the lost unit should result in any defeats or victories.
		//
		public static void MeleeCheckLostUnit( BJUnit lostUnit )
		{
			// Original JassCode
			BJPlayer lostUnitOwner = GetOwningPlayer(lostUnit);
			// We only need to check for mortality if this was the last building.
			if(  (GetPlayerStructureCount(lostUnitOwner, true) <= 0)  )
			{
				MeleeCheckForLosersAndVictors();
			}
			// Check if the lost unit has crippled or uncrippled the player.
			// (A team with 0 units is dead, and thus considered uncrippled.)
			MeleeCheckForCrippledPlayers();
		}

		//===========================================================================
		// Determine if the gained unit should result in any defeats, victories,
		// or cripple-status changes.
		//
		public static void MeleeCheckAddedUnit( BJUnit addedUnit )
		{
			// Original JassCode
			BJPlayer addedUnitOwner = GetOwningPlayer(addedUnit);
			// If the player was crippled, this unit may have uncrippled him/her.
			if(  (playerIsCrippled[GetPlayerId(addedUnitOwner)])  )
			{
				MeleeCheckForCrippledPlayers();
			}
		}

		//===========================================================================
		public static void MeleeTriggerActionConstructCancel(  )
		{
			// Original JassCode
			MeleeCheckLostUnit(GetCancelledStructure());
		}

		//===========================================================================
		public static void MeleeTriggerActionUnitDeath(  )
		{
			// Original JassCode
			if(  (IsUnitType(GetDyingUnit(), UNIT_TYPE_STRUCTURE))  )
			{
				MeleeCheckLostUnit(GetDyingUnit());
			}
		}

		//===========================================================================
		public static void MeleeTriggerActionUnitConstructionStart(  )
		{
			// Original JassCode
			MeleeCheckAddedUnit(GetConstructingStructure());
		}

		//===========================================================================
		public static void MeleeTriggerActionPlayerDefeated(  )
		{
			// Original JassCode
			BJPlayer thePlayer = GetTriggerPlayer();
			CachePlayerHeroData(thePlayer);
			if(  (MeleeGetAllyCount(thePlayer) > 0)  )
			{
				// If at least one ally is still alive and kicking, share units with
				// them and proceed with death.
				ShareEverythingWithTeam(thePlayer);
				if(  (! meleeDefeated[GetPlayerId(thePlayer)])  )
				{
					MeleeDoDefeat(thePlayer);
				}
			}
			else
			{
				// If no living allies remain, swap all units and buildings over to
				// neutral_passive and proceed with death.
				MakeUnitsPassiveForTeam(thePlayer);
				if(  (! meleeDefeated[GetPlayerId(thePlayer)])  )
				{
					MeleeDoDefeat(thePlayer);
				}
			}
			MeleeCheckForLosersAndVictors();
		}

		//===========================================================================
		public static void MeleeTriggerActionPlayerLeft(  )
		{
			// Original JassCode
			BJPlayer thePlayer = GetTriggerPlayer();
			// Just show game over for observers when they leave
			if(  (IsPlayerObserver(thePlayer))  )
			{
				RemovePlayerPreserveUnitsBJ(thePlayer, PLAYER_GAME_RESULT_NEUTRAL, false);
				return;
			}
			CachePlayerHeroData(thePlayer);
			// This is the same as defeat except the player generates the message 
			// "player left the game" as opposed to "player was defeated".
			if(  (MeleeGetAllyCount(thePlayer) > 0)  )
			{
				// If at least one ally is still alive and kicking, share units with
				// them and proceed with death.
				ShareEverythingWithTeam(thePlayer);
				MeleeDoLeave(thePlayer);
			}
			else
			{
				// If no living allies remain, swap all units and buildings over to
				// neutral_passive and proceed with death.
				MakeUnitsPassiveForTeam(thePlayer);
				MeleeDoLeave(thePlayer);
			}
			MeleeCheckForLosersAndVictors();
		}

		//===========================================================================
		public static void MeleeTriggerActionAllianceChange(  )
		{
			// Original JassCode
			MeleeCheckForLosersAndVictors();
			MeleeCheckForCrippledPlayers();
		}

		//===========================================================================
		public static void MeleeTriggerTournamentFinishSoon(  )
		{
			// Original JassCode
			// Note: We may get this trigger multiple times
			int playerIndex;
			BJPlayer indexPlayer;
			double timeRemaining = GetTournamentFinishSoonTimeRemaining();
			if(  ! finishSoonAllExposed  )
			{
				finishSoonAllExposed = true;
				// Reset all crippled players and their timers, and hide the local crippled timer dialog
				playerIndex = 0;
				while( true )
				{
					indexPlayer = Player(playerIndex);
					if(  playerIsCrippled[playerIndex]  )
					{
						// Uncripple the player
						playerIsCrippled[playerIndex] = false;
						PauseTimer(crippledTimer[playerIndex]);
						if(  (GetLocalPlayer() == indexPlayer)  )
						{
							// Use only local code (no net traffic) within this block to avoid desyncs.
							// Hide the timer window.
							TimerDialogDisplay(crippledTimerWindows[playerIndex], false);
						}
					}
					playerIndex = playerIndex + 1;
					if(  playerIndex == MAX_PLAYERS )
						break;
				}
				// Expose all players
				MeleeExposeAllPlayers();
			}
			// Show the "finish soon" timer dialog and set the real time remaining
			TimerDialogDisplay(finishSoonTimerDialog, true);
			TimerDialogSetRealTimeRemaining(finishSoonTimerDialog, timeRemaining);
		}

		//===========================================================================
		public static bool MeleeWasUserPlayer( BJPlayer whichPlayer )
		{
            // Original JassCode
            BJPlayerSlotState slotState;
			if(  (GetPlayerController(whichPlayer) != MAP_CONTROL_USER)  )
			{
				return false;
			}
			slotState = GetPlayerSlotState(whichPlayer);
			return (slotState == PLAYER_SLOT_STATE_PLAYING || slotState == PLAYER_SLOT_STATE_LEFT);
		}

		//===========================================================================
		public static void MeleeTournamentFinishNowRuleA( int multiplier )
		{
			// Original JassCode
			int[] playerScore = new int[MAX_PLAYERS];
			int[] teamScore = new int[MAX_PLAYERS];
			BJForce[] teamForce = new BJForce[MAX_PLAYERS];
			int teamCount;
			int index;
			BJPlayer indexPlayer;
			int index2;
			BJPlayer indexPlayer2;
			int bestTeam;
			int bestScore;
			bool draw;
			// Compute individual player scores
			index = 0;
			while( true )
			{
				indexPlayer = Player(index);
				if(  MeleeWasUserPlayer(indexPlayer)  )
				{
					playerScore[index] = GetTournamentScore(indexPlayer);
					if(  playerScore[index] <= 0  )
					{
						playerScore[index] = 1;
					}
				}
				else
				{
					playerScore[index] = 0;
				}
				index = index + 1;
				if(  index == MAX_PLAYERS )
					break;
			}
			// Compute team scores and team forces
			teamCount = 0;
			index = 0;
			while( true )
			{
				if(  playerScore[index] != 0  )
				{
					indexPlayer = Player(index);
					teamScore[teamCount] = 0;
					teamForce[teamCount] = CreateForce();
					index2 = index;
					while( true )
					{
						if(  playerScore[index2] != 0  )
						{
							indexPlayer2 = Player(index2);
							if(  PlayersAreCoAllied(indexPlayer, indexPlayer2)  )
							{
								teamScore[teamCount] = teamScore[teamCount] + playerScore[index2];
								ForceAddPlayer(teamForce[teamCount], indexPlayer2);
								playerScore[index2] = 0;
							}
						}
						index2 = index2 + 1;
						if(  index2 == MAX_PLAYERS )
							break;
					}
					teamCount = teamCount + 1;
				}
				index = index + 1;
				if(  index == MAX_PLAYERS )
					break;
			}
			// The game is now over
			meleeGameOver = true;
			// There should always be at least one team, but continue to work if not
			if(  teamCount != 0  )
			{
				// Find best team score
				bestTeam = -1;
				bestScore = -1;
				index = 0;
				while( true )
				{
					if(  teamScore[index] > bestScore  )
					{
						bestTeam = index;
						bestScore = teamScore[index];
					}
					index = index + 1;
					if(  index == teamCount )
						break;
				}
				// Check whether the best team's score is 'multiplier' times better than
				// every other team. In the case of multiplier == 1 and exactly equal team
				// scores, the first team (which was randomly chosen by the server) will win.
				draw = false;
				index = 0;
				while( true )
				{
					if(  index != bestTeam  )
					{
						if(  bestScore < (multiplier * teamScore[index])  )
						{
							draw = true;
						}
					}
					index = index + 1;
					if(  index == teamCount )
						break;
				}
				if(  draw  )
				{
					// Give draw to all players on all teams
					index = 0;
					while( true )
					{
						ForForce(teamForce[index],  MeleeDoDrawEnum);
						index = index + 1;
						if(  index == teamCount )
							break;
					}
				}
				else
				{
					// Give defeat to all players on teams other than the best team
					index = 0;
					while( true )
					{
						if(  index != bestTeam  )
						{
							ForForce(teamForce[index],  MeleeDoDefeatEnum);
						}
						index = index + 1;
						if(  index == teamCount )
							break;
					}
					// Give victory to all players on the best team
					ForForce(teamForce[bestTeam],  MeleeDoVictoryEnum);
				}
			}
		}

		//===========================================================================
		public static void MeleeTriggerTournamentFinishNow(  )
		{
			// Original JassCode
			int rule = GetTournamentFinishNowRule();
			// If the game is already over, do nothing
			if(  meleeGameOver  )
			{
				return;
			}
			if(  (rule == 1)  )
			{
				// Finals games
				MeleeTournamentFinishNowRuleA(1);
			}
			else
			{
				// Preliminary games
				MeleeTournamentFinishNowRuleA(3);
			}
			// Since the game is over we should remove all observers
			MeleeRemoveObservers();
		}

		//===========================================================================
		public static void MeleeInitVictoryDefeat(  )
		{
			// Original JassCode
			BJTrigger trig;
			int index;
			BJPlayer indexPlayer;
			// Create a timer window for the "finish soon" timeout period, it has no timer
			// because it is driven by real time (outside of the game state to avoid desyncs)
			finishSoonTimerDialog = CreateTimerDialog(null);
			// Set a trigger to fire when we receive a "finish soon" game event
			trig = CreateTrigger();
			TriggerRegisterGameEvent(trig, EVENT_GAME_TOURNAMENT_FINISH_SOON);
			TriggerAddAction(trig,  MeleeTriggerTournamentFinishSoon);
			// Set a trigger to fire when we receive a "finish now" game event
			trig = CreateTrigger();
			TriggerRegisterGameEvent(trig, EVENT_GAME_TOURNAMENT_FINISH_NOW);
			TriggerAddAction(trig,  MeleeTriggerTournamentFinishNow);
			// Set up each player's mortality code.
			index = 0;
			while( true )
			{
				indexPlayer = Player(index);
				// Make sure this player slot is playing.
				if(  (GetPlayerSlotState(indexPlayer) == PLAYER_SLOT_STATE_PLAYING)  )
				{
					meleeDefeated[index] = false;
					meleeVictoried[index] = false;
					// Create a timer and timer window in case the player is crippled.
					playerIsCrippled[index] = false;
					playerIsExposed[index] = false;
					crippledTimer[index] = CreateTimer();
					crippledTimerWindows[index] = CreateTimerDialog(crippledTimer[index]);
					TimerDialogSetTitle(crippledTimerWindows[index], MeleeGetCrippledTimerMessage(indexPlayer));
					// Set a trigger to fire whenever a building is cancelled for this player.
					trig = CreateTrigger();
					TriggerRegisterPlayerUnitEvent(trig, indexPlayer, EVENT_PLAYER_UNIT_CONSTRUCT_CANCEL, null);
					TriggerAddAction(trig,  MeleeTriggerActionConstructCancel);
					// Set a trigger to fire whenever a unit dies for this player.
					trig = CreateTrigger();
					TriggerRegisterPlayerUnitEvent(trig, indexPlayer, EVENT_PLAYER_UNIT_DEATH, null);
					TriggerAddAction(trig,  MeleeTriggerActionUnitDeath);
					// Set a trigger to fire whenever a unit begins construction for this player
					trig = CreateTrigger();
					TriggerRegisterPlayerUnitEvent(trig, indexPlayer, EVENT_PLAYER_UNIT_CONSTRUCT_START, null);
					TriggerAddAction(trig,  MeleeTriggerActionUnitConstructionStart);
					// Set a trigger to fire whenever this player defeats-out
					trig = CreateTrigger();
					TriggerRegisterPlayerEvent(trig, indexPlayer, EVENT_PLAYER_DEFEAT);
					TriggerAddAction(trig,  MeleeTriggerActionPlayerDefeated);
					// Set a trigger to fire whenever this player leaves
					trig = CreateTrigger();
					TriggerRegisterPlayerEvent(trig, indexPlayer, EVENT_PLAYER_LEAVE);
					TriggerAddAction(trig,  MeleeTriggerActionPlayerLeft);
					// Set a trigger to fire whenever this player changes his/her alliances.
					trig = CreateTrigger();
					TriggerRegisterPlayerAllianceChange(trig, indexPlayer, ALLIANCE_PASSIVE);
					TriggerRegisterPlayerStateEvent(trig, indexPlayer, PLAYER_STATE_ALLIED_VICTORY, EQUAL, 1);
					TriggerAddAction(trig,  MeleeTriggerActionAllianceChange);
				}
				else
				{
					meleeDefeated[index] = true;
					meleeVictoried[index] = false;
					// Handle leave events for observers
					if(  (IsPlayerObserver(indexPlayer))  )
					{
						// Set a trigger to fire whenever this player leaves
						trig = CreateTrigger();
						TriggerRegisterPlayerEvent(trig, indexPlayer, EVENT_PLAYER_LEAVE);
						TriggerAddAction(trig,  MeleeTriggerActionPlayerLeft);
					}
				}
				index = index + 1;
				if(  index == MAX_PLAYERS )
					break;
			}
			// Test for victory / defeat at startup, in case the user has already won / lost.
			// Allow for a short time to pass first, so that the map can finish loading.
			TimerStart(CreateTimer(), 2.0, false,  MeleeTriggerActionAllianceChange);
		}

		//***************************************************************************
		//*
		//*  Player Slot Availability
		//*
		//***************************************************************************
		//===========================================================================
		public static void CheckInitPlayerSlotAvailability(  )
		{
			// Original JassCode
			int index;
			if(  (! slotControlReady)  )
			{
				index = 0;
				while( true )
				{
					slotControlUsed[index] = false;
					slotControl[index] = MAP_CONTROL_USER;
					index = index + 1;
					if(  index == MAX_PLAYERS )
						break;
				}
				slotControlReady = true;
			}
		}

		//===========================================================================
		public static void SetPlayerSlotAvailable( BJPlayer whichPlayer , BJMapControl control )
		{
			// Original JassCode
			int playerIndex = GetPlayerId(whichPlayer);
			CheckInitPlayerSlotAvailability();
			slotControlUsed[playerIndex] = true;
			slotControl[playerIndex] = control;
		}

		//***************************************************************************
		//*
		//*  Generic Template Player-slot Initialization
		//*
		//***************************************************************************
		//===========================================================================
		public static void TeamInitPlayerSlots( int teamCount )
		{
			// Original JassCode
			int index;
			BJPlayer indexPlayer;
			int team;
			SetTeams(teamCount);
			CheckInitPlayerSlotAvailability();
			index = 0;
			team = 0;
			while( true )
			{
				if(  (slotControlUsed[index])  )
				{
					indexPlayer = Player(index);
					SetPlayerTeam( indexPlayer, team );
					team = team + 1;
					if(  (team >= teamCount)  )
					{
						team = 0;
					}
				}
				index = index + 1;
				if(  index == MAX_PLAYERS )
					break;
			}
		}

		//===========================================================================
		public static void MeleeInitPlayerSlots(  )
		{
			// Original JassCode
			TeamInitPlayerSlots(MAX_PLAYERS);
		}

		//===========================================================================
		public static void FFAInitPlayerSlots(  )
		{
			// Original JassCode
			TeamInitPlayerSlots(MAX_PLAYERS);
		}

		//===========================================================================
		public static void OneOnOneInitPlayerSlots(  )
		{
			// Original JassCode
			// Limit the game to 2 players.
			SetTeams(2);
			SetPlayers(2);
			TeamInitPlayerSlots(2);
		}

		//===========================================================================
		public static void InitGenericPlayerSlots(  )
		{
			// Original JassCode
			BJGameType gType = GetGameTypeSelected();
			if(  (gType == GAME_TYPE_MELEE)  )
			{
				MeleeInitPlayerSlots();
			}
			else if(  (gType == GAME_TYPE_FFA)  )
			{
				FFAInitPlayerSlots();
			}
			else if(  (gType == GAME_TYPE_USE_MAP_SETTINGS)  )
			{
				// Do nothing; the map-specific script handles this.
			}
			else if(  (gType == GAME_TYPE_ONE_ON_ONE)  )
			{
				OneOnOneInitPlayerSlots();
			}
			else if(  (gType == GAME_TYPE_TWO_TEAM_PLAY)  )
			{
				TeamInitPlayerSlots(2);
			}
			else if(  (gType == GAME_TYPE_THREE_TEAM_PLAY)  )
			{
				TeamInitPlayerSlots(3);
			}
			else if(  (gType == GAME_TYPE_FOUR_TEAM_PLAY)  )
			{
				TeamInitPlayerSlots(4);
			}
			else
			{
				// Unrecognized Game Type
			}
		}

		//***************************************************************************
		//*
		//*  Blizzard.j Initialization
		//*
		//***************************************************************************
		//===========================================================================
		public static void SetDNCSoundsDawn(  )
		{
			// Original JassCode
			if(  useDawnDuskSounds  )
			{
				StartSound(dawnSound);
			}
		}

		//===========================================================================
		public static void SetDNCSoundsDusk(  )
		{
			// Original JassCode
			if(  useDawnDuskSounds  )
			{
				StartSound(duskSound);
			}
		}

		//===========================================================================
		public static void SetDNCSoundsDay(  )
		{
			// Original JassCode
			double ToD = GetTimeOfDay();
			if(  (ToD >= TOD_DAWN && ToD < TOD_DUSK) && ! dncIsDaytime  )
			{
				dncIsDaytime = true;
				// change ambient sounds
				StopSound(nightAmbientSound, false, true);
				StartSound(dayAmbientSound);
			}
		}

		//===========================================================================
		public static void SetDNCSoundsNight(  )
		{
			// Original JassCode
			double ToD = GetTimeOfDay();
			if(  (ToD < TOD_DAWN || ToD >= TOD_DUSK) && dncIsDaytime  )
			{
				dncIsDaytime = false;
				// change ambient sounds
				StopSound(dayAmbientSound, false, true);
				StartSound(nightAmbientSound);
			}
		}

		//===========================================================================
		public static void InitDNCSounds(  )
		{
			// Original JassCode
			// Create sounds to be played at dawn and dusk.
			dawnSound = CreateSoundFromLabel("RoosterSound", false, false, false, 10000, 10000);
			duskSound = CreateSoundFromLabel("WolfSound", false, false, false, 10000, 10000);
			// Set up triggers to respond to dawn and dusk.
			dncSoundsDawn = CreateTrigger();
			TriggerRegisterGameStateEvent(dncSoundsDawn, GAME_STATE_TIME_OF_DAY, EQUAL, TOD_DAWN);
			TriggerAddAction(dncSoundsDawn,  SetDNCSoundsDawn);
			dncSoundsDusk = CreateTrigger();
			TriggerRegisterGameStateEvent(dncSoundsDusk, GAME_STATE_TIME_OF_DAY, EQUAL, TOD_DUSK);
			TriggerAddAction(dncSoundsDusk,  SetDNCSoundsDusk);
			// Set up triggers to respond to changes from day to night or vice-versa.
			dncSoundsDay = CreateTrigger();
			TriggerRegisterGameStateEvent(dncSoundsDay, GAME_STATE_TIME_OF_DAY, GREATER_THAN_OR_EQUAL, TOD_DAWN);
			TriggerRegisterGameStateEvent(dncSoundsDay, GAME_STATE_TIME_OF_DAY, LESS_THAN, TOD_DUSK);
			TriggerAddAction(dncSoundsDay,  SetDNCSoundsDay);
			dncSoundsNight = CreateTrigger();
			TriggerRegisterGameStateEvent(dncSoundsNight, GAME_STATE_TIME_OF_DAY, LESS_THAN, TOD_DAWN);
			TriggerRegisterGameStateEvent(dncSoundsNight, GAME_STATE_TIME_OF_DAY, GREATER_THAN_OR_EQUAL, TOD_DUSK);
			TriggerAddAction(dncSoundsNight,  SetDNCSoundsNight);
		}

		//===========================================================================
		public static void InitBlizzardGlobals(  )
		{
			// Original JassCode
			int index;
			int userControlledPlayers;
			BJVersion v;
			// Init filter function vars
			filterIssueHauntOrderAtLocBJ = ( IssueHauntOrderAtLocBJFilter);
			filterEnumDestructablesInCircleBJ = ( EnumDestructablesInCircleBJFilter);
			filterGetUnitsInRectOfPlayer = ( GetUnitsInRectOfPlayerFilter);
			filterGetUnitsOfTypeIdAll = ( GetUnitsOfTypeIdAllFilter);
			filterGetUnitsOfPlayerAndTypeId = ( GetUnitsOfPlayerAndTypeIdFilter);
			filterMeleeTrainedUnitIsHeroBJ = ( MeleeTrainedUnitIsHeroBJFilter);
			filterLivingPlayerUnitsOfTypeId = ( LivingPlayerUnitsOfTypeIdFilter);
			// Init force presets
			index = 0;
			while( true )
			{
				if(  index == MAX_PLAYER_SLOTS )
					break;
				FORCE_PLAYER[index] = CreateForce();
				ForceAddPlayer(FORCE_PLAYER[index], Player(index));
				index = index + 1;
			}
			FORCE_ALL_PLAYERS = CreateForce();
			ForceEnumPlayers(FORCE_ALL_PLAYERS, null);
			// Init Cinematic Mode history
			cineModePriorSpeed = GetGameSpeed();
			cineModePriorFogSetting = IsFogEnabled();
			cineModePriorMaskSetting = IsFogMaskEnabled();
			// Init Trigger Queue
			index = 0;
			while( true )
			{
				if(  index >= MAX_QUEUED_TRIGGERS )
					break;
				queuedExecTriggers[index] = null;
				queuedExecUseConds[index] = false;
				index = index + 1;
			}
			// Init singleplayer check
			isSinglePlayer = false;
			userControlledPlayers = 0;
			index = 0;
			while( true )
			{
				if(  index >= MAX_PLAYERS )
					break;
				if(  (GetPlayerController(Player(index)) == MAP_CONTROL_USER && GetPlayerSlotState(Player(index)) == PLAYER_SLOT_STATE_PLAYING)  )
				{
					userControlledPlayers = userControlledPlayers + 1;
				}
				index = index + 1;
			}
			isSinglePlayer = (userControlledPlayers == 1);
			// Init sounds
			//set pingMinimapSound = CreateSoundFromLabel("AutoCastButtonClick", false, false, false, 10000, 10000)
			rescueSound = CreateSoundFromLabel("Rescue", false, false, false, 10000, 10000);
			questDiscoveredSound = CreateSoundFromLabel("QuestNew", false, false, false, 10000, 10000);
			questUpdatedSound = CreateSoundFromLabel("QuestUpdate", false, false, false, 10000, 10000);
			questCompletedSound = CreateSoundFromLabel("QuestCompleted", false, false, false, 10000, 10000);
			questFailedSound = CreateSoundFromLabel("QuestFailed", false, false, false, 10000, 10000);
			questHintSound = CreateSoundFromLabel("Hint", false, false, false, 10000, 10000);
			questSecretSound = CreateSoundFromLabel("SecretFound", false, false, false, 10000, 10000);
			questItemAcquiredSound = CreateSoundFromLabel("ItemReward", false, false, false, 10000, 10000);
			questWarningSound = CreateSoundFromLabel("Warning", false, false, false, 10000, 10000);
			victoryDialogSound = CreateSoundFromLabel("QuestCompleted", false, false, false, 10000, 10000);
			defeatDialogSound = CreateSoundFromLabel("QuestFailed", false, false, false, 10000, 10000);
			// Init corpse creation triggers.
			DelayedSuspendDecayCreate();
			// Init version-specific data
			v = VersionGet();
			if(  (v == VERSION_REIGN_OF_CHAOS)  )
			{
				MELEE_MAX_TWINKED_HEROES = MELEE_MAX_TWINKED_HEROES_V0;
			}
			else
			{
				MELEE_MAX_TWINKED_HEROES = MELEE_MAX_TWINKED_HEROES_V1;
			}
		}

		//===========================================================================
		public static void InitQueuedTriggers(  )
		{
			// Original JassCode
			queuedExecTimeout = CreateTrigger();
			TriggerRegisterTimerExpireEvent(queuedExecTimeout, queuedExecTimeoutTimer);
			TriggerAddAction(queuedExecTimeout,  QueuedTriggerDoneBJ);
		}

		//===========================================================================
		public static void InitMapRects(  )
		{
			// Original JassCode
			mapInitialPlayableArea = Rect(GetCameraBoundMinX()-GetCameraMargin(CAMERA_MARGIN_LEFT), GetCameraBoundMinY()-GetCameraMargin(CAMERA_MARGIN_BOTTOM), GetCameraBoundMaxX()+GetCameraMargin(CAMERA_MARGIN_RIGHT), GetCameraBoundMaxY()+GetCameraMargin(CAMERA_MARGIN_TOP));
			mapInitialCameraBounds = GetCurrentCameraBoundsMapRectBJ();
		}

		//===========================================================================
		public static void InitSummonableCaps(  )
		{
			// Original JassCode
			int index;
			index = 0;
			while( true )
			{
				// upgraded units
				SetPlayerTechMaxAllowed(Player(index), UnitId( "hrtt" ), 0);
				SetPlayerTechMaxAllowed(Player(index), UnitId( "otbk" ), 0);
				// max skeletons per player
				SetPlayerTechMaxAllowed(Player(index), UnitId( "uske" ), MAX_SKELETONS);
				index = index + 1;
				if(  index == MAX_PLAYERS )
					break;
			}
		}

		//===========================================================================
		// Update the per-class stock limits.
		//
		public static void UpdateStockAvailability( BJItem whichItem )
		{
			// Original JassCode
			BJItemType iType = GetItemType(whichItem);
			int iLevel = GetItemLevel(whichItem);
			// Update allowed type/level combinations.
			if(  (iType == ITEM_TYPE_PERMANENT)  )
			{
				stockAllowedPermanent[iLevel] = true;
			}
			else if(  (iType == ITEM_TYPE_CHARGED)  )
			{
				stockAllowedCharged[iLevel] = true;
			}
			else if(  (iType == ITEM_TYPE_ARTIFACT)  )
			{
				stockAllowedArtifact[iLevel] = true;
			}
			else
			{
				// Not interested in this item type - ignore the item.
			}
		}

		//===========================================================================
		// Find a sellable item of the given type and level, and then add it.
		//
		public static void UpdateEachStockBuildingEnum(  )
		{
			// Original JassCode
			int iteration = 0;
			int pickedItemId;
			while( true )
			{
				pickedItemId = ChooseRandomItemEx(stockPickedItemType, stockPickedItemLevel);
				if(  IsItemIdSellable(pickedItemId) )
					break;
				// If we get hung up on an entire class/level combo of unsellable
				// items, or a very unlucky series of random numbers, give up.
				iteration = iteration + 1;
				if(  (iteration > STOCK_MAX_ITERATIONS)  )
				{
					return;
				}
			}
			AddItemToStock(GetEnumUnit(), pickedItemId, 1, 1);
		}

		//===========================================================================
		public static void UpdateEachStockBuilding( BJItemType iType , int iLevel )
		{
			// Original JassCode
			BJGroup g;
			stockPickedItemType = iType;
			stockPickedItemLevel = iLevel;
			g = CreateGroup();
			GroupEnumUnitsOfType(g, "marketplace", null);
			ForGroup(g,  UpdateEachStockBuildingEnum);
			DestroyGroup(g);
		}

		//===========================================================================
		// Update stock inventory.
		//
		public static void PerformStockUpdates(  )
		{
			// Original JassCode
			int pickedItemId;
			BJItemType pickedItemType = new BJItemType();
			int pickedItemLevel = 0;
			int allowedCombinations = 0;
			int iLevel;
			// Give each type/level combination a chance of being picked.
			iLevel = 1;
			while( true )
			{
				if(  (stockAllowedPermanent[iLevel])  )
				{
					allowedCombinations = allowedCombinations + 1;
					if(  (GetRandomInt(1, allowedCombinations) == 1)  )
					{
						pickedItemType = ITEM_TYPE_PERMANENT;
						pickedItemLevel = iLevel;
					}
				}
				if(  (stockAllowedCharged[iLevel])  )
				{
					allowedCombinations = allowedCombinations + 1;
					if(  (GetRandomInt(1, allowedCombinations) == 1)  )
					{
						pickedItemType = ITEM_TYPE_CHARGED;
						pickedItemLevel = iLevel;
					}
				}
				if(  (stockAllowedArtifact[iLevel])  )
				{
					allowedCombinations = allowedCombinations + 1;
					if(  (GetRandomInt(1, allowedCombinations) == 1)  )
					{
						pickedItemType = ITEM_TYPE_ARTIFACT;
						pickedItemLevel = iLevel;
					}
				}
				iLevel = iLevel + 1;
				if(  iLevel > MAX_ITEM_LEVEL )
					break;
			}
			// Make sure we found a valid item type to add.
			if(  (allowedCombinations == 0)  )
			{
				return;
			}
			UpdateEachStockBuilding(pickedItemType, pickedItemLevel);
		}

		//===========================================================================
		// Perform the first update, and then arrange future updates.
		//
		public static void StartStockUpdates(  )
		{
			// Original JassCode
			PerformStockUpdates();
			TimerStart(stockUpdateTimer, STOCK_RESTOCK_INTERVAL, true,  PerformStockUpdates);
		}

		//===========================================================================
		public static void RemovePurchasedItem(  )
		{
			// Original JassCode
			RemoveItemFromStock(GetSellingUnit(), GetItemTypeId(GetSoldItem()));
		}

		//===========================================================================
		public static void InitNeutralBuildings(  )
		{
			// Original JassCode
			int iLevel;
			// Chart of allowed stock items.
			iLevel = 0;
			while( true )
			{
				stockAllowedPermanent[iLevel] = false;
				stockAllowedCharged[iLevel] = false;
				stockAllowedArtifact[iLevel] = false;
				iLevel = iLevel + 1;
				if(  iLevel > MAX_ITEM_LEVEL )
					break;
			}
			// Limit stock inventory slots.
			SetAllItemTypeSlots(MAX_STOCK_ITEM_SLOTS);
			SetAllUnitTypeSlots(MAX_STOCK_UNIT_SLOTS);
			// Arrange the first update.
			stockUpdateTimer = CreateTimer();
			TimerStart(stockUpdateTimer, STOCK_RESTOCK_INITIAL_DELAY, false,  StartStockUpdates);
			// Set up a trigger to fire whenever an item is sold.
			stockItemPurchased = CreateTrigger();
			TriggerRegisterPlayerUnitEvent(stockItemPurchased, Player(PLAYER_NEUTRAL_PASSIVE), EVENT_PLAYER_UNIT_SELL_ITEM, null);
			TriggerAddAction(stockItemPurchased,  RemovePurchasedItem);
		}

		//===========================================================================
		public static void MarkGameStarted(  )
		{
			// Original JassCode
			gameStarted = true;
			DestroyTimer(gameStartedTimer);
		}

		//===========================================================================
		public static void DetectGameStarted(  )
		{
			// Original JassCode
			gameStartedTimer = CreateTimer();
			TimerStart(gameStartedTimer, GAME_STARTED_THRESHOLD, false,  MarkGameStarted);
		}

		//===========================================================================
		public static void InitBlizzard(  )
		{
			// Original JassCode
			// Set up the Neutral Victim player slot, to torture the abandoned units
			// of defeated players.  Since some triggers expect this player slot to
			// exist, this is performed for all maps.
			ConfigureNeutralVictim();
			InitBlizzardGlobals();
			InitQueuedTriggers();
			InitRescuableBehaviorBJ();
			InitDNCSounds();
			InitMapRects();
			InitSummonableCaps();
			InitNeutralBuildings();
			DetectGameStarted();
		}

		//***************************************************************************
		//*
		//*  Random distribution
		//*
		//*  Used to select a random object from a given distribution of chances
		//*
		//*  - RandomDistReset clears the distribution list
		//*
		//*  - RandomDistAddItem adds a new object to the distribution list
		//*    with a given identifier and an integer chance to be chosen
		//*
		//*  - RandomDistChoose will use the current distribution list to choose
		//*    one of the objects randomly based on the chance distribution
		//*  
		//*  Note that the chances are effectively normalized by their sum,
		//*  so only the relative values of each chance are important
		//*
		//***************************************************************************
		//===========================================================================
		public static void RandomDistReset(  )
		{
			// Original JassCode
			randDistCount = 0;
		}

		//===========================================================================
		public static void RandomDistAddItem( int inID , int inChance )
		{
			// Original JassCode
			randDistID[randDistCount] = inID;
			randDistChance[randDistCount] = inChance;
			randDistCount = randDistCount + 1;
		}

		//===========================================================================
		public static int RandomDistChoose(  )
		{
			// Original JassCode
			int sum = 0;
			int chance = 0;
			int index;
			int foundID = -1;
			bool done;
			// No items?
			if(  (randDistCount == 0)  )
			{
				return -1;
			}
			// Find sum of all chances
			index = 0;
			while( true )
			{
				sum = sum + randDistChance[index];
				index = index + 1;
				if(  index == randDistCount )
					break;
			}
			// Choose random number within the total range
			chance = GetRandomInt(1, sum);
			// Find ID which corresponds to this chance
			index = 0;
			sum = 0;
			done = false;
			while( true )
			{
				sum = sum + randDistChance[index];
				if(  (chance <= sum)  )
				{
					foundID = randDistID[index];
					done = true;
				}
				index = index + 1;
				if(  (index == randDistCount)  )
				{
					done = true;
				}
				if(  done == true )
					break;
			}
			return foundID;
		}

		//***************************************************************************
		//*
		//*  Drop item
		//*
		//*  Makes the given unit drop the given item
		//*
		//*  Note: This could potentially cause problems if the unit is standing
		//*        right on the edge of an unpathable area and happens to drop the
		//*        item into the unpathable area where nobody can get it...
		//*
		//***************************************************************************
		public static BJItem UnitDropItem( BJUnit inUnit , int inItemID )
		{
			// Original JassCode
			double x;
			double y;
			double radius = 32;
			double unitX;
			double unitY;
			BJItem droppedItem;
			if(  (inItemID == -1)  )
			{
				return null;
			}
			unitX = GetUnitX(inUnit);
			unitY = GetUnitY(inUnit);
			x = GetRandomReal(unitX - radius, unitX + radius);
			y = GetRandomReal(unitY - radius, unitY + radius);
			droppedItem = CreateItem(inItemID, x, y);
			SetItemDropID(droppedItem, GetUnitTypeId(inUnit));
			UpdateStockAvailability(droppedItem);
			return droppedItem;
		}

		//===========================================================================
		public static BJItem WidgetDropItem( BJWidget inWidget , int inItemID )
		{
			// Original JassCode
			double x;
			double y;
			double radius = 32;
			double widgetX;
			double widgetY;
			if(  (inItemID == -1)  )
			{
				return null;
			}
			widgetX = GetWidgetX(inWidget);
			widgetY = GetWidgetY(inWidget);
			x = GetRandomReal(widgetX - radius, widgetX + radius);
			y = GetRandomReal(widgetY - radius, widgetY + radius);
			return CreateItem(inItemID, x, y);
		}

	}

